{"./":{"url":"./","title":"缘起","keywords":"","body":" 缘起 在全球，随着Flutter被越来越多的知名公司应用在自己的商业APP中，Flutter这门新技术也逐渐进入了移动开发者的视野，尤其是当Google在2018年IO大会上发布了第一个Preview版本后，国内刮起来一股学习Flutter的热潮。 为了更好的方便帮助中国开发者了解这门新技术，我们，Flutter中文网，前后发起了Flutter翻译计划、Flutter开源计划，前者主要的任务是翻译Flutter官方文档，后者则主要是开发一些常用的包来丰富Flutter生态，帮助开发者提高开发效率。而时至今日，这两件事取得的效果还都不错！ 目前，Flutter中文官网日PV在5W左右，每日独立访问人数8000多。 自今年我们在github建立官方账号以来，前后开源了cookieJar、dio、flukit等多个项目，而dio在开源两周后，就迅速成为Flutter第三方包中Star排名第一的开源库。 之前，有很多次被没用过Flutter但对其保持好奇的开发者问到”Flutter的性能究竟怎样？“，”开发体验真的好吗？“这类问题。当时之所以会有很多这样的问题，主要的原因就是那时Flutter的成功案例太少，虽然国内闲鱼是第一个引入Flutter的商业应用，但初期也只是在很少的页面使用了Flutter，Flutter究竟能否适合用于完整项目缺乏考验。那时，我就想如果能用Flutter开发一个完整的APP发布到应用商店，这样开发者就可以在犹豫的时候可以先实际感受一下Flutter的流畅度，这样有个直观的了解后，就会容易做出判断，为此，我开发了Gitme，它是一个Github客户端，它支持了源码浏览、Issue、Label等Github的大多数功能。到目前为止，通过Gitme登录过Github账号的用户有5000多，日活用户有500。更重要的是，有很多人正是用了Gitme后，才来学flutter的。 虽然做的事情已经够多了，但是仍有一些很有必要去做的事情，由于时间原因，一直被搁置。 随着学习Flutter的人越来越多，一部分开发者通过查看官网的文档就能入门，但也有很多开发者感觉学习时有些吃力，而这主要的原因是没有一个资料去系统的学习Flutter。 我们虽然翻译了官方文档，但是对于海量的SDK文档，基本很难去全部翻译。而那时，电子工业出版社正好找到了我，希望我能写一本Flutter实战类的书籍。 这个想法听起来不错，书最大的好处就是可以系统性的介绍一门新技术，但由于我平时工作太忙，周末时间已经有很多花费在维护中文网和开源项目上了，所以此事不得不推迟，而直到今天，你现在看到的，也仍然不是完整的内容，目录灰色的部分都还没有写，那什么时候能写完？ 如果只靠我一个人，也只能等我有空了才能写，但是今年实在是太忙了！当然，还是有一些方法可以加快进度，比如大家一起来写，本书已经开源，有志之士都可以提PR，然后需要做好的就是Review和校稿；当然还有一个不能保证一定有用的办法就是点击下面的”打赏“按钮，然后发一个大红包，这样作者拿了钱，说不定会不好意思慢慢吞吞的写，毕竟是收了钱的，哈哈。 最后再说一下为什么本书要开源。既然是电子工业出版社约的稿，就这么公开，难道将来就不会冲击实体书的销量？这个问题我是仔细考虑过的，很多写过书的人可能都知道，写技术书是不赚钱的，能收获的也就是一点点名气，而我吧却只喜欢钱，既然赚不到钱，那何不直接公开得了…当然还有另外一个原因就是要做实体书的话，最后和编辑校稿会花费很多时间，可是我实在是没时间了，很可能会放弃实体书出版，为了防止本书最后因不能正常出版而不能被大家看到，所以最终决定了开源。 最后，如果您发现本书中的错误，欢迎点击右上角的”编辑按钮“，提PR。如果您想一起参与本书创作，可以参考《Flutter实战》贡献指南。 最后，知识是应该付费的，创作不易，开源不等于免费，如果您是本书读者并手头宽裕，可以点击下面打赏按钮打赏；当然，如果您囊中羞涩，您也可以阅读本书，但我对您有个小小的要求，希望您在阅读的过程中能积极参与到本书的纠错以及未完成内容的创作上来，也算是有所付出。 "},"chapter1/":{"url":"chapter1/","title":"起步","keywords":"","body":"本章目录 移动开发技术简介 Flutter简介 搭建Flutter开发环境 Dart语言简介 "},"chapter1/mobile_development_intro.html":{"url":"chapter1/mobile_development_intro.html","title":"移动开发技术简介","keywords":"","body":"移动开发技术简介 原生开发与跨平台技术 原生开发 原生应用程序是指某一个移动平台（比如iOS或安卓）所特有的应用，使用相应平台支持的开发工具和语言，并直接调用系统提供的SDK API。比如Android原生应用就是指使用Java或Kotlin语言直接调用Android SDK开发的应用程序；而iOS原生应用就是指通过Objective-C或Swift语言直接调用iOS SDK开发的应用程序。原生开发有以下主要优势： 可访问平台全部功能（GPS、摄像头）； 速度快、性能高、可以实现复杂动画及绘制，整体用户体验好； 主要缺点： 平台特定，开发成本高；不同平台必须维护不同代码，人力成本随之变大； 内容固定，动态化弱，大多数情况下，有新功能更新时只能发版； 在移动互联网发展初期，业务场景并不复杂，原生开发还可以应对产品需求迭代。 但近几年，随着物联网时代到来、移动互联网高歌猛进，日新月异，在很多业务场景中，传统的纯原生开发已经不能满足日益增长的业务需求。主要表现在： 动态化内容需求增大；当需求发生变化时，纯原生应用需要通过版本升级来更新内容，但应用上架、审核是需要周期的，这对高速变化的互联网时代来说是很难接受的，所以，对应用动态化(不发版也可以更新应用内容)的需求就变的迫在眉睫。 业务需求变化快，开发成本变大；由于原生开发一般都要维护Android、iOS两个开发团队，版本迭代时，无论人力成本，还是测试成本都会变大。 总结一下，纯原生开发主要面临动态化和开发成本两个问题，而针对这两个问题，诞生了一些跨平台的动态化框架。 跨平台技术简介 针对原生开发面临问题，人们一直都在努力寻找好的解决方案，而时至今日，已经有很多跨平台框架(注意，本书中所指的“跨平台”若无特殊说明，即特指Android和iOS两个平台)，根据其原理，主要分为三类： H5+原生（Cordova、Ionic、微信小程序） JavaScript开发+原生渲染 （React Native、Weex、快应用） 自绘UI+原生(QT for mobile、Flutter) 在接下来的章节中我们逐个来看看这三类框架的原理及优缺点。 Hybrid技术简介 H5+原生混合开发 这类框架主要原理就是将APP的一部分需要动态变动的内容通过H5来实现，通过原生的网页加载控件WebView (Android)或WKWebView（ios）来加载（以后若无特殊说明，我们用WebView来统一指代android和ios中的网页加载控件）。这样一来，H5部分是可以随时改变而不用发版，动态化需求能满足；同时，由于h5代码只需要一次开发，就能同时在Android和iOS两个平台运行，这也可以减小开发成本，也就是说，h5部分功能越多，开发成本就越小。我们称这种h5+原生的开发模式为混合开发 ，采用混合模式开发的APP我们称之为混合应用或Hybrid APP ，如果一个应用的大多数功能都是H5实现的话，我们称其为Web APP 。 目前混合开发框架的典型代表有：Cordova、Ionic 和微信小程序，值得一提的是微信小程序目前是在webview中渲染的，并非原生渲染，但将来有可能会采用原生渲染。 混合开发技术点 如之前所述，原生开发可以访问平台所有功能，而混合开发中，h5代码是运行在WebView中，而WebView实质上就是一个浏览器内核，其JavaScript依然运行在一个权限受限的沙箱中，所以对于大多数系统能力都没有访问权限，如无法访问文件系统、不能使用蓝牙等。所以，对于H5不能实现的功能，都需要原生去做。而混合框架一般都会在原生代码中预先实现一些访问系统能力的API， 然后暴露给WebView以供JavaScript调用，这样一来，WebView就成为了JavaScript与原生API之间通信的桥梁，主要负责JavaScript与原生之间传递调用消息，而消息的传递必须遵守一个标准的协议，它规定了消息的格式与含义，我们把依赖于WebView的用于在JavaScript与原生之间通信并实现了某种消息传输协议的工具称之为WebView JavaScript Bridge, 简称 JsBridge，它也是混合开发框架的核心。 示例：JavaScript调用原生API获取手机型号 下面我们以Android为例，实现一个获取手机型号的原生API供JavaScript调用。在这个示例中将展示JavaScript调用原生API的流程，读者可以直观的感受一下调用流程。我们选用笔者在Github上开源的dsBridge作为JsBridge来进行通信。dsBridge是一个支持同步调用的跨平台的JsBridge，此示例中只使用其同步调用功能。 首先在原生中实现获取手机型号的API getPhoneModel class JSAPI{ @JavascriptInterface public Object getPhoneModel(Object msg){ return Build.MODEL; } } 将原生API通过WebView注册到JsBridge中 import wendu.dsbridge.DWebView ... //DWebView继承自WebView，由dsBridge提供 DWebView dwebView= (DWebView) findViewById(R.id.dwebview); //注册原生API到JsBridge dwebView.addJavascriptObject(new JsAPI(), null); 在JavaScript中调用原生API var dsBridge=require(\"dsbridge\") //直接调用原生API `getPhoneModel` var model=dsBridge.call(\"getPhoneModel\"); //打印机型 console.log(model); 上面示例演示了JavaScript调用原生API的过程，同样的，一般来说优秀的JsBridge也支持原生调用JavaScript，dsBridge也是支持的，如果您感兴趣，可以去github dsBridge项目主页查看。 现在，我们回头来看一下，混合应用无非就是在第一步中预先实现一系列API供JavaScript调用，让JavaScript有访问系统的能力，看到这里，我相信你也可以自己实现一个混合开发框架了。 总结 混合应用的优点是动态内容是H5，web技术栈，社区及资源丰富，缺点是性能不好，对于复杂用户界面或动画，webview不堪重任。 React Native和Weex 本篇主要介绍一下 JavaScript开发+原生渲染的跨平台框架原理。 React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和Android两个平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。 由于RN和React原理相通，并且Flutter也是受React启发，很多思想也都是相通的，万丈高楼平地起，我们有必要深入了解一下React原理。React是一个响应式的Web框架，我们先了解一下两个重要的概念：Dom树与响应式编程。 DOM树与控件树 文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标志语言的标准编程接口，一种独立于平台和语言的方式访问和修改一个文档的内容和结构。换句话说，这是表示和处理一个HTML或XML文档的标准接口。简单来说，DOM就是文档树，与用户界面控件树对应，在前端开发中通常指HTML对应的渲染树，但广义的DOM也可以指Android中的XML布局文件对应的控件树，而术语DOM操作就是指直接来操作渲染树（或控件树）， 因此，可以看到其实DOM树和控件树是等价的概念，只不过前者常用语Web开发中，而后者常用于原生开发中。 响应式编程 React中提出一个重要思想：状态改变则UI随之自动改变，而React框架本身就是响应用户状态改变的事件而执行重新构建用户界面的工作，这就是典型的响应式编程范式，下面我们总结一下React中响应式原理： 开发者只需关注状态转移（数据），当状态发生变化，React框架会自动根据新的状态重新构建UI。 React框架在接收到用户状态改变通知后，会根据当前渲染树，结合最新的状态改变，通过Diff算法，计算出树中变化的部分，然后只更新变化的部分（DOM操作），从而避免整棵树重构，提高性能。 值得注意的是，在第二步中，状态变化后React框架并不会立即去计算并渲染DOM树的变化部分，相反，React会在DOM的基础上建立一个抽象层，即虚拟DOM树，对数据和状态所做的任何改动，都会被自动且高效的同步到虚拟DOM，最后再批量同步到真实DOM中，而不是每次改变都去操作一下DOM。为什么不能每次改变都直接去操作DOM树？这是因为在浏览器中每一次DOM操作都有可能引起浏览器的重绘或回流： 如果DOM只是外观风格发生变化，如颜色变化，会导致浏览器重绘界面。 如果DOM树的结构发生变化，如尺寸、布局、节点隐藏等导致，浏览器就需要回流（及重新排版布局）。 而浏览器的重绘和回流都是比较昂贵的操作，如果每一次改变都直接对DOM进行操作，这会带来性能问题，而批量操作只会触发一次DOM更新。 思考题：Diff操作和DOM批量更新难道不应该是浏览器的职责吗？第三方框架中去做合不合适？ 此处需要有一张插图 React Native 上文已经提到React Native 是React 在原生移动应用平台的衍生产物，那两者主要的区别是什么呢？其实，主要的区别在于虚拟DOM映射的对象是什么？React中虚拟DOM最终会映射为浏览器DOM树，而RN中虚拟DOM会通过 JavaScriptCore 映射为原生控件树。 JavaScriptCore 是一个JavaScript解释器，它在React Native中主要有两个作用： 为JavaScript提供运行环境。 是JavaScript与原生应用之间通信的桥梁，作用和JsBridge一样，事实上，在iOS中，很多JsBridge的实现都是基于 JavaScriptCore 。 而RN中将虚拟DOM映射为原生控件的过程中分两步： 布局消息传递； 将虚拟DOM布局信息传递给原生； 原生根据布局信息通过对应的原生控件渲染控件树； 至此，React Native 便实现了跨平台。 相对于混合应用，由于React Native是原生控件渲染，所以性能会比混合应用中H5好很多，同时React Native是Web开发技术栈，也只需维护一份代码，同样是跨平台框架。 Weex Weex是阿里巴巴于2016年发布的跨平台移动端开发框架，思想及原理和React Native类似，最大的不同是语法层面，Weex支持Vue语法和Rax语法，Rax 的 DSL 语法是基于 React JSX 语法而创造。与 React 不同，在 Rax 中 JSX 是必选的，它不支持通过其它方式创建组件，所以学习 JSX 是使用 Rax 的必要基础。而React Native只支持JSX语法。 快应用 快应用是华为、小米、OPPO、魅族等国内9大主流手机厂商共同制定的轻量级应用标准，目标直指微信小程序。它也是采用JavaScript语言开发，原生控件渲染，与React Native和Weex相比主要有两点不同： 快应用自身不支持Vue或React语法，其采用原生JavaScript开发，其开发框架和微信小程序很像，值得一提的是小程序目前已经可以使用Vue语法开发（mpvue），从原理上来讲，Vue的语法也可以移植到快应用上。 React Native和Weex的渲染/排版引擎是集成到框架中的，每一个APP都需要打包一份，安装包体积较大；而快应用渲染/排版引擎是集成到ROM中的，应用中无需打包，安装包体积小，正因如此，快应用才能在保证性能的同时做到快速分发。 总结 JavaScript开发+原生渲染的方式主要优点如下： 采用Web开发技术栈，社区庞大、上手快、开发成本相对较低。 原生渲染，性能相比H5提高很多。 动态化较好，支持热更新。 不足： 渲染时需要JavaScript和原生之间通信，在有些场景如拖动可能会因为通信频繁导致卡顿。 JavaScript为脚本语言，执行时需要JIT，执行效率和AOT代码仍有差距。 由于渲染依赖原生控件，不同平台的控件需要单独维护，并且当系统更新时，社区控件可能会滞后；除此之外，其控件系统也会受到原生UI系统限制，例如，在Android中，手势冲突消歧规则是固定的，这在使用不同人写的控件嵌套时，手势冲突问题将会变得非常棘手。 QT Moblie与Flutter 在本篇中，我们看看最后一种跨平台技术：自绘UI+原生。这种技术的思路是，通过在不同平台实现一个统一接口的渲染引擎来绘制UI，而不依赖系统原生控件，所以可以做到不同平台UI的一致性。注意，自绘引擎解决的是UI的跨平台问题，如果涉及其它系统能力调用，依然要涉及原生开发。这种平台技术的优点如下： 性能高；由于自绘引擎是直接调用系统API来绘制UI，所以性能和原生控件接近。 灵活、组件库易维护、UI外观保真度和一致性高；由于UI渲染不依赖原生控件，也就不需要根据不同平台的控件单独维护一套组件库，所以代码容易维护。由于组件库是同一套代码、同一个渲染引擎，所以在不同平台，组件显示外观可以做到高保真和高一致性；另外，由于不依赖原生控件，也就不会受原生布局系统的限制，这样布局系统会非常灵活。 不足： 动态性不足；为了保证UI绘制性能，自绘UI系统一般都会采用AOT模式编译其发布包，所以应用发布后，不能像Hybrid和RN那些使用JavaScript（JIT）作为开发语言的框架那样动态下发代码。 也许你已经猜到Flutter就属于这一类跨平台技术，没错，Flutter正是实现一套自绘引擎，并拥有一套自己的UI布局系统。不过，自绘制引擎的思路并不是什么新概念，Flutter并不是第一个尝试这么做的，在它之前有一个典型的代表，即大名鼎鼎的QT。 QT简介 Qt是一个1991年由Qt Company开发的跨平台C++图形用户界面应用程序开发框架。2008年，Qt Company科技被诺基亚公司收购，Qt也因此成为诺基亚旗下的编程语言工具。2012年，Qt被Digia收购。2014年4月，跨平台集成开发环境Qt Creator 3.1.0正式发布，实现了对于iOS的完全支持，新增WinRT、Beautifier等插件，废弃了无Python接口的GDB调试支持，集成了基于Clang的C/C++代码模块，并对Android支持做出了调整，至此实现了全面支持iOS、Android、WP，它提供给应用程序开发者构建图形用户界面所需的所有功能。但是，QT虽然在PC端获得了巨大成功，备受社区追捧，然而其在移动端却表现不佳，在近几年，虽然偶尔能听到QT的声音，但一直很弱，无论QT本身技术如何、设计思想如何，但事实上终究是败了，究其原因，笔者认为主要有四： 第一：QT移动开发社区太小，学习资料不足，生态不好。 第二：官方推广不利，支持不够。 第三：移动端发力较晚，市场已被其它动态化框架占领（Hybrid和RN)。 第四：在移动开发中，C++开发和Web开发栈相比有着先天的劣势，直接结果就是QT开发效率太低。 基于此四点，尽管QT是移动端开发跨平台自绘引擎的先驱，但却成为了烈士。 Flutter简介 “千呼万唤始出来”，铺垫这么久，现在终于等到本书的主角出场了！ Flutter是Google发布的一个用于创建跨平台、高性能移动应用的框架。Flutter和QT mobile一样，都没有使用原生控件，相反都实现了一个自绘引擎，使用自身的布局、绘制系统。那么，我们会担心，QT mobile面对的问题Flutter是否也一样，Flutter会不会步入QT mobile后尘，成为另一个烈士？要回到这个问题，我们先来看看Flutter诞生过程： 2017 年 Google I/O 大会上，Google 首次推出了一款新的用于创建跨平台、高性能的移动应用框架——Flutter。 2018年2月，Flutter发布了第一个Beta版本，同年五月， 在2018年Google I/O 大会上，Flutter 更新到了 beta 3 版本。 2018年6月，Flutter发布了首个预览版本，这意味着 Flutter 进入了正式版（1.0）发布前的最后阶段。 观其发展，在2018年5月份，Flutter 进入了 GitHub stars 排行榜前 100 名，已有 27k star。而今天(2018年8月16日)，已经有35K的Star。经历了短短一年多的时间，Flutter 生态系统得以快速增长，由此可见，Flutter在开发者中受到了热烈的欢迎，其未来发展值得期待！ 现在，我们来和QT mobile做一个对比： 生态；从Github上来看，目前Flutter活跃用户正在高速增长。从Stackoverflow上提问来看，Flutter社区现在已经很庞大。Flutter的文档、资源也越来越丰富，开发过程中遇到的很多问题都可以在Stackoverflow或其github issue中找到答案。 技术支持；现在Google正在大力推广Flutter，Flutter的作者中很多人都是来自Chromium团队，并且github上活跃度很高。另一个角度，从今年上半年Flutter频繁的版本发布也可以看出Google对Flutter的投入的资源不小，所以在官方技术支持这方面，大可不必担心。 开发效率；Flutter的热重载可帮助开发者快速地进行测试、构建UI、添加功能并更快地修复错误。在iOS和Android模拟器或真机上可以实现毫秒级热重载，并且不会丢失状态。这真的很棒，相信我，如果你是一名原生开发者，体验了Flutter开发流后，很可能就不想重新回去做原生了，毕竟很少有人不吐槽原生开发的编译速度。 基于以上三点，相信读者和笔者一样，flutter未来如何，心中自有定论。到现在为止，我们已经对移动端开发技术有了一个全面的了解，接下来我们便要进入本书的主题，你准备好了吗！ 本章总结 本章主要介绍了目前移动开发中三种跨平台技术，现在我们从框架角度对比一下： 技术类型 UI渲染方式 性能 开发效率 动态化 框架代表 H5+原生 WebView渲染 一般 高 ✔️ Cordova、Ionic JavaScript+原生渲染 原生控件渲染 好 高 ✔️ RN、Weex 自绘UI+原生 调用系统API渲染 好 Flutter高, QT低 默认不支持 QT、Flutter 上表中开发语言主要指UI的开发语言，动态化主要指是否支持动态下发代码和是否支持热更新。值得注意的是Flutter的Release包默认是使用Dart AOT模式编译的，所以不支持动态化，但Dart还有JIT或snapshot运行方式，这些模式都是支持动态化的，后续会介绍。 "},"chapter1/flutter_intro.html":{"url":"chapter1/flutter_intro.html","title":"Flutter简介","keywords":"","body":"初识Flutter Flutter简介 Flutter 是 Google推出并开源的移动应用开发框架，主打跨平台、高保真、高性能。开发者可以通过 Dart语言开发 App，一套代码同时运行在 iOS 和 Android平台。 Flutter提供了丰富的组件、接口，开发者可以很快地为 Flutter添加 native扩展。同时 Flutter还使用 Native引擎渲染视图，这无疑能为用户提供良好的体验。 跨平台自绘引擎 Flutter与用于构建移动应用程序的其它大多数框架不同，因为Flutter既不使用WebView，也不使用操作系统的原生控件。 相反，Flutter使用自己的高性能渲染引擎来绘制widget。这样不仅可以保证在Android和iOS上UI的一致性，而且也可以避免对原生控件依赖而带来的限制及高昂的维护成本。 Flutter使用Skia作为其2D渲染引擎，Skia是Google的一个2D图形处理函数库，包含字型、坐标转换，以及点阵图都有高效能且简洁的表现，Skia是跨平台的，并提供了非常友好的API，目前Google Chrome浏览器和Android均采用Skia作为其绘图引擎，值得一提的是，由于Android系统已经内置了Skia，所以Flutter在打包APK(Android应用安装包)时，不需要再将Skia打入APK中，但iOS系统并未内置Skia，所以构建iPA时，也必须将Skia一起打包，这也是为什么Flutter APP的Android安装包比iOS安装包小的主要原因。 高性能 Flutter高性能主要靠两点来保证，首先，Flutter APP采用Dart语言开发。Dart在 JIT（即时编译）模式下，速度与 JavaScript基本持平。但是 Dart支持 AOT，当以 AOT模式运行时，JavaScript便远远追不上了。速度的提升对高帧率下的视图数据计算很有帮助。其次，Flutter使用自己的渲染引擎来绘制UI，布局数据等由Dart语言直接控制，所以在布局过程中不需要像RN那样要在JavaScript和Native之间通信，这在一些滑动和拖动的场景下具有明显优势，因为在滑动和拖动过程往往都会引起布局发生变化，所以JavaScript需要和Native之间不停的同步布局信息，这和在浏览器中要JavaScript频繁操作DOM所带来的问题是相同的，都会带来比较可观的性能开销。 采用Dart语言开发 这是一个很有意思，但也很有争议的问题，在了解Flutter为什么选择了 Dart而不是 JavaScript之前我们先来介绍两个概念：JIT和AOT。 目前，程序主要有两种运行方式：静态编译与动态解释。静态编译的程序在执行前全部被翻译为机器码，通常将这种类型称为AOT （Ahead of time）即 “提前编译”；而解释执行的则是一句一句边翻译边运行，通常将这种类型称为JIT（Just-in-time）即“即时编译”。AOT程序的典型代表是用C/C++开发的应用，它们必须在执行前编译成机器码，而JIT的代表则非常多，如JavaScript、python等，事实上，所有脚本语言都支持JIT模式。但需要注意的是JIT和AOT指的是程序运行方式，和编程语言并非强关联的，有些语言既可以以JIT方式运行也可以以AOT方式运行，如Java、Python，它们可以在第一次执行时编译成中间字节码、然后在之后执行时可以直接执行字节码，也许有人会说，中间字节码并非机器码，在程序执行时仍然需要动态将字节码转为机器码，是的，这没有错，不过通常我们区分是否为AOT的标准就是看代码在执行之前是否需要编译，只要需要编译，无论其编译产物是字节码还是机器码，都属于AOT。在此，读者不必纠结于概念，概念就是为了传达精神而发明的，只要读者能够理解其原理即可，得其神忘其形。 现在我们看看Flutter为什么选择Dart语言？笔者根据官方解释以及自己对Flutter的理解总结了以下几条（由于其它跨平台框架都将JavaScript作为其开发语言，所以主要将Dart和JavaScript做一个对比）： 开发效率高 Dart运行时和编译器支持Flutter的两个关键特性的组合： 基于JIT的快速开发周期：Flutter在开发阶段采用，采用JIT模式，这样就避免了每次改动都要进行编译，极大的节省了开发时间； 基于AOT的发布包: Flutter在发布时可以通过AOT生成高效的ARM代码以保证应用性能。而JavaScript则不具有这个能力。 高性能 Flutter旨在提供流畅、高保真的的UI体验。为了实现这一点，Flutter中需要能够在每个动画帧中运行大量的代码。这意味着需要一种既能提供高性能的语言，而不会出现会丢帧的周期性暂停，而Dart支持AOT，在这一点上可以做的比JavaScript更好。 快速内存分配 Flutter框架使用函数式流，这使得它在很大程度上依赖于底层的内存分配器。因此，拥有一个能够有效地处理琐碎任务的内存分配器将显得十分重要，在缺乏此功能的语言中，Flutter将无法有效地工作。当然Chrome V8的JavaScript引擎在内存分配上也已经做的很好，事实上Dart开发团队的很多成员都是来自Chrome团队的，所以在内存分配上Dart并不能作为超越JavaScript的优势，而对于Flutter来说，它需要这样的特性，而Dart也正好满足而已。 类型安全 由于Dart是类型安全的语言，支持静态类型检测，所以可以在编译前发现一些类型的错误，并排除潜在问题，这一点对于前端开发者来说可能会更具有吸引力。与之不同的，JavaScript是一个弱类型语言，也因此前端社区出现了很多给JavaScript代码添加静态类型检测的扩展语言和工具，如：微软的TypeScript以及Facebook的Flow。相比之下，Dart本身就支持静态类型，这是它的一个重要优势。 Dart团队就在你身边 看似不起眼，实则举足轻重。由于有Dart团队的积极投入，Flutter团队可以获得更多、更方便的支持，正如Flutter官网所述“我们正与Dart社区进行密切合作，以改进Dart在Flutter中的使用。例如，当我们最初采用Dart时，该语言并没有提供生成原生二进制文件的工具链（这对于实现可预测的高性能具有很大的帮助），但是现在它实现了，因为Dart团队专门为Flutter构建了它。同样，Dart VM之前已经针对吞吐量进行了优化，但团队现在正在优化VM的延迟时间，这对于Flutter的工作负载更为重要。” 总结 本节主要介绍了一下Flutter的特点，如果你感到有些点还不是很好理解，不用着急，随着日后对Flutter细节的了解，再回过头来看，相信你会有更深的体会。 Flutter框架结构 本节我们先对Flutter的框架做一个整体介绍，旨在让读者心中有一个整体的印象，这对初学者来说非常重要。如果一下子便深入到Flutter中，就会像是一个在沙漠中没有地图的人，即使可以找到一个绿洲，但是他也不会知道下一个绿洲在哪。因此，无论学什么技术，都要现有一张清晰的“地图”，而我们的学习过程就是“按图索骥”，这样我们才不会陷于细节而“目无全牛”。言归正传，我们看一下Flutter官方提供的一张框架图： Flutter Framework 这是一个纯 Dart实现的 SDK，它实现了一套基础库，自底向上，我们来简单介绍一下： 底下两层（Foundation和Animation、Painting、Gestures）在Google的一些视频中被合并为一个dart UI层，对应的是Flutter中的dart:ui包，它是Flutter引擎暴露的底层UI库，提供动画、手势及绘制能力。 Rendering层，这一层是一个抽象的布局层，它依赖于dart UI层，Rendering层会构建一个UI树，当UI树有变化时，会计算出有变化的部分，然后更新UI树，最终将UI树绘制到屏幕上，这个过程类似于React中的虚拟DOM。Rendering层可以说是Flutter UI框架最核心的部分，它除了确定每个UI元素的位置、大小之外还要进行坐标变换、绘制(调用底层dart:ui)。 Widgets层是Flutter提供的的一套基础组件库，在基础组件库之上，Flutter还提供了 Material 和Cupertino两种视觉风格的组件库。而我们Flutter开发的大多数场景，只是和这两层打交道。 Flutter Engine 这是一个纯 C++实现的 SDK，其中包括了 Skia引擎、Dart运行时、文字排版引擎等。在代码调用 dart:ui库时，调用最终会走到Engine层，然后实现真正的绘制逻辑。 总结 Flutter框架本身有着良好的分层设计，本节旨在让读者对Flutter整体框架有个大概的印象，相信到现在为止，读者已经对Flutter有一个初始印象，在我们正式动手之前，我们还需要了解一下Flutter的开发语言Dart。 如何学习Flutter 本节给大家一些学习建议，分享一下笔者在学习Flutter中的一些心得，希望可以帮助你提高学习效率，避免不必要的坑。 资源 官网：阅读Flutter官网的资源是快速入门的最佳方式，同时官网也是了解最新Flutter发展动态的地方，由于目前Flutter仍然处于快速发展阶段，所以建议读者还是时不时的去官网看看有没有新的动态。 源码及注释：源码注释应作为学习Flutter的第一文档，Flutter SDK的源码是开源的，并且注释非常详细，也有很多示例，实际上，Flutter官方的SDK文档就是通过注释生成的。源码结合注释可以帮你解决大多数问题。 Github：如果遇到的问题在StackOverflow上也没有找到答案，可以去github flutter 项目下提issue。 Gallery源码：Gallery是Flutter官方示例APP，里面有丰富的示例，读者可以在网上下载安装。Gallery的源码在Flutter源码“examples”目录下。 社区 StackOverflow：如果你还没听过StackOverflow，这是目前全球最大的程序员问答社区，现在也是活跃度最高的Flutter问答社区。StackOverflow上面除了世界各地的Flutter使用者会在上面交流之外，Flutter开发团队的成员也经常会在上面回答问题。 Flutter中文网社区：Flutter中文网(https://flutterchina.club)是笔者维护中文网站，目前也是最大的中文资源社区，上面提供了Flutter官网的文档翻译、开源项目、及案例，还有申请加入组织的入口哦。 掘金：掘金的Flutter主页目前也收集了不少的博客文章，读者可以自行浏览。 总结 有了资料和社区后，对于我们学习者自身来说，最重要的还是要多动手、多实践，在本书后面的章节中，希望读者能够亲自动手写一下示例。准备好了吗，下一章中，我们将正式进入Flutter的世界！ "},"chapter1/install_flutter.html":{"url":"chapter1/install_flutter.html","title":"搭建Flutter开发环境","keywords":"","body":"安装Flutter 工欲善其事必先利其器，本节首先会分别介绍一下在Windows和macOS下Flutter SDK的安装，然后再介绍一下配IDE和模拟器的使用。 搭建Flutter开发环境 由于Flutter会同时构建Android和IOS两个平台的发布包，所以Flutter同时依赖Android SDK和iOS SDK，在安装Flutter时也需要安装相应平台的构建工具和SDK。下面我们分别介绍一下Windows和macOS下的环境搭建。 使用镜像 由于在国内访问Flutter有时可能会受到限制，Flutter官方为中国开发者搭建了临时镜像，大家可以将如下环境变量加入到用户环境变量中： export PUB_HOSTED_URL=https://pub.flutter-io.cn export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 注意： 此镜像为临时镜像，并不能保证一直可用，读者可以参考https://flutter.io/community/china 以获得有关镜像服务器的最新动态。 在Windows上搭建Flutter开发环境 系统要求 要安装并运行Flutter，您的开发环境必须满足以下最低要求: 操作系统: Windows 7 或更高版本 (64-bit) 磁盘空间: 400 MB (不包括Android Studio的磁盘空间). 工具: Flutter 依赖下面这些命令行工具. PowerShell 5.0 或更新的版本 Git for Windows (Git命令行工具)； 如果已安装Git for Windows，请确保可以在命令提示符或PowerShell中运行 git 命令 获取Flutter SDK 去flutter官网下载其最新可用的安装包，官网地址：https://flutter.io/sdk-archive/#windows 注意，Flutter的渠道版本会不停变动，请以Flutter官网为准。另外，在中国大陆地区，要想正常获取安装包列表或下载安装包，可能需要翻墙，读者也可以去Flutter github项目下去下载安装包，地址：https://github.com/flutter/flutter/releases 。 将安装包zip解压到你想安装Flutter SDK的路径（如：C:\\src\\flutter；注意，不要将flutter安装到需要一些高权限的路径如C:\\Program Files\\）。 在Flutter安装目录的flutter文件下找到flutter_console.bat，双击运行并启动flutter命令行，接下来，你就可以在Flutter命令行运行flutter命令了。 更新环境变量 如果你想在Windows系统自带命令行（而不是）运行flutter命令，需要添加以下环境变量到用户PATH： 转到 “控制面板>用户帐户>用户帐户>更改我的环境变量” 在“用户变量”下检查是否有名为“Path”的条目: 如果该条目存在， 追加 flutter\\bin的全路径，使用 ; 作为分隔符. 如果该条目不存在，创建一个新用户变量 Path ，然后将 flutter\\bin 的全路径作为它的值. 重启Windows以应用此更改. 运行 flutter doctor命令 在Flutter命令行运行如下命令来查看是否还需要安装其它依赖，如果需要，安装它们： flutter doctor 该命令检查你的环境并在命令行窗口中显示报告。Dart SDK已经在打包在Flutter SDK里了，没有必要单独安装Dart。 仔细检查命令行输出以获取可能需要安装的其他软件或进一步需要执行的任务。 例如： [-] Android toolchain - develop for Android devices • Android SDK at D:\\Android\\sdk ✗ Android SDK is missing command line tools; download from https://goo.gl/XxQghQ • Try re-installing or updating your Android SDK, visit https://flutter.io/setup/#android-setup for detailed instructions. 第一次运行flutter命令（如flutter doctor）时，它会下载它自己的依赖项并自行编译。以后再运行就会快得多。缺失的依赖需要安装一下，安装完成后再运行flutter doctor命令来验证是否安装成功。 Android设置 Flutter依赖于Android Studio的全量安装。Android Studio不仅可以管理Android 平台依赖、SDK版本等，而且它也是Flutter开发推荐的IDE之一（当然，你也可以使用其它编辑器或IDE，我们将会在后面讨论）。 安装Android Studio 下载并安装 Android Studio，下载地址：https://developer.android.com/studio/index.html 。 启动Android Studio，然后执行“Android Studio安装向导”。这将安装最新的Android SDK、Android SDK平台工具和Android SDK构建工具，这些是用Flutter进行Android开发所需要的。 安装遇到问题？ 如果在安装过程中遇到问题，可以先去flutter官网查看一下安装方式是否发生变化，或者在网上搜索一下解决方案。 在macOS上搭建Flutter开发环境 在masOS下可以同时进行Android和iOS设备的测试。 系统要求 要安装并运行Flutter，您的开发环境必须满足以下最低要求: 操作系统: macOS (64-bit) 磁盘空间: 700 MB (不包括Xcode或Android Studio的磁盘空间）. 工具: Flutter 依赖下面这些命令行工具. bash、mkdir、rm、git、curl、unzip、which 获取Flutter SDK 去flutter官网下载其最新可用的安装包，官网地址：https://flutter.io/sdk-archive/#macos 注意，Flutter的渠道版本会不停变动，请以Flutter官网为准。另外，在中国大陆地区，要想正常获取安装包列表或下载安装包，可能需要翻墙，读者也可以去Flutter github项目下去下载安装包，地址：https://github.com/flutter/flutter/releases 。 解压安装包到你想安装的目录，如： cd ~/development unzip ~/Downloads/flutter_macos_v0.5.1-beta.zip 添加flutter相关工具到path中： export PATH=`pwd`/flutter/bin:$PATH 此代码只能暂时针对当前命令行窗口设置PATH环境变量，要想永久将Flutter添加到PATH中请参考下面更新环境变量 部分。 运行 flutter doctor命令 这一步和Windows下步骤一致，不再赘述。 更新环境变量 将Flutter添加到PATH中，可以在任何终端会话中运行flutter命令。 对于所有终端会话永久修改此变量的步骤是和特定计算机系统相关的。通常，您会在打开新窗口时将设置环境变量的命令添加到执行的文件中。例如 确定您Flutter SDK的目录记为“FLUTTER_INSTALL_PATH”，您将在步骤3中用到。 打开(或创建) $HOME/.bash_profile。文件路径和文件名可能在你的电脑上不同. 添加以下路径: export PATH=[FLUTTER_INSTALL_PATH]/flutter/bin:$PATH 例如笔者Flutter 安装目录是“~/code/flutter_dir”，那么代码为： export PATH=~/code/flutter_dir/flutter/bin:$PATH 运行 source $HOME/.bash_profile 刷新当前终端窗口。 注意: 如果你使用终端是zsh，终端启动时 ~/.bash_profile 将不会被加载，解决办法就是修改 ～/.zshrc ，在其中添加：source ～/.bash_profile 验证“flutter/bin”是否已在PATH中： echo $PATH 安装 Xcode 要为iOS开发Flutter应用程序，您需要Xcode 9.0或更高版本: 安装Xcode 9.0或更新版本(通过链接下载或苹果应用商店). 配置Xcode命令行工具以使用新安装的Xcode版本 sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer 对于大多数情况，当您想要使用最新版本的Xcode时，这是正确的路径。如果您需要使用不同的版本，请指定相应路径。 确保Xcode许可协议是通过打开一次Xcode或通过命令sudo xcodebuild -license同意过了. 使用Xcode，您可以在iOS设备或模拟器上运行Flutter应用程序。 安装Android Studio 和Window一样，要在Android设备上构建并运行Flutter程序都需要先安装Android Studio，读者可以先自行下载并安装Android Studio，在此不再赘述。 升级 Flutter Flutter SDK分支 Flutter SDK有多个分支，如beta、dev、master、stable，其中stable分支为稳定分支（日后有新的稳定版本发布后可能也会有新的稳定分支，如1.0.0），dev和master为开发分支，安装flutter后，你可以运行flutter channel查看所有分支，如笔者本地运行后，结果如下： Flutter channels: beta dev * master 带\"*\"号的分支即你本地的Flutter SDK 跟踪的分支，要切换分支，可以使用flutter channel beta 或 flutter channel master，Flutter官方建议跟踪稳定分支，但你也可以跟踪master分支，这样可以查看最新的变化，但这样稳定性要低的多。 升级Flutter SDK和依赖包 要升级flutter sdk，只需一句命令： flutter upgrade 该命令会同时更新Flutter SDK和你的flutter项目依赖包。如果你只想更新项目依赖包（不包括Flutter SDK），可以使用如下命令： flutter packages get获取项目所有的依赖包。 flutter packages upgrade 获取项目所有依赖包的最新版本。 IDE配置与使用 理论上可以使用任何文本编辑器与命令行工具来构建Flutter应用程序。 不过，Flutter官方建议使用Android Studio和VS Code之一以获得更好的开发体验。Flutter官方提供了这两款编辑器插件，通过IDE和插件可获得代码补全、语法高亮、widget编辑辅助、运行和调试支持等功能，可以帮助我们极大的提高开发效率。下面我们分别介绍一下Android Studio和VS Code的配置及使用（Android Studio和VS Code读者可以在其官网获得最新的安装，由于安装比较简单，故不再赘述）。 Android Studio 配置与使用 由于Android Studio是基于IntelliJ IDEA开发的，所以读者也可以使用IntelliJ IDEA。 安装Flutter和Dart插件 需要安装两个插件: Flutter插件： 支持Flutter开发工作流 (运行、调试、热重载等)。 Dart插件： 提供代码分析 (输入代码时进行验证、代码补全等)。 安装步骤： 启动Android Studio。 打开插件首选项 (macOS：Preferences>Plugins, Windows：File>Settings>Plugins)。 选择 Browse repositories…，选择 flutter 插件并点击 install。 重启Android Studio后插件生效。 接下来，让我们用Android Studio创建一个Flutter项目，然后运行它，并体验“热重载”。 创建Flutter应用 选择 File>New Flutter Project 。 选择 Flutter application 作为 project 类型, 然后点击 Next。 输入项目名称 (如 myapp)，然后点击 Next。 点击 Finish。 等待Android Studio安装SDK并创建项目。 上述命令创建一个Flutter项目，项目名为myapp，其中包含一个使用Material 组件的简单演示应用程序。 在项目目录中，您应用程序的代码位于 lib/main.dart。 运行应用程序 定位到Android Studio工具栏： 在 target selector 中, 选择一个运行该应用的Android设备。如果没有列出可用，请选择 Tools>Android>AVD Manager 并在那里创建一个。 在工具栏中点击 Run图标。 如果一切正常, 您应该在您的设备或模拟器上会看到启动的应用程序： 体验热重载 Flutter 可以通过 热重载（hot reload） 实现快速的开发周期，热重载就是无需重启应用程序就能实时加载修改后的代码，并且不会丢失状态。简单的对代码进行更改，然后告诉IDE或命令行工具你需要重新加载（点击reload按钮），你就会在你的设备或模拟器上看到更改。 1. 打开`lib/main.dart`文件 2. 将字符串 `'You have pushed the button this many times:'` 更改为 `'You have clicked the button this many times:'` 3. 不要按“停止”按钮; 让您的应用继续运行. 4. 要查更改，请调用 **Save** (`cmd-s` / `ctrl-s`)，或者点击 **热重载按钮** (带有闪电⚡️图标的按钮)。 你会立即在运行的应用程序中看到更新的字符串。 VS Code的配置与使用 VS Code是一个轻量级编辑器，支持Flutter运行和调试。 安装flutter插件 启动 VS Code。 调用 View>Command Palette…。 输入 ‘install’, 然后选择 Extensions: Install Extension action。 在搜索框输入 flutter ，在搜索结果列表中选择 ‘Flutter’, 然后点击 Install。 选择 ‘OK’ 重新启动 VS Code。 验证配置 调用 View>Command Palette… 输入 ‘doctor’, 然后选择 ‘Flutter: Run Flutter Doctor’ action。 查看“OUTPUT”窗口中的输出是否有问题 创建Flutter应用 启动 VS Code 调用 View>Command Palette… 输入 ‘flutter’, 然后选择 ‘Flutter: New Project’ action 输入 Project 名称 (如myapp), 然后按回车键 指定放置项目的位置，然后按蓝色的确定按钮 等待项目创建继续，并显示main.dart文件 体验热重载 打开lib/main.dart文件。 将字符串 'You have pushed the button this many times:' 更改为 'You have clicked the button this many times:'。 不要按“停止”按钮; 让您的应用继续运行。 要查看您的更改，请调用 Save (cmd-s / ctrl-s), 或者点击 热重载按钮 (绿色圆形箭头按钮)。 你会立即在运行的应用程序中看到更新的字符串。 连接设备运行Flutter应用 Window下只支持为Android设备构建并运行Flutter应用，而macOS同时支持iOS和Android设备。下面分别介绍如何连接Android和iOS设备来运行flutter应用。 连接Android模拟器 要准备在Android模拟器上运行并测试Flutter应用，请按照以下步骤操作： 启动 Android Studio>Tools>Android>AVD Manager 并选择 Create Virtual Device. 选择一个设备并选择 Next。 为要模拟的Android版本选择一个或多个系统印象，然后选择 Next. 建议使用 x86 或 x86_64 image . 在 “Emulated Performance”下, 选择 Hardware - GLES 2.0 以启用 硬件加速. 验证AVD配置是否正确，然后选择 Finish。 有关上述步骤的详细信息，请参阅 Managing AVDs. 在“Android Virtual Device Manager”中，点击工具栏的 Run。模拟器启动并显示所选操作系统版本或设备的启动画面。 运行 flutter run 启动您的设备。 连接的设备名是 Android SDK built for ，其中 platform 是芯片系列，如 x86。 连接Android真机设备 要准备在Android设备上运行并测试Flutter应用，需要Android 4.1（API level 16）或更高版本的Android设备. 在Android设备上启用 开发人员选项 和 USB调试 。详细说明可在Android文档中找到。 使用USB将手机插入电脑。如果设备出现调试授权提示，请授权你的电脑可以访问该设备。 在命令行运行 flutter devices 命令以验证Flutter识别您连接的Android设备。 运行启动你应用程序 flutter run。 默认情况下，Flutter使用的Android SDK版本是基于你的 adb 工具版本。 如果想让Flutter使用不同版本的Android SDK，则必须将该 ANDROID_HOME 环境变量设置为相应的SDK安装目录。 连接iOS模拟器 要准备在iOS模拟器上运行并测试Flutter应用，请按以下步骤操作： 在你的MAC上，通过 Spotlight 或以下命令找到模拟器： open -a Simulator 通过检查模拟器 Hardware > Device 菜单中的设置，确保模拟器正在使用64位设备（iPhone 5s或更高版本）。 根据你电脑屏幕大小，模拟高清屏iOS设备可能会溢出屏幕。可以在模拟器的 Window> Scale 菜单下设置设备比例。 运行 flutter run启动flutter应用程序。 连接iOS真机设备 要将Flutter应用安装到iOS真机设备，需要一些额外的工具和一个Apple帐户，还需要在Xcode中进行一些设置。 安装 homebrew （如果已经安装了brew,跳过此步骤）。 打开终端并运行如下这些命令: brew update brew install --HEAD libimobiledevice brew install ideviceinstaller ios-deploy cocoapods pod setup 如果这些命令中的任何一个失败并出现错误，请运行brew doctor并按照说明解决问题. 遵循Xcode签名流程来配置您的项目: 在你Flutter项目目录中通过 open ios/Runner.xcworkspace 打开默认的Xcode workspace. 在Xcode中，选择导航面板左侧中的Runner项目。 在Runner target设置页面中，确保在 General > Signing > Team 下选择了你的开发团队。当你选择一个团队时，Xcode会创建并下载开发证书，向你的设备注册你的帐户，并创建和下载配置文件（如果需要）。 要开始您的第一个iOS开发项目，您可能需要使用您的Apple ID登录Xcode。 任何Apple ID都支持开发和测试，但若想将应用分发到App Store，就必须注册Apple开发者计划，有关详情读者可以自行了解。 当您第一次attach真机设备进行iOS开发时，需要同时信任你的Mac和该设备上的开发证书。首次将iOS设备连接到Mac时，请在对话框中选择 Trust。 然后，转到iOS设备上的设置菜单，选择 常规>设备管理 并信任您的证书。 如果Xcode中的自动签名失败，请验证项目的 General > Identity > Bundle Identifier 值是否唯一. 运行 flutter run启动flutter应用程序。 "},"chapter1/configuration.html":{"url":"chapter1/configuration.html","title":"常见配置问题","keywords":"","body":"常见配置问题 Android Studio问题 缺少依赖库问题 上手安卓最常遇见的问题之一，错误如下图所示，此时点击超链接即可自动跳转到安装页面 安装之后重新运行即可。 连接不上Android Repository 这也是最常见的问题之一，当你发现自己无法下载部分依赖的时候，请优先考虑这种情况。进入 File -> Settings -> Appearance & Behavior -> System Settings -> Android SDK -> SDK Update Sites 列表，可以看到此时的 Android Repository 无法连接。 解决方法如下： 进入 C:\\windows\\system32\\drivers\\etc\\ 打开 hosts 文件 添加 203.208.41.32 dl.google.com 即可解决 安卓包配置问题 一般格式为 Could not HEAD ** Could not Get ** 如：Android Studio Could not GET gradle-3.2.0.pom 这一类问题是由于无法连接到 Maven 库造成的，解决方法如下： 进入当前所在项目名/android 打开 build.gradle 找到下面这一部分，并加上 maven { url 'http://maven.aliyun.com/nexus/content/groups/public/' } allprojects { repositories { google() jcenter() maven { url 'http://maven.aliyun.com/nexus/content/groups/public/' } //添加这一句 } } 进入 File/ Settings/ Build, Execution, Deployment/ BuildTools/ Gradle/ Android Studio 中，勾选上 Enable embedded Maven repository ，重启 Android Studio 即可解决。 注意：存在这样的一种情况，当你根据上述步骤设置了之后，依旧无法解决这个问题，并有类似于 Could not HEAD maven.aliyun.com 的报错信息，请检查 C:\\Users\\{user_name}\\.gradle\\gradle.properties 是否有设置代理。删除后问题即可解决。 "},"chapter1/dart.html":{"url":"chapter1/dart.html","title":"Dart语言简介","keywords":"","body":"Dart语言简介 在之前我们已经介绍过Dart语言的相关特性，读者可以翻看一下，如果你熟悉Dart语法，可以跳过本节，如果你还不了解Dart，不用担心，按照笔者经验，如果你有过其他编程语言经验，尤其是Java和JavaScript的话，所以，如果你是前端或Android开发者，那么将会非常容易上手Dart。当然，如果你是iOS开发者，也不用担心，dart中也有一些与swift比较相似的特性，如命名参数等，笔者当时学习Dart时，只是花了一个小时，看完Dart官网的Language Tour，就开始动手写Flutter了。 在笔者看来，Dart的设计目标应该是既对标Java，也对标JavaScript，Dart在静态语法方面和Java非常相似，如类型定义、函数声明、泛型等，而在动态特性方面又和JavaScript很像，如函数式特性、异步支持等。除了融合Java和JavaScript语言之所长之外，Dart也具有一些其它具有表现力的语法，如可选命名参数、..（级联运算符）和?.（条件成员访问运算符）以及??（判空赋值运算符）。其实，对编程语言了解比较多的读者会发现，在Dart中其实看到的不仅有Java和JavaScript的影子，它还具有其它编程语言中的身影，如命名参数在Objective-C和Swift中早就很普遍，而??操作符在Php 7.0语法中就已经存在了，因此我们可以看到Google对Dart语言给予厚望，是想把Dart打造成一门集百家之所长的编程语言。 接下来，我们先对Dart语法做一个简单的介绍，然后再将Dart与JavaScript和Java做一个简要的对比，方便读者更好的理解。 注意：由于本书并非专门介绍Dart语言的书籍，所以本章主要会介绍一下在Flutter开发中常用的语法特性，如果想更多了解Dart，读者可以去Dart官网学习，现在互联网上Dart相关资料已经很多了。另外Dart 2.0已经正式发布，所以本书所有示例均采用Dart 2.0语法。 变量声明 var 类似于JavaScript中的var，它可以接收任何类型的变量，但最大的不同是Dart中var变量一旦赋值，类型便会确定，则不能再改变其类型，如： var t; t=\"hi world\"; // 下面代码在dart中会报错，因为变量t的类型已经确定为String， // 类型一旦确定后则不能再更改其类型。 t=1000; 上面的代码在JavaScript是没有问题的，前端开发者需要注意一下，之所以有此差异是因为Dart本身是一个强类型语言，任何变量都是有确定类型的，在Dart中，当用var声明一个变量后，Dart在编译时会根据第一次赋值数据的类型来推断其类型，编译结束后其类型就已经被确定，而JavaScript是纯粹的弱类型脚本语言，var只是变量的声明方式而已。 dynamic和Object Object 是dart所有对象的根基类，也就是说所有类型都是Object的子类(包括Function和Null)，所以任何类型的数据都可以赋值给Object声明的对象. dynamic与var一样都是关键词,声明的变量可以赋值任意对象. dynamic与var相同之处在于,dynamic与Object声明的变量一样都可以在后期改变赋值类型. dynamic t; Object x; t = \"hi world\"; x = 'Hello Object'; //下面代码没有问题 t = 1000; x = 1000; dynamic与Object不同的是,dynamic声明的对象编译器会提供所有可能的组合, Object声明的对象只能使用Object的属性与方法, 否则编译器会报错. 如: dynamic a; Object b; main() { a = \"\"; b = \"\"; printLengths(); } printLengths() { // no warning print(a.length); // warning: // The getter 'length' is not defined for the class 'Object' print(b.length); } 变量a不会报错, 变量b编译器会报错 dynamic的这个特性与Objective-C中的id作用很像. dynamic的这个特点使得我们在使用它是需要格外注意,这很容易引必一个运行时错误. final和const 如果您从未打算更改一个变量，那么使用 final 或 const，不是var，也不是一个类型。 一个 final 变量只能被设置一次，两者区别在于：const 变量是一个编译时常量，final变量在第一次使用时被初始化。被final或者const修饰的变量，变量类型可以省略，如： //可以省略String这个类型声明 final str = \"hi world\"; //final String str = \"hi world\"; const str1 = \"hi world\"; //const String str1 = \"hi world\"; 函数 Dart是一种真正的面向对象的语言，所以即使是函数也是对象，并且有一个类型Function。这意味着函数可以赋值给变量或作为参数传递给其他函数，这是函数式编程的典型特征。 函数声明 bool isNoble(int atomicNumber) { return _nobleGases[atomicNumber] != null; } dart函数声明如果没有显式声明返回值类型时会默认当做dynamic处理，注意，函数返回值没有类型推断： typedef bool CALLBACK(); //不指定返回类型，此时默认为dynamic，不是bool isNoble(int atomicNumber) { return _nobleGases[atomicNumber] != null; } void test(CALLBACK cb){ print(cb()); } //报错，isNoble不是bool类型 test(isNoble); 对于只包含一个表达式的函数，可以使用简写语法 bool isNoble （int atomicNumber ）=> _nobleGases [ atomicNumber ] ！= null ; 函数作为变量 var say= (str){ print(str); }; say(\"hi world\"); 函数作为参数传递 void execute(var callback){ callback(); } execute(()=>print(\"xxx\")) 可选的位置参数 包装一组函数参数，用[]标记为可选的位置参数： String say(String from, String msg, [String device]) { var result = '$from says $msg'; if (device != null) { result = '$result with a $device'; } return result; } 下面是一个不带可选参数调用这个函数的例子： say('Bob', 'Howdy'); //结果是： Bob says Howdy 下面是用第三个参数调用这个函数的例子： say('Bob', 'Howdy', 'smoke signal'); //结果是：Bob says Howdy with a smoke signal 可选的命名参数 定义函数时，使用{param1, param2, …}，用于指定命名参数。例如： //设置[bold]和[hidden]标志 void enableFlags({bool bold, bool hidden}) { // ... } 调用函数时，可以使用指定命名参数。例如：paramName: value enableFlags(bold: true, hidden: false); 可选命名参数在Flutter中使用非常多。 异步支持 Dart类库有非常多的返回Future或者Stream对象的函数。 这些函数被称为异步函数：它们只会在设置好一些耗时操作之后返回，比如像 IO操作。而不是等到这个操作完成。 async和await关键词支持了异步编程，运行您写出和同步代码很像的异步代码。 Future Future与JavaScript中的Promise非常相似，表示一个异步操作的最终完成（或失败）及其结果值的表示。简单来说，它就是用于处理异步操作的，异步处理成功了就执行成功的操作，异步处理失败了就捕获错误或者停止后续操作。一个Future只会对应一个结果，要么成功，要么失败。 由于本身功能较多，这里我们只介绍其常用的API及特性。还有，请记住，Future 的所有API的返回值仍然是一个Future对象，所以可以很方便的进行链式调用。 Future.then 为了方便示例，在本例中我们使用Future.delayed 创建了一个延时任务（实际场景会是一个真正的耗时任务，比如一次网络请求），即2秒后返回结果字符串\"hi world!\"，然后我们在then中接收异步结果并打印结果，代码如下： Future.delayed(new Duration(seconds: 2),(){ return \"hi world!\"; }).then((data){ print(data); }); Future.catchError 如果异步任务发生错误，我们可以在catchError中捕获错误，我们将上面示例改为： Future.delayed(new Duration(seconds: 2),(){ //return \"hi world!\"; throw AssertionError(\"Error\"); }).then((data){ //执行成功会走到这里 print(\"success\"); }).catchError((e){ //执行失败会走到这里 print(e); }); 在本示例中，我们在异步任务中抛出了一个异常，then的回调函数将不会被执行，取而代之的是 catchError回调函数将被调用；但是，并不是只有 catchError回调才能捕获错误，then方法还有一个可选参数onError，我们也可以它来捕获异常： Future.delayed(new Duration(seconds: 2), () { //return \"hi world!\"; throw AssertionError(\"Error\"); }).then((data) { print(\"success\"); }, onError: (e) { print(e); }); Future.whenComplete 有些时候，我们会遇到无论异步任务执行成功或失败都需要做一些事的场景，比如在网络请求前弹出加载对话框，在请求结束后关闭对话框。这种场景，有两种方法，第一种是分别在then或catch中关闭一下对话框，第二种就是使用Future的whenComplete回调，我们将上面示例改一下： Future.delayed(new Duration(seconds: 2),(){ //return \"hi world!\"; throw AssertionError(\"Error\"); }).then((data){ //执行成功会走到这里 print(data); }).catchError((e){ //执行失败会走到这里 print(e); }).whenComplete((){ //无论成功或失败都会走到这里 }); Future.wait 有些时候，我们需要等待多个异步任务都执行结束后才进行一些操作，比如我们有一个界面，需要先分别从两个网络接口获取数据，获取成功后，我们需要将两个接口数据进行特定的处理后再显示到UI界面上，应该怎么做？答案是Future.wait，它接受一个Future数组参数，只有数组中所有Future都执行成功后，才会触发then的成功回调，只要有一个Future执行失败，就会触发错误回调。下面，我们通过模拟Future.delayed 来模拟两个数据获取的异步任务，等两个异步任务都执行成功时，将两个异步任务的结果拼接打印出来，代码如下： Future.wait([ // 2秒后返回结果 Future.delayed(new Duration(seconds: 2), () { return \"hello\"; }), // 4秒后返回结果 Future.delayed(new Duration(seconds: 4), () { return \" world\"; }) ]).then((results){ print(results[0]+results[1]); }).catchError((e){ print(e); }); 执行上面代码，4秒后你会在控制台中看到“hello world”。 Async/await Dart中的async/await 和JavaScript中的async/await功能和用法是一模一样的，如果你已经了解JavaScript中的async/await的用法，可以直接跳过本节。 回调地狱(Callback hell) 如果代码中有大量异步逻辑，并且出现大量异步任务依赖其它异步任务的结果时，必然会出现Future.then回调中套回调情况。举个例子，比如现在有个需求场景是用户先登录，登录成功后会获得用户Id，然后通过用户Id，再去请求用户个人信息，获取到用户个人信息后，为了使用方便，我们需要将其缓存在本地文件系统，代码如下： //先分别定义各个异步任务 Future login(String userName, String pwd){ ... //用户登录 }; Future getUserInfo(String id){ ... //获取用户信息 }; Future saveUserInfo(String userInfo){ ... // 保存用户信息 }; 接下来，执行整个任务流： login(\"alice\",\"******\").then((id){ //登录成功后通过，id获取用户信息 getUserInfo(id).then((userInfo){ //获取用户信息后保存 saveUserInfo(userInfo).then((){ //保存用户信息，接下来执行其它操作 ... }); }); }) 可以感受一下，如果业务逻辑中有大量异步依赖的情况，将会出现上面这种在回调里面套回调的情况，过多的嵌套会导致的代码可读性下降以及出错率提高，并且非常难维护，这个问题被形象的称为回调地狱（Callback hell）。回调地狱问题在之前JavaScript中非常突出，也是JavaScript被吐槽最多的点，但随着ECMAScript6和ECMAScript7标准发布后，这个问题得到了非常好的解决，而解决回调地狱的两大神器正是ECMAScript6引入了Promise，以及ECMAScript7中引入的async/await。 而在Dart中几乎是完全平移了JavaScript中的这两者：Future相当于Promise，而async/await连名字都没改。接下来我们看看通过Future和async/await如何消除上面示例中的嵌套问题。 使用Future消除callback hell login(\"alice\",\"******\").then((id){ return getUserInfo(id); }).then((userInfo){ return saveUserInfo(userInfo); }).then((e){ //执行接下来的操作 }).catchError((e){ //错误处理 print(e); }); 正如上文所述， “Future 的所有API的返回值仍然是一个Future对象，所以可以很方便的进行链式调用” ，如果在then中返回的是一个Future的话，该future会执行，执行结束后会触发后面的then回调，这样依次向下，就避免了层层嵌套。 使用async/await消除callback hell 通过Future回调中再返回Future的方式虽然能避免层层嵌套，但是还是有一层回调，有没有一种方式能够让我们可以像写同步代码那样来执行异步任务而不使用回调的方式？答案是肯定的，这就要使用async/await了，下面我们先直接看代码，然后再解释，代码如下： task() async { try{ String id = await login(\"alice\",\"******\"); String userInfo = await getUserInfo(id); await saveUserInfo(userInfo); //执行接下来的操作 } catch(e){ //错误处理 print(e); } } async用来表示函数是异步的，定义的函数会返回一个Future对象，可以使用then方法添加回调函数。 await 后面是一个Future，表示等待该异步任务完成，异步完成后才会往下走；await必须出现在 async 函数内部。 可以看到，我们通过async/await将一个异步流用同步的代码表示出来了。 其实，无论是在JavaScript还是Dart中，async/await都只是一个语法糖，编译器或解释器最终都会将其转化为一个Promise（Future）的调用链。 Stream Stream 也是用于接收异步事件数据，和Future 不同的是，它可以接收多个异步操作的结果（成功或失败）。 也就是说，在执行异步任务时，可以通过多次触发成功或失败事件来传递结果数据或错误异常。 Stream 常用于会多次读取数据的异步任务场景，如网络内容下载、文件读写等。举个例子： Stream.fromFutures([ // 1秒后返回结果 Future.delayed(new Duration(seconds: 1), () { return \"hello 1\"; }), // 抛出一个异常 Future.delayed(new Duration(seconds: 2),(){ throw AssertionError(\"Error\"); }), // 3秒后返回结果 Future.delayed(new Duration(seconds: 3), () { return \"hello 3\"; }) ]).listen((data){ print(data); }, onError: (e){ print(e.message); },onDone: (){ }); 上面的代码依次会输出： I/flutter (17666): hello 1 I/flutter (17666): Error I/flutter (17666): hello 3 代码很简单，就不赘述了。 思考题：既然Stream可以接收多次事件，那能不能用Stream来实现一个订阅者模式的事件总线？ 总结 通过上面介绍，相信你对Dart应该有了一个初步的印象，由于笔者平时也使用Java和JavaScript，下面笔者根据自己的经验，结合Java和JavaScript，谈一下自己的看法。 之所以将Dart与Java和JavaScript对比，是因为，这两者分别是强类型语言和弱类型语言的典型代表，并且Dart 语法中很多地方也都借鉴了Java和JavaScript。 Dart vs Java 客观的来讲，Dart在语法层面确实比Java更有表现力；在VM层面，Dart VM在内存回收和吞吐量都进行了反复的优化，但具体的性能对比，笔者没有找到相关测试数据，但在笔者看来，只要Dart语言能流行，VM的性能就不用担心，毕竟Google在go（没用vm但有GC）、javascript（v8）、dalvik（android上的java vm）上已经有了很多技术积淀。值得注意的是Dart在Flutter中已经可以将GC做到10ms以内，所以Dart和Java相比，决胜因素并不会是在性能方面。而在语法层面，Dart要比java更有表现力，最重要的是Dart对函数式编程支持要远强于Java(目前只停留在lamda表达式)，而Dart目前真正的不足是生态，但笔者相信，随着Flutter的逐渐火热，会回过头来反推Dart生态加速发展，对于Dart来说，现在需要的是时间。 Dart vs JavaScript JavaScript的弱类型一直被抓短，所以TypeScript、Coffeescript甚至是Facebook的flow（虽然并不能算JavaScript的一个超集，但也通过标注和打包工具提供了静态类型检查）才有市场。就笔者使用过的脚本语言中（笔者曾使用过Python、PHP），JavaScript无疑是动态化支持最好的脚本语言，比如在JavaScript中，可以给任何对象在任何时候动态扩展属性，对于精通JavaScript的高手来说，这无疑是一把利剑。但是，任何事物都有两面性，JavaScript的强大的动态化特性也是把双刃剑，你可经常听到另一个声音，认为JavaScript的这种动态性糟糕透了，太过灵活反而导致代码很难预期，无法限制不被期望的修改。毕竟有些人总是对自己或别人写的代码不放心，他们希望能够让代码变得可控，并期望有一套静态类型检查系统来帮助自己减少错误。正因如此，在Flutter中，Dart几乎放弃了脚本语言动态化的特性，如不支持反射、也不支持动态创建函数等。并且Dart在2.0强制开启了类型检查（Strong Mode），原先的检查模式（checked mode）和可选类型（optional type）将淡出，所以在类型安全这个层面来说，Dart和TypeScript、Coffeescript是差不多的，所以单从这一点来看，Dart并不具备什么明显优势，但综合起来看，dart既能进行服务端脚本、APP开发、web开发，这就有优势了！ 综上所述，笔者还是很看好Dart语言的将来，之所以表这个态，是因为在新技术发展初期，很多人可能还有所摇摆，有所犹豫，所以有必要给大家打一剂强心针，当然，这是一个见仁见智的问题，大家可以各抒己见。 "},"chapter2/":{"url":"chapter2/","title":"第一个Flutter应用","keywords":"","body":"简介 本章将通过一些简单的示例来一步步介绍Flutter的开发流程. 本章目录 实现一个计数器 路由管理 包管理 资源管理 调试Flutter APP Dart线程模型及异常捕获 "},"chapter2/first_flutter_app.html":{"url":"chapter2/first_flutter_app.html","title":"计数器示例","keywords":"","body":"计数器应用示例 用Android Studio和VS Code创建的Flutter应用模板是一个简单的计数器示例，本节先仔细讲解一下这个计数器Demo的源码，让读者对Flutter应用程序结构有个基本了解，在随后小节中，将会基于此示例，一步一步添加一些新的功能来介绍Flutter应用的其它概念与技术。对于接下来的示例，希望读者可以跟着笔者实际动手来写一下，这样不仅可以加深印象，而且也会对介绍的概念与技术有一个真切的体会。如果你还不是很熟悉Dart或者没有移动开发经验，不用担心，只要你熟悉面向对象和基本编程概念（如变量、循环和条件控制），则可以完成本示例。 通过Android Studio和VS Code根据前面“编辑器配置与使用”一章中介绍的创建Flutter工程的方法创建一个新的Flutter工程，命名为\"first_flutter_app\"。创建好后，就会得到一个计数器应用的Demo。 注意，默认Demo示例可能随着编辑器Flutter插件版本变化而变化，本例中会介绍计数器示例的全部代码，所以不会对本示例产生影响。 我们先运行此示例，效果图如下： 该计数器示例中，每点击一次右下角带“➕”号的悬浮按钮，屏幕中央的数字就会加1。 在这个示例中，主要Dart代码是在 lib/main.dart 文件中，下面我们看看该示例的源码： import 'package:flutter/material.dart'; void main() => runApp(new MyApp()); class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp( title: 'Flutter Demo', theme: new ThemeData( primarySwatch: Colors.blue, ), home: new MyHomePage(title: 'Flutter Demo Home Page'), ); } } class MyHomePage extends StatefulWidget { MyHomePage({Key key, this.title}) : super(key: key); final String title; @override _MyHomePageState createState() => new _MyHomePageState(); } class _MyHomePageState extends State { int _counter = 0; void _incrementCounter() { setState(() { _counter++; }); } @override Widget build(BuildContext context) { return new Scaffold( appBar: new AppBar( title: new Text(widget.title), ), body: new Center( child: new Column( mainAxisAlignment: MainAxisAlignment.center, children: [ new Text( 'You have pushed the button this many times:', ), new Text( '$_counter', style: Theme.of(context).textTheme.display1, ), ], ), ), floatingActionButton: new FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: new Icon(Icons.add), ), // This trailing comma makes auto-formatting nicer for build methods. ); } } 分析 导入包。 import 'package:flutter/material.dart'; 此行代码作用是导入了Material UI组件库。Material是一种标准的移动端和web端的视觉设计语言， Flutter默认提供了一套丰富的Material风格的UI组件。 应用入口。 void main() => runApp(new MyApp()); 与C/C++、Java类似，Flutter 应用中main函数为应用程序的入口，main函数中调用了，runApp 方法，它的功能是启动Flutter应用，它接受一个Widget参数，在本示例中它是MyApp类的一个实例，该参数代表Flutter应用。 main函数使用了(=>)符号，这是Dart中单行函数或方法的简写。 应用结构。 class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp( //应用名称 title: 'Flutter Demo', theme: new ThemeData( //蓝色主题 primarySwatch: Colors.blue, ), //应用首页路由 home: new MyHomePage(title: 'Flutter Demo Home Page'), ); } } MyApp类代表Flutter应用，它继承了 StatelessWidget类，这也就意味着应用本身也是一个widget。 在Flutter中，大多数东西都是widget，包括对齐(alignment)、填充(padding)和布局(layout)。 Flutter在构建页面时，会调用组件的build方法，widget的主要工作是提供一个build()方法来描述如何构建UI界面（通常是通过组合、拼装其它基础widget）。 MaterialApp 是Material库中提供的Flutter APP框架，通过它可以设置应用的名称、主题、语言、首页及路由列表等。MaterialApp也是一个widget。 Scaffold 是Material库中提供的页面脚手架，它包含导航栏和Body以及FloatingActionButton（如果需要的话）。 本书后面示例中，路由默认都是通过Scaffold创建。 home 为Flutter应用的首页，它也是一个widget。 首页 class MyHomePage extends StatefulWidget { MyHomePage({Key key, this.title}) : super(key: key); final String title; @override _MyHomePageState createState() => new _MyHomePageState(); } class _MyHomePageState extends State { ... } MyHomePage 是应用的首页，它继承自StatefulWidget类，表示它是一个有状态的widget（Stateful widget）。现在，我们可以简单认为Stateful widget 和Stateless widget有两点不同： Stateful widget可以拥有状态，这些状态在widget生命周期中是可以变的，而Stateless widget是不可变的。 Stateful widget至少由两个类组成： 一个StatefulWidget类。 一个 State类； StatefulWidget类本身是不变的，但是 State类中持有的状态在widget生命周期中可能会发生变化。 _MyHomePageState类是MyHomePage类对应的状态类。看到这里，细心的读者可能已经发现，和MyApp 类不同， MyHomePage类中并没有build方法，取而代之的是，build方法被挪到了_MyHomePageState方法中，至于为什么这么做，先留个疑问，在分析完完整代码后再来解答。 接下来，我们看看_MyHomePageState中都包含哪些东西： 状态。 int _counter = 0; _counter 为保存屏幕右下角带“➕”号按钮点击次数的状态。 设置状态的自增函数。 void _incrementCounter() { setState(() { _counter++; }); } 当按钮点击时，会调用此函数，该函数的作用是先自增_counter，然后调用setState 方法。setState方法的作用是通知Flutter框架，有状态发生了改变，Flutter框架收到通知后，会执行build方法来根据新的状态重新构建界面， Flutter 对此方法做了优化，使重新执行变的很快，所以你可以重新构建任何需要更新的东西，而无需分别去修改各个widget。 构建UI界面 构建UI界面的逻辑在build方法中，当MyHomePage第一次创建时，_MyHomePageState类会被创建，当初始化完成后，Flutter框架会调用Widget的build方法来构建widget树，最终将widget树渲染到设备屏幕上。所以，我们看看_MyHomePageState的build方法中都干了什么事： Widget build(BuildContext context) { return new Scaffold( appBar: new AppBar( title: new Text(widget.title), ), body: new Center( child: new Column( mainAxisAlignment: MainAxisAlignment.center, children: [ new Text( 'You have pushed the button this many times:', ), new Text( '$_counter', style: Theme.of(context).textTheme.display1, ), ], ), ), floatingActionButton: new FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: new Icon(Icons.add), ), ); } Scaffold 是 Material库中提供的一个widget, 它提供了默认的导航栏、标题和包含主屏幕widget树的body属性。widget树可以很复杂。 body的widget树中包含了一个Center widget，Center 可以将其子widget树对齐到屏幕中心， Center 子widget是一个Column widget，Column的作用是将其所有子widget沿屏幕垂直方向依次排列， 此例中Column包含两个 Text子widget，第一个Text widget显示固定文本 “You have pushed the button this many times:”，第二个Text widget显示_counter状态的数值。 floatingActionButton是页面右下角的带“➕”的悬浮按钮，它的onPressed属性接受一个回调函数，代表它本点击后的处理器，本例中直接将_incrementCounter作为其处理函数。 现在，我们将整个流程串起来：当右下角的floatingActionButton按钮被点击之后，会调用_incrementCounter，在_incrementCounter中，首先会自增_counter计数器（状态），然后setState会通知Flutter框架状态发生变化，接着，Flutter会调用build方法以新的状态重新构建UI，最终显示在设备屏幕上。 为什么要将build方法放在State中，而不是放在StatefulWidget中？ 现在，我们回答之前提出的问题，为什么build()方法在State（而不是StatefulWidget）中 ？这主要是为了开发的灵活性。如果将build()方法在StatefulWidget中则会有两个问题： 状态访问不便 试想一下，如果我们的Stateful widget 有很多状态，而每次状态改变都要调用build方法，由于状态是保存在State中的，如果将build方法放在StatefulWidget中，那么构建时读取状态将会很不方便，试想一下，如果真的将build方法放在StatefulWidget中的话，由于构建用户界面过程需要依赖State，所以build方法将必须加一个State参数，大概是下面这样： Widget build(BuildContext context, State state){ //state.counter ... } 这样的话就只能将State的所有状态声明为公开的状态，这样才能在State类外部访问状态，但将状态设置为公开后，状态将不再具有私密性，这样依赖，对状态的修改将会变的不可控。将build()方法放在State中的话，构建过程则可以直接访问状态，这样会很方便。 继承StatefulWidget不便 例如，Flutter中有一个动画widget的基类AnimatedWidget，它继承自StatefulWidget类。AnimatedWidget中引入了一个抽象方法build(BuildContext context)，继承自AnimatedWidget的动画widget都要实现这个build方法。现在设想一下，如果StatefulWidget 类中已经有了一个build方法，正如上面所述，此时build方法需要接收一个state对象，这就意味着AnimatedWidget必须将自己的State对象(记为_animatedWidgetState)提供给其子类，因为子类需要在其build方法中调用父类的build方法，代码可能如下： class MyAnimationWidget extends AnimatedWidget{ @override Widget build(BuildContext context, State state){ //由于子类要用到AnimatedWidget的状态对象_animatedWidgetState， //所以AnimatedWidget必须通过某种方式将其状态对象_animatedWidgetState //暴露给其子类 super.build(context, _animatedWidgetState) } } 这样很显然是不合理的，因为 AnimatedWidget的状态对象是AnimatedWidget内部实现细节，不应该暴露给外部。 如果要将父类状态暴露给子类，那么必须得有一种传递机制，而做这一套传递机制是无意义的，因为父子类之间状态的传递和子类本身逻辑是无关的。 综上所述，可以发现，对于StatefulWidget，将build方法放在State中，可以给开发带来很大的灵活性。 "},"chapter2/flutter_router.html":{"url":"chapter2/flutter_router.html","title":"路由管理","keywords":"","body":"路由管理 路由(Route)在移动开发中通常指页面（Page），这跟web开发中单页应用的Route概念意义是相同的，Route在Android中通常指一个Activity，在iOS中指一个ViewController。所谓路由管理，就是管理页面之间如何跳转，通常也可被称为导航管理。这和原生开发类似，无论是Android还是iOS，导航管理都会维护一个路由栈，路由入栈(push)操作对应打开一个新页面，路由出栈(pop)操作对应页面关闭操作，而路由管理主要是指如何来管理路由栈。 示例 我们在上一节“计数器”示例的基础上，做如下修改： 创建一个新路由，命名“NewRoute” class NewRoute extends StatelessWidget { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(\"New route\"), ), body: Center( child: Text(\"This is new route\"), ), ); } } 新路由继承自StatelessWidget，界面很简单，在页面中间显示一句\"This is new route\"。 在_MyHomePageState.build方法中的Column的子widget中添加一个按钮（FlatButton） : Column( mainAxisAlignment: MainAxisAlignment.center, children: [ ... //省略无关代码 FlatButton( child: Text(\"open new route\"), textColor: Colors.blue, onPressed: () { //导航到新路由 Navigator.push( context, new MaterialPageRoute(builder: (context) { return new NewRoute(); })); }, ), ], ) 我们添加了一个打开新路由的按钮，并将按钮文字颜色设置为蓝色，点击该按钮后就会打开新的路由页面。 MaterialPageRoute MaterialPageRoute继承自PageRoute类，PageRoute类是一个抽象类，表示占有整个屏幕空间的一个模态路由页面，它还定义了路由构建及切换时过渡动画的相关接口及属性。MaterialPageRoute 是Material组件库的一个Widget，它可以针对不同平台，实现与平台页面切换动画风格一致的路由切换动画： 对于Android，当打开新页面时，新的页面会从屏幕底部滑动到屏幕顶部；当关闭页面时，当前页面会从屏幕顶部滑动到屏幕底部后消失，同时上一个页面会显示到屏幕上。 对于iOS，当打开页面时，新的页面会从屏幕右侧边缘一致滑动到屏幕左边，直到新页面全部显示到屏幕上，而上一个页面则会从当前屏幕滑动到屏幕左侧而消失；当关闭页面时，正好相反，当前页面会从屏幕右侧滑出，同时上一个页面会从屏幕左侧滑入。 下面我们介绍一下MaterialPageRoute 构造函数的各个参数的意义： MaterialPageRoute({ WidgetBuilder builder, RouteSettings settings, bool maintainState = true, bool fullscreenDialog = false, }) builder 是一个WidgetBuilder类型的回调函数，它的作用是构建路由页面的具体内容，返回值是一个widget。我们通常要实现此回调，返回新路由的实例。 settings 包含路由的配置信息，如路由名称、是否初始路由（首页）。 maintainState：默认情况下，当入栈一个新路由时，原来的路由仍然会被保存在内存中，如果想在路由没用的时候释放其所占用的所有资源，可以设置maintainState为false。 fullscreenDialog表示新的路由页面是否是一个全屏的模态对话框，在iOS中，如果fullscreenDialog为true，新页面将会从屏幕底部滑入（而不是水平方向）。 如果想自定义路由切换动画，可以自己继承PageRoute来实现，我们将在后面介绍动画时，实现一个自定义的路由Widget。 Navigator Navigator是一个路由管理的widget，它通过一个栈来管理一个路由widget集合。通常当前屏幕显示的页面就是栈顶的路由。Navigator提供了一系列方法来管理路由栈，在此我们只介绍其最常用的两个方法： Future push(BuildContext context, Route route) 将给定的路由入栈（即打开新的页面），返回值是一个Future对象，用以接收新路由出栈（及关闭）时的返回数据。 bool pop(BuildContext context, [ result ]) 将栈顶路由出栈，result为页面关闭时返回给上一个页面的数据。 Navigator 还有很多其它方法，如Navigator.replace、Navigator.popUntil等，详情请参考API文档或SDK源码注释，在此不再赘述。下面我们还需要介绍一下路由相关的另一个概念“命名路由”。 命名路由 所谓命名路由（Named Route）即给路由起一个名字，然后可以通过路由名字直接打开新的路由。这为路由管理带来了一种直观、简单的方式。 路由表 要想使用命名路由，我们必须先提供并注册一个路由表（routing table），这样应用程序才知道哪个名称与哪个路由Widget对应。路由表的定义如下： Map routes； 它是一个Map， key 为路由的名称，是个字符串；value是个builder回调函数，用于生成相应的路由Widget。我们在通过路由名称入栈新路由时，应用会根据路由名称在路由表中找到对应的WidgetBuilder回调函数，然后调用该回调函数生成路由widget并返回。 注册路由表 我们需要先注册路由表后，我们的Flutter应用才能正确处理命名路由的跳转。注册方式很简单，我们回到之前“计数器”的示例，然后在MyApp类的build方法中找到MaterialApp，添加routes属性，代码如下： return new MaterialApp( title: 'Flutter Demo', theme: new ThemeData( primarySwatch: Colors.blue, ), //注册路由表 routes:{ \"new_page\":(context)=>NewRoute(), } , home: new MyHomePage(title: 'Flutter Demo Home Page'), ); 现在我们就完成了路由表的注册。 通过路由名打开新路由页 要通过路由名称来打开新路由，可以使用： Future pushNamed(BuildContext context, String routeName) Navigator 除了pushNamed方法，还有pushReplacementNamed等其他管理命名路由的方法，读者可以自行查看API文档。 接下来我们通过路由名来打开新的路由页，修改FlatButton的onPressed回调代码，改为： onPressed: () { Navigator.pushNamed(context, \"new_page\"); //Navigator.push(context, // new MaterialPageRoute(builder: (context) { // return new NewRoute(); //})); }, 热重载应用，再次点击“open new route”按钮，依然可以打开新的路由页。 命名路由的优缺点 命名路由的最大优点是直观，我们可以通过语义化的字符串来管理路由。但其有一个明显的缺点：不能直接传递路由参数。举个例子，假设有一个新路由EchoRoute，它的功能是接受一个字符串参数tip，然后再在屏幕中心将tip的内容显示出来，代码如下： class EchoRoute extends StatelessWidget { EchoRoute(this.tip); final String tip; @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(\"Echo route\"), ), body: Center( //回显tip内容 child: Text(tip), ), ); } } 如果我们使用命名参数，就必须将路由提前注册到路由表中，所以就无法动态修改tip参数，如： { \"tip_widgets\":(context)=>EchoRoute(\"内容固定\") } 综上所述，我们可以看到当路由需要参数时，使用命名路由则不够灵活。 "},"chapter2/flutter_package_mgr.html":{"url":"chapter2/flutter_package_mgr.html","title":"包管理","keywords":"","body":"包管理 一个完整的应用程序往往会依赖很多第三方包，正如在原生开发中，Android使用Gradle来管理依赖，iOS用Cocoapods或Carthage来管理依赖，而Flutter也有自己的依赖管理工具，本节我们主要介绍一下flutter如何使用配置文件pubspec.yaml（位于项目根目录）来管理第三方依赖包。 YAML是一种直观、可读性高并且容易被人类阅读的文件格式，它和xml或Json相比，它语法简单并非常容易解析，所以YAML常用于配置文件，Flutter也是用yaml文件作为其配置文件，Flutter项目默认的配置文件是pubspec.yaml，我们看一个简单的示例： name: flutter_in_action description: First Flutter application. version: 1.0.0+1 dependencies: flutter: sdk: flutter cupertino_icons: ^0.1.2 dev_dependencies: flutter_test: sdk: flutter flutter: uses-material-design: true 下面，我们逐一解释一下各个字段的意义： name：应用或包名称。 description: 应用或包的描述、简介。 version：应用或包的版本号。 dependencies：应用或包依赖的其它包或插件。 dev_dependencies：开发环境依赖的工具包（而不是flutter应用本身依赖的包）。 flutter：flutter相关的配置选项。 如果我们的Flutter应用本身依赖某个包，我们需要将所依赖的包添加到dependencies 下，接下来我们通过一个例子来演示一下如何依赖、下载并使用第三方包。 Pub仓库 Pub（https://pub.dartlang.org/ ）是Google官方的Dart Packages仓库，类似于node中的npm仓库，android中的jcenter，我们可以在上面查找我们需要的包和插件，也可以向pub发布我们的包和插件。我们将在后面的章节中介绍如何向pub发布我们的包和插件。 示例 接下来，我们实现一个显示随机字符串的widget。有一个名为“english_words”的开源软件包，其中包含数千个常用的英文单词以及一些实用功能。我们首先在pub上找到english_words这个包，确定其最新的版本号和是否支持Flutter。 我们看到“english_words”包最新的版本是3.1.3，并且支持flutter，接下来： 将english_words（3.1.3版本）添加到依赖项列表，如下： dependencies: flutter: sdk: flutter cupertino_icons: ^0.1.0 # 新添加的依赖 english_words: ^3.1.3 下载包 在Android Studio的编辑器视图中查看pubspec.yaml时，单击右上角的 Packages get 。 这会将依赖包安装到您的项目。您可以在控制台中看到以下内容： flutter packages get Running \"flutter packages get\" in flutter_in_action... Process finished with exit code 0 你也可以在控制台，定位到当前工程目录，然后手动运行flutter packages get 命令来下载依赖包。 引入english_words包。 import 'package:english_words/english_words.dart'; 在输入时，Android Studio会自动提供有关库导入的建议选项。导入后该行代码将会显示为灰色，表示导入的库尚未使用。 使用english_words包来生成随机字符串。 class RandomWordsWidget extends StatelessWidget { @override Widget build(BuildContext context) { // 生成随机字符串 final wordPair = new WordPair.random(); return Padding( padding: const EdgeInsets.all(8.0), child: new Text(wordPair.toString()), ); } } 我们将RandomWordsWidget 添加到\"计数器\"示例的首页MyHomePage 的Column的子widget中。 如果应用程序正在运行，请使用热重载按钮 () 更新正在运行的应用程序。每次单击热重载或保存项目时，都会在正在运行的应用程序中随机选择不同的单词对。 这是因为单词对是在 build 方法内部生成的。每次热更新时，build方法都会被执行。 其它依赖方式 上文所述的依赖方式是依赖pub仓库的。但我们还可以依赖本地包和git仓库。 依赖本地包 如果我们正在本地开发一个包，包名为pkg1，我们可以通过下面方式依赖： dependencies: pkg1: path: ../../code/pkg1 路径可以是相对的，也可以是绝对的。 依赖Git：你也可以依赖存储在Git仓库中的包。如果软件包位于仓库的根目录中，请使用以下语法 dependencies: pkg1: git: url: git://github.com/xxx/pkg1.git 上面假定包位于Git存储库的根目录中。如果不是这种情况，可以使用path参数指定相对位置，例如： dependencies: package1: git: url: git://github.com/flutter/packages.git path: packages/package1 总结 本节介绍了引用、下载、使用一个包的整体流程，并在后面介绍了多种不同的引入方式，这些是Flutter开发中常用的，但Dart的dependencies还有一些其它依赖方式，完整的内容读者可以自行查看：https://www.dartlang.org/tools/pub/dependencies 。 "},"chapter2/flutter_assets_mgr.html":{"url":"chapter2/flutter_assets_mgr.html","title":"资源管理","keywords":"","body":"资源管理 Flutter应用程序可以包含代码和 assets（有时称为资源）。assets是会打包到程序安装包中的，可在运行时访问。常见类型的assets包括静态数据（例如JSON文件）、配置文件、图标和图片（JPEG，WebP，GIF，动画WebP / GIF，PNG，BMP和WBMP）等。 指定 assets 和包管理一样，Flutter也使用pubspec.yaml文件来管理应用程序所需的资源。举一个例子: flutter: assets: - assets/my_icon.png - assets/background.png assets指定应包含在应用程序中的文件。 每个asset都通过相对于pubspec.yaml文件所在位置的显式路径进行标识。asset的声明顺序是无关紧要的。asset的实际目录可以是任意文件夹（在本示例中是assets）。 在构建期间，Flutter将asset放置到称为 asset bundle 的特殊存档中，应用程序可以在运行时读取它们（但不能修改）。 Asset 变体（variant） 构建过程支持asset变体的概念：不同版本的asset可能会显示在不同的上下文中。 在pubspec.yaml的assets部分中指定asset路径时，构建过程中，会在相邻子目录中查找具有相同名称的任何文件。这些文件随后会与指定的asset一起被包含在asset bundle中。 例如，如果应用程序目录中有以下文件: …/pubspec.yaml …/graphics/my_icon.png …/graphics/background.png …/graphics/dark/background.png …etc. 然后pubspec.yaml文件中只需包含: flutter: assets: - graphics/background.png 那么这两个graphics/background.png和graphics/dark/background.png 都将包含在您的asset bundle中。前者被认为是main asset （主资源），后者被认为是一种变体（variant）。 在选择匹配当前设备分辨率的图片时，Flutter会使用到asset变体（见下文），将来，Flutter可能会将这种机制扩展到本地化、阅读提示等方面。 加载 assets 您的应用可以通过AssetBundle对象访问其asset 。有两种主要方法允许从Asset bundle中加载字符串或图片(二进制)文件。 加载文本assets 通过rootBundle 对象加载：每个Flutter应用程序都有一个rootBundle对象， 通过它可以轻松访问主资源包，直接使用package:flutter/services.dart中全局静态的rootBundle对象来加载asset即可。 通过 DefaultAssetBundle 加载：建议使用 DefaultAssetBundle 来获取当前BuildContext的AssetBundle。 这种方法不是使用应用程序构建的默认asset bundle，而是使父级widget在运行时动态替换的不同的AssetBundle，这对于本地化或测试场景很有用。 通常，可以使用DefaultAssetBundle.of()在应用运行时来间接加载asset（例如JSON文件），而在widget上下文之外，或其它AssetBundle句柄不可用时，可以使用rootBundle直接加载这些asset，例如： import 'dart:async' show Future; import 'package:flutter/services.dart' show rootBundle; Future loadAsset() async { return await rootBundle.loadString('assets/config.json'); } 加载图片 类似于原生开发，Flutter也可以为当前设备加载适合其分辨率的图像。 声明分辨率相关的图片 assets AssetImage 可以将asset的请求逻辑映射到最接近当前设备像素比例(dpi)的asset。为了使这种映射起作用，必须根据特定的目录结构来保存asset： …/image.png …/Mx/image.png …/Nx/image.png …etc. 其中M和N是数字标识符，对应于其中包含的图像的分辨率，也就是说，它们指定不同设备像素比例的图片。 主资源默认对应于1.0倍的分辨率图片。看一个例子： …/my_icon.png …/2.0x/my_icon.png …/3.0x/my_icon.png 在设备像素比率为1.8的设备上，.../2.0x/my_icon.png 将被选择。对于2.7的设备像素比率，.../3.0x/my_icon.png将被选择。 如果未在Image widget上指定渲染图像的宽度和高度，那么Image widget将占用与主资源相同的屏幕空间大小。 也就是说，如果.../my_icon.png是72px乘72px，那么.../3.0x/my_icon.png应该是216px乘216px; 但如果未指定宽度和高度，它们都将渲染为72像素×72像素（以逻辑像素为单位）。 pubspec.yaml中asset部分中的每一项都应与实际文件相对应，但主资源项除外。当主资源缺少某个资源时，会按分辨率从低到高的顺序去选择 ，也就是说1x中没有的话会在2x中找，2x中还没有的话就在3x中找。 加载图片 要加载图片，可以使用 AssetImage类。例如，我们可以从上面的asset声明中加载背景图片： Widget build(BuildContext context) { return new DecoratedBox( decoration: new BoxDecoration( image: new DecorationImage( image: new AssetImage('graphics/background.png'), ), ), ); } 注意，AssetImage 并非是一个widget， 它实际上是一个ImageProvider，有些时候你可能期望直接得到一个显示图片的widget，那么你可以使用Image.asset()方法，如： Widget build(BuildContext context) { return Image.asset('graphics/background.png'); } 使用默认的 asset bundle 加载资源时，内部会自动处理分辨率等，这些处理对开发者来说是无感知的。 (如果使用一些更低级别的类，如 ImageStream或 ImageCache 时你会注意到有与缩放相关的参数) 依赖包中的资源图片 要加载依赖包中的图像，必须给AssetImage提供package参数。 例如，假设您的应用程序依赖于一个名为“my_icons”的包，它具有如下目录结构： …/pubspec.yaml …/icons/heart.png …/icons/1.5x/heart.png …/icons/2.0x/heart.png …etc. 然后加载图像，使用: new AssetImage('icons/heart.png', package: 'my_icons') 或 new Image.asset('icons/heart.png', package: 'my_icons') 注意：包在使用本身的资源时也应该加上package参数来获取。 打包包中的 assets 如果在pubspec.yaml文件中声明了期望的资源，它将会打包到相应的package中。特别是，包本身使用的资源必须在pubspec.yaml中指定。 包也可以选择在其lib/文件夹中包含未在其pubspec.yaml文件中声明的资源。在这种情况下，对于要打包的图片，应用程序必须在pubspec.yaml中指定包含哪些图像。 例如，一个名为“fancy_backgrounds”的包，可能包含以下文件： …/lib/backgrounds/background1.png …/lib/backgrounds/background2.png …/lib/backgrounds/background3.png 要包含第一张图像，必须在pubspec.yaml的assets部分中声明它： flutter: assets: - packages/fancy_backgrounds/backgrounds/background1.png lib/是隐含的，所以它不应该包含在资产路径中。 特定平台 assets 上面的资源都是flutter应用中的，这些资源只有在Flutter框架运行之后才能使用，如果要给我们的应用设置APP图标或者添加启动图，那我们必须使用特定平台的assets。 设置APP图标 更新Flutter应用程序启动图标的方式与在本机Android或iOS应用程序中更新启动图标的方式相同。 Android 在Flutter项目的根目录中，导航到.../android/app/src/main/res目录，里面包含了各种资源文件夹（如mipmap-hdpi已包含占位符图像”ic_launcher.png”）。 只需按照Android开发人员指南中的说明， 将其替换为所需的资源，并遵守每种屏幕密度（dpi）的建议图标大小标准。 注意: 如果您重命名.png文件，则还必须在您AndroidManifest.xml的标签的android:icon属性中更新名称。 iOS 在Flutter项目的根目录中，导航到.../ios/Runner。该目录中Assets.xcassets/AppIcon.appiconset已经包含占位符图片。 只需将它们替换为适当大小的图片。保留原始文件名称。 更新启动页 在Flutter框架加载时，Flutter会使用本地平台机制绘制启动页。此启动页将持续到Flutter渲染应用程序的第一帧时。 注意: 这意味着如果您不在应用程序的main()方法中调用runApp 函数 （或者更具体地说，如果您不调用window.render去响应window.onDrawFrame）的话， 启动屏幕将永远持续显示。 Android 要将启动屏幕（splash screen）添加到您的Flutter应用程序， 请导航至.../android/app/src/main。在res/drawable/launch_background.xml，通过自定义drawable来实现自定义启动界面（你也可以直接换一张图片）。 iOS 要将图片添加到启动屏幕（splash screen）的中心，请导航至.../ios/Runner。在Assets.xcassets/LaunchImage.imageset， 拖入图片，并命名为LaunchImage.png、LaunchImage@2x.png、LaunchImage@3x.png。 如果你使用不同的文件名，那您还必须更新同一目录中的Contents.json文件，图片的具体尺寸可以查看苹果官方的标准。 您也可以通过打开Xcode完全自定义storyboard。在Project Navigator中导航到Runner/Runner然后通过打开Assets.xcassets拖入图片，或者通过在LaunchScreen.storyboard中使用Interface Builder进行自定义。 "},"chapter2/flutter_app_debug.html":{"url":"chapter2/flutter_app_debug.html","title":"调试Flutter APP","keywords":"","body":"调试Flutter应用 有各种各样的工具和功能来帮助调试Flutter应用程序。 Dart 分析器 在运行应用程序前，请运行flutter analyze测试你的代码。这个工具（它是dartanalyzer工具的一个包装）将分析你的代码并帮助你发现可能的错误。 如果你使用IntelliJ的Flutter插件，那么已经自动启用了。 Dart分析器大量使用了代码中的类型注释来帮助追踪问题。我们鼓励您在任何地方使用它们（避免var、无类型的参数、无类型的列表文字等），因为这是追踪问题的最快的方式。 Dart Observatory (语句级的单步调试和分析器) 如果您使用flutter run启动应用程序，那么当它运行时，您可以打开Observatory URL的Web页面（例如Observatory监听http://127.0.0.1:8100/）， 直接使用语句级单步调试器连接到您的应用程序。如果您使用的是IntelliJ，则还可以使用其内置的调试器来调试您的应用程序。 Observatory 同时支持分析、检查堆等。有关Observatory的更多信息请参考Observatory 文档. 如果您使用Observatory进行分析，请确保通过--profile选项来运行flutter run命令来运行应用程序。 否则，配置文件中将出现的主要问题将是调试断言，以验证框架的各种不变量（请参阅下面的“调试模式断言”）。 debugger() 声明 当使用Dart Observatory（或另一个Dart调试器，例如IntelliJ IDE中的调试器）时，可以使用该debugger()语句插入编程式断点。要使用这个，你必须添加import 'dart:developer';到相关文件顶部。 debugger()语句采用一个可选when参数，您可以指定该参数仅在特定条件为真时中断，如下所示： void someFunction(double offset) { debugger(when: offset > 30.0); // ... } print、debugPrint、flutter logs Dart print()功能将输出到系统控制台，您可以使用flutter logs了查看它（基本上是一个包装adb logcat）。 如果你一次输出太多，那么Android有时会丢弃一些日志行。为了避免这种情况，您可以使用Flutter的foundation库中的debugPrint()。 这是一个封装print，它将输出限制在一个级别，避免被Android内核丢弃。 Flutter框架中的许多类都有toString实现。按照惯例，这些输出通常包括对象的runtimeType单行输出，通常在表单中ClassName(more information about this instance…)。 树中使用的一些类也具有toStringDeep，从该点返回整个子树的多行描述。已一些具有详细信息toString的类会实现一个toStringShort，它只返回对象的类型或其他非常简短的（一个或两个单词）描述。 调试模式断言 在开发过程中，强烈建议您使用Flutter的“调试”模式，有时也称为“checked”模式（注意：Dart2.0后“checked”被废除，可以使用“strong” mode）。 如果您使用flutter run运行程序。在这种模式下，Dart assert语句被启用，并且Flutter框架使用它来执行许多运行时检查来验证是否违反一些不可变的规则。 当一个不可变的规则被违反时，它被报告给控制台，并带有一些上下文信息来帮助追踪问题的根源。 要关闭调试模式并使用发布模式，请使用flutter run --release运行您的应用程序。 这也关闭了Observatory调试器。一个中间模式可以关闭除Observatory之外所有调试辅助工具的，称为“profile mode”，用--profile替代--release即可。 调试应用程序层 Flutter框架的每一层都提供了将其当前状态或事件转储(dump)到控制台（使用debugPrint）的功能。 Widget 层 要转储Widgets库的状态，请调用debugDumpApp()。 只要应用程序已经构建了至少一次（即在调用build()之后的任何时间），您可以在应用程序未处于构建阶段（即，不在build()方法内调用 ）的任何时间调用此方法（在调用runApp()之后）。 如, 这个应用程序: import 'package:flutter/material.dart'; void main() { runApp( new MaterialApp( home: new AppHome(), ), ); } class AppHome extends StatelessWidget { @override Widget build(BuildContext context) { return new Material( child: new Center( child: new FlatButton( onPressed: () { debugDumpApp(); }, child: new Text('Dump App'), ), ), ); } } …会输出这样的内容（精确的细节会根据框架的版本、设备的大小等等而变化）： I/flutter ( 6559): WidgetsFlutterBinding - CHECKED MODE I/flutter ( 6559): RenderObjectToWidgetAdapter([GlobalObjectKey RenderView(497039273)]; renderObject: RenderView) I/flutter ( 6559): └MaterialApp(state: _MaterialAppState(1009803148)) I/flutter ( 6559): └ScrollConfiguration() I/flutter ( 6559): └AnimatedTheme(duration: 200ms; state: _AnimatedThemeState(543295893; ticker inactive; ThemeDataTween(ThemeData(Brightness.light Color(0xff2196f3) etc...) → null))) I/flutter ( 6559): └Theme(ThemeData(Brightness.light Color(0xff2196f3) etc...)) I/flutter ( 6559): └WidgetsApp([GlobalObjectKey _MaterialAppState(1009803148)]; state: _WidgetsAppState(552902158)) I/flutter ( 6559): └CheckedModeBanner() I/flutter ( 6559): └Banner() I/flutter ( 6559): └CustomPaint(renderObject: RenderCustomPaint) I/flutter ( 6559): └DefaultTextStyle(inherit: true; color: Color(0xd0ff0000); family: \"monospace\"; size: 48.0; weight: 900; decoration: double Color(0xffffff00) TextDecoration.underline) I/flutter ( 6559): └MediaQuery(MediaQueryData(size: Size(411.4, 683.4), devicePixelRatio: 2.625, textScaleFactor: 1.0, padding: EdgeInsets(0.0, 24.0, 0.0, 0.0))) I/flutter ( 6559): └LocaleQuery(null) I/flutter ( 6559): └Title(color: Color(0xff2196f3)) I/flutter ( 6559): └Navigator([GlobalObjectKey _WidgetsAppState(552902158)]; state: NavigatorState(240327618; tracking 1 ticker)) I/flutter ( 6559): └Listener(listeners: down, up, cancel; behavior: defer-to-child; renderObject: RenderPointerListener) I/flutter ( 6559): └AbsorbPointer(renderObject: RenderAbsorbPointer) I/flutter ( 6559): └Focus([GlobalKey 489139594]; state: _FocusState(739584448)) I/flutter ( 6559): └Semantics(container: true; renderObject: RenderSemanticsAnnotations) I/flutter ( 6559): └_FocusScope(this scope has focus; focused subscope: [GlobalObjectKey MaterialPageRoute(875520219)]) I/flutter ( 6559): └Overlay([GlobalKey 199833992]; state: OverlayState(619367313; entries: [OverlayEntry@248818791(opaque: false; maintainState: false), OverlayEntry@837336156(opaque: false; maintainState: true)])) I/flutter ( 6559): └_Theatre(renderObject: _RenderTheatre) I/flutter ( 6559): └Stack(renderObject: RenderStack) I/flutter ( 6559): ├_OverlayEntry([GlobalKey 612888877]; state: _OverlayEntryState(739137453)) I/flutter ( 6559): │└IgnorePointer(ignoring: false; renderObject: RenderIgnorePointer) I/flutter ( 6559): │ └ModalBarrier() I/flutter ( 6559): │ └Semantics(container: true; renderObject: RenderSemanticsAnnotations) I/flutter ( 6559): │ └GestureDetector() I/flutter ( 6559): │ └RawGestureDetector(state: RawGestureDetectorState(39068508; gestures: tap; behavior: opaque)) I/flutter ( 6559): │ └_GestureSemantics(renderObject: RenderSemanticsGestureHandler) I/flutter ( 6559): │ └Listener(listeners: down; behavior: opaque; renderObject: RenderPointerListener) I/flutter ( 6559): │ └ConstrainedBox(BoxConstraints(biggest); renderObject: RenderConstrainedBox) I/flutter ( 6559): └_OverlayEntry([GlobalKey 727622716]; state: _OverlayEntryState(279971240)) I/flutter ( 6559): └_ModalScope([GlobalKey 816151164]; state: _ModalScopeState(875510645)) I/flutter ( 6559): └Focus([GlobalObjectKey MaterialPageRoute(875520219)]; state: _FocusState(331487674)) I/flutter ( 6559): └Semantics(container: true; renderObject: RenderSemanticsAnnotations) I/flutter ( 6559): └_FocusScope(this scope has focus) I/flutter ( 6559): └Offstage(offstage: false; renderObject: RenderOffstage) I/flutter ( 6559): └IgnorePointer(ignoring: false; renderObject: RenderIgnorePointer) I/flutter ( 6559): └_MountainViewPageTransition(animation: AnimationController(⏭ 1.000; paused; for MaterialPageRoute(/))➩ProxyAnimation➩Cubic(0.40, 0.00, 0.20, 1.00)➩Tween(Offset(0.0, 1.0) → Offset(0.0, 0.0))➩Offset(0.0, 0.0); state: _AnimatedState(552160732)) I/flutter ( 6559): └SlideTransition(animation: AnimationController(⏭ 1.000; paused; for MaterialPageRoute(/))➩ProxyAnimation➩Cubic(0.40, 0.00, 0.20, 1.00)➩Tween(Offset(0.0, 1.0) → Offset(0.0, 0.0))➩Offset(0.0, 0.0); state: _AnimatedState(714726495)) I/flutter ( 6559): └FractionalTranslation(renderObject: RenderFractionalTranslation) I/flutter ( 6559): └RepaintBoundary(renderObject: RenderRepaintBoundary) I/flutter ( 6559): └PageStorage([GlobalKey 619728754]) I/flutter ( 6559): └_ModalScopeStatus(active) I/flutter ( 6559): └AppHome() I/flutter ( 6559): └Material(MaterialType.canvas; elevation: 0; state: _MaterialState(780114997)) I/flutter ( 6559): └AnimatedContainer(duration: 200ms; has background; state: _AnimatedContainerState(616063822; ticker inactive; has background)) I/flutter ( 6559): └Container(bg: BoxDecoration()) I/flutter ( 6559): └DecoratedBox(renderObject: RenderDecoratedBox) I/flutter ( 6559): └Container(bg: BoxDecoration(backgroundColor: Color(0xfffafafa))) I/flutter ( 6559): └DecoratedBox(renderObject: RenderDecoratedBox) I/flutter ( 6559): └NotificationListener() I/flutter ( 6559): └_InkFeature([GlobalKey ink renderer]; renderObject: _RenderInkFeatures) I/flutter ( 6559): └AnimatedDefaultTextStyle(duration: 200ms; inherit: false; color: Color(0xdd000000); family: \"Roboto\"; size: 14.0; weight: 400; baseline: alphabetic; state: _AnimatedDefaultTextStyleState(427742350; ticker inactive)) I/flutter ( 6559): └DefaultTextStyle(inherit: false; color: Color(0xdd000000); family: \"Roboto\"; size: 14.0; weight: 400; baseline: alphabetic) I/flutter ( 6559): └Center(alignment: Alignment.center; renderObject: RenderPositionedBox) I/flutter ( 6559): └FlatButton() I/flutter ( 6559): └MaterialButton(state: _MaterialButtonState(398724090)) I/flutter ( 6559): └ConstrainedBox(BoxConstraints(88.0(369160267)) I/flutter ( 6559): └GestureDetector() I/flutter ( 6559): └RawGestureDetector(state: RawGestureDetectorState(175370983; gestures: tap; behavior: opaque)) I/flutter ( 6559): └_GestureSemantics(renderObject: RenderSemanticsGestureHandler relayoutBoundary=up2) I/flutter ( 6559): └Listener(listeners: down; behavior: opaque; renderObject: RenderPointerListener relayoutBoundary=up3) I/flutter ( 6559): └Container(padding: EdgeInsets(16.0, 0.0, 16.0, 0.0)) I/flutter ( 6559): └Padding(renderObject: RenderPadding relayoutBoundary=up4) I/flutter ( 6559): └Center(alignment: Alignment.center; widthFactor: 1.0; renderObject: RenderPositionedBox relayoutBoundary=up5) I/flutter ( 6559): └Text(\"Dump App\") I/flutter ( 6559): └RichText(renderObject: RenderParagraph relayoutBoundary=up6) 这是一个“扁平化”的树，显示了通过各种构建函数投影的所有widget（如果你在widget树的根中调用toStringDeepwidget，这是你获得的树）。 你会看到很多在你的应用源代码中没有出现的widget，因为它们是被框架中widget的build()函数插入的。例如，InkFeature是Material widget的一个实现细节 。 当按钮从被按下变为被释放时debugDumpApp()被调用，FlatButton对象同时调用setState()，并将自己标记为\"dirty\"。 这就是为什么如果你看转储，你会看到特定的对象标记为“dirty”。您还可以查看已注册了哪些手势监听器; 在这种情况下，一个单一的GestureDetector被列出，并且监听“tap”手势（“tap”是TapGestureDetector的toStringShort函数输出的） 如果您编写自己的widget，则可以通过覆盖debugFillProperties()来添加信息。 将DiagnosticsProperty对象作为方法参数，并调用父类方法。 该函数是该toString方法用来填充小部件描述信息的。 渲染层 如果您尝试调试布局问题，那么Widgets层的树可能不够详细。在这种情况下，您可以通过调用debugDumpRenderTree()转储渲染树。 正如debugDumpApp()，除布局或绘制阶段外，您可以随时调用此函数。作为一般规则，从frame 回调 或事件处理器中调用它是最佳解决方案。 要调用debugDumpRenderTree()，您需要添加import'package:flutter/rendering.dart';到您的源文件。 上面这个小例子的输出结果如下所示： I/flutter ( 6559): RenderView I/flutter ( 6559): │ debug mode enabled - android I/flutter ( 6559): │ window size: Size(1080.0, 1794.0) (in physical pixels) I/flutter ( 6559): │ device pixel ratio: 2.625 (physical pixels per logical pixel) I/flutter ( 6559): │ configuration: Size(411.4, 683.4) at 2.625x (in logical pixels) I/flutter ( 6559): │ I/flutter ( 6559): └─child: RenderCustomPaint I/flutter ( 6559): │ creator: CustomPaint ← Banner ← CheckedModeBanner ← I/flutter ( 6559): │ WidgetsApp-[GlobalObjectKey _MaterialAppState(1009803148)] ← I/flutter ( 6559): │ Theme ← AnimatedTheme ← ScrollConfiguration ← MaterialApp ← I/flutter ( 6559): │ [root] I/flutter ( 6559): │ parentData: I/flutter ( 6559): │ constraints: BoxConstraints(w=411.4, h=683.4) I/flutter ( 6559): │ size: Size(411.4, 683.4) I/flutter ( 6559): │ I/flutter ( 6559): └─child: RenderPointerListener I/flutter ( 6559): │ creator: Listener ← Navigator-[GlobalObjectKey I/flutter ( 6559): │ _WidgetsAppState(552902158)] ← Title ← LocaleQuery ← MediaQuery I/flutter ( 6559): │ ← DefaultTextStyle ← CustomPaint ← Banner ← CheckedModeBanner ← I/flutter ( 6559): │ WidgetsApp-[GlobalObjectKey _MaterialAppState(1009803148)] ← I/flutter ( 6559): │ Theme ← AnimatedTheme ← ⋯ I/flutter ( 6559): │ parentData: I/flutter ( 6559): │ constraints: BoxConstraints(w=411.4, h=683.4) I/flutter ( 6559): │ size: Size(411.4, 683.4) I/flutter ( 6559): │ behavior: defer-to-child I/flutter ( 6559): │ listeners: down, up, cancel I/flutter ( 6559): │ I/flutter ( 6559): └─child: RenderAbsorbPointer I/flutter ( 6559): │ creator: AbsorbPointer ← Listener ← I/flutter ( 6559): │ Navigator-[GlobalObjectKey I/flutter ( 6559): │ _WidgetsAppState(552902158)] ← Title ← LocaleQuery ← MediaQuery I/flutter ( 6559): │ ← DefaultTextStyle ← CustomPaint ← Banner ← CheckedModeBanner ← I/flutter ( 6559): │ WidgetsApp-[GlobalObjectKey _MaterialAppState(1009803148)] ← I/flutter ( 6559): │ Theme ← ⋯ I/flutter ( 6559): │ parentData: I/flutter ( 6559): │ constraints: BoxConstraints(w=411.4, h=683.4) I/flutter ( 6559): │ size: Size(411.4, 683.4) I/flutter ( 6559): │ absorbing: false I/flutter ( 6559): │ I/flutter ( 6559): └─child: RenderSemanticsAnnotations I/flutter ( 6559): │ creator: Semantics ← Focus-[GlobalKey 489139594] ← AbsorbPointer I/flutter ( 6559): │ ← Listener ← Navigator-[GlobalObjectKey I/flutter ( 6559): │ _WidgetsAppState(552902158)] ← Title ← LocaleQuery ← MediaQuery I/flutter ( 6559): │ ← DefaultTextStyle ← CustomPaint ← Banner ← CheckedModeBanner ← I/flutter ( 6559): │ ⋯ I/flutter ( 6559): │ parentData: I/flutter ( 6559): │ constraints: BoxConstraints(w=411.4, h=683.4) I/flutter ( 6559): │ size: Size(411.4, 683.4) I/flutter ( 6559): │ I/flutter ( 6559): └─child: _RenderTheatre I/flutter ( 6559): │ creator: _Theatre ← Overlay-[GlobalKey 199833992] ← _FocusScope ← I/flutter ( 6559): │ Semantics ← Focus-[GlobalKey 489139594] ← AbsorbPointer ← I/flutter ( 6559): │ Listener ← Navigator-[GlobalObjectKey I/flutter ( 6559): │ _WidgetsAppState(552902158)] ← Title ← LocaleQuery ← MediaQuery I/flutter ( 6559): │ ← DefaultTextStyle ← ⋯ I/flutter ( 6559): │ parentData: I/flutter ( 6559): │ constraints: BoxConstraints(w=411.4, h=683.4) I/flutter ( 6559): │ size: Size(411.4, 683.4) I/flutter ( 6559): │ I/flutter ( 6559): ├─onstage: RenderStack I/flutter ( 6559): ╎ │ creator: Stack ← _Theatre ← Overlay-[GlobalKey 199833992] ← I/flutter ( 6559): ╎ │ _FocusScope ← Semantics ← Focus-[GlobalKey 489139594] ← I/flutter ( 6559): ╎ │ AbsorbPointer ← Listener ← I/flutter ( 6559): ╎ │ Navigator-[GlobalObjectKey I/flutter ( 6559): ╎ │ _WidgetsAppState(552902158)] ← Title ← LocaleQuery ← MediaQuery I/flutter ( 6559): ╎ │ ← ⋯ I/flutter ( 6559): ╎ │ parentData: not positioned; offset=Offset(0.0, 0.0) I/flutter ( 6559): ╎ │ constraints: BoxConstraints(w=411.4, h=683.4) I/flutter ( 6559): ╎ │ size: Size(411.4, 683.4) I/flutter ( 6559): ╎ │ I/flutter ( 6559): ╎ ├─child 1: RenderIgnorePointer I/flutter ( 6559): ╎ │ │ creator: IgnorePointer ← _OverlayEntry-[GlobalKey 612888877] ← I/flutter ( 6559): ╎ │ │ Stack ← _Theatre ← Overlay-[GlobalKey 199833992] ← _FocusScope I/flutter ( 6559): ╎ │ │ ← Semantics ← Focus-[GlobalKey 489139594] ← AbsorbPointer ← I/flutter ( 6559): ╎ │ │ Listener ← Navigator-[GlobalObjectKey I/flutter ( 6559): ╎ │ │ _WidgetsAppState(552902158)] ← Title ← ⋯ I/flutter ( 6559): ╎ │ │ parentData: not positioned; offset=Offset(0.0, 0.0) I/flutter ( 6559): ╎ │ │ constraints: BoxConstraints(w=411.4, h=683.4) I/flutter ( 6559): ╎ │ │ size: Size(411.4, 683.4) I/flutter ( 6559): ╎ │ │ ignoring: false I/flutter ( 6559): ╎ │ │ ignoringSemantics: implicitly false I/flutter ( 6559): ╎ │ │ I/flutter ( 6559): ╎ │ └─child: RenderSemanticsAnnotations I/flutter ( 6559): ╎ │ │ creator: Semantics ← ModalBarrier ← IgnorePointer ← I/flutter ( 6559): ╎ │ │ _OverlayEntry-[GlobalKey 612888877] ← Stack ← _Theatre ← I/flutter ( 6559): ╎ │ │ Overlay-[GlobalKey 199833992] ← _FocusScope ← Semantics ← I/flutter ( 6559): ╎ │ │ Focus-[GlobalKey 489139594] ← AbsorbPointer ← Listener ← ⋯ I/flutter ( 6559): ╎ │ │ parentData: I/flutter ( 6559): ╎ │ │ constraints: BoxConstraints(w=411.4, h=683.4) I/flutter ( 6559): ╎ │ │ size: Size(411.4, 683.4) I/flutter ( 6559): ╎ │ │ I/flutter ( 6559): ╎ │ └─child: RenderSemanticsGestureHandler I/flutter ( 6559): ╎ │ │ creator: _GestureSemantics ← RawGestureDetector ← GestureDetector I/flutter ( 6559): ╎ │ │ ← Semantics ← ModalBarrier ← IgnorePointer ← I/flutter ( 6559): ╎ │ │ _OverlayEntry-[GlobalKey 612888877] ← Stack ← _Theatre ← I/flutter ( 6559): ╎ │ │ Overlay-[GlobalKey 199833992] ← _FocusScope ← Semantics ← ⋯ I/flutter ( 6559): ╎ │ │ parentData: I/flutter ( 6559): ╎ │ │ constraints: BoxConstraints(w=411.4, h=683.4) I/flutter ( 6559): ╎ │ │ size: Size(411.4, 683.4) I/flutter ( 6559): ╎ │ │ I/flutter ( 6559): ╎ │ └─child: RenderPointerListener I/flutter ( 6559): ╎ │ │ creator: Listener ← _GestureSemantics ← RawGestureDetector ← I/flutter ( 6559): ╎ │ │ GestureDetector ← Semantics ← ModalBarrier ← IgnorePointer ← I/flutter ( 6559): ╎ │ │ _OverlayEntry-[GlobalKey 612888877] ← Stack ← _Theatre ← I/flutter ( 6559): ╎ │ │ Overlay-[GlobalKey 199833992] ← _FocusScope ← ⋯ I/flutter ( 6559): ╎ │ │ parentData: I/flutter ( 6559): ╎ │ │ constraints: BoxConstraints(w=411.4, h=683.4) I/flutter ( 6559): ╎ │ │ size: Size(411.4, 683.4) I/flutter ( 6559): ╎ │ │ behavior: opaque I/flutter ( 6559): ╎ │ │ listeners: down I/flutter ( 6559): ╎ │ │ I/flutter ( 6559): ╎ │ └─child: RenderConstrainedBox I/flutter ( 6559): ╎ │ creator: ConstrainedBox ← Listener ← _GestureSemantics ← I/flutter ( 6559): ╎ │ RawGestureDetector ← GestureDetector ← Semantics ← ModalBarrier I/flutter ( 6559): ╎ │ ← IgnorePointer ← _OverlayEntry-[GlobalKey 612888877] ← Stack ← I/flutter ( 6559): ╎ │ _Theatre ← Overlay-[GlobalKey 199833992] ← ⋯ I/flutter ( 6559): ╎ │ parentData: I/flutter ( 6559): ╎ │ constraints: BoxConstraints(w=411.4, h=683.4) I/flutter ( 6559): ╎ │ size: Size(411.4, 683.4) I/flutter ( 6559): ╎ │ additionalConstraints: BoxConstraints(biggest) I/flutter ( 6559): ╎ │ I/flutter ( 6559): ╎ └─child 2: RenderSemanticsAnnotations I/flutter ( 6559): ╎ │ creator: Semantics ← Focus-[GlobalObjectKey I/flutter ( 6559): ╎ │ MaterialPageRoute(875520219)] ← _ModalScope-[GlobalKey I/flutter ( 6559): ╎ │ 816151164] ← _OverlayEntry-[GlobalKey 727622716] ← Stack ← I/flutter ( 6559): ╎ │ _Theatre ← Overlay-[GlobalKey 199833992] ← _FocusScope ← I/flutter ( 6559): ╎ │ Semantics ← Focus-[GlobalKey 489139594] ← AbsorbPointer ← I/flutter ( 6559): ╎ │ Listener ← ⋯ I/flutter ( 6559): ╎ │ parentData: not positioned; offset=Offset(0.0, 0.0) I/flutter ( 6559): ╎ │ constraints: BoxConstraints(w=411.4, h=683.4) I/flutter ( 6559): ╎ │ size: Size(411.4, 683.4) I/flutter ( 6559): ╎ │ I/flutter ( 6559): ╎ └─child: RenderOffstage I/flutter ( 6559): ╎ │ creator: Offstage ← _FocusScope ← Semantics ← I/flutter ( 6559): ╎ │ Focus-[GlobalObjectKey MaterialPageRoute(875520219)] ← I/flutter ( 6559): ╎ │ _ModalScope-[GlobalKey 816151164] ← _OverlayEntry-[GlobalKey I/flutter ( 6559): ╎ │ 727622716] ← Stack ← _Theatre ← Overlay-[GlobalKey 199833992] ← I/flutter ( 6559): ╎ │ _FocusScope ← Semantics ← Focus-[GlobalKey 489139594] ← ⋯ I/flutter ( 6559): ╎ │ parentData: I/flutter ( 6559): ╎ │ constraints: BoxConstraints(w=411.4, h=683.4) I/flutter ( 6559): ╎ │ size: Size(411.4, 683.4) I/flutter ( 6559): ╎ │ offstage: false I/flutter ( 6559): ╎ │ I/flutter ( 6559): ╎ └─child: RenderIgnorePointer I/flutter ( 6559): ╎ │ creator: IgnorePointer ← Offstage ← _FocusScope ← Semantics ← I/flutter ( 6559): ╎ │ Focus-[GlobalObjectKey MaterialPageRoute(875520219)] ← I/flutter ( 6559): ╎ │ _ModalScope-[GlobalKey 816151164] ← _OverlayEntry-[GlobalKey I/flutter ( 6559): ╎ │ 727622716] ← Stack ← _Theatre ← Overlay-[GlobalKey 199833992] ← I/flutter ( 6559): ╎ │ _FocusScope ← Semantics ← ⋯ I/flutter ( 6559): ╎ │ parentData: I/flutter ( 6559): ╎ │ constraints: BoxConstraints(w=411.4, h=683.4) I/flutter ( 6559): ╎ │ size: Size(411.4, 683.4) I/flutter ( 6559): ╎ │ ignoring: false I/flutter ( 6559): ╎ │ ignoringSemantics: implicitly false I/flutter ( 6559): ╎ │ I/flutter ( 6559): ╎ └─child: RenderFractionalTranslation I/flutter ( 6559): ╎ │ creator: FractionalTranslation ← SlideTransition ← I/flutter ( 6559): ╎ │ _MountainViewPageTransition ← IgnorePointer ← Offstage ← I/flutter ( 6559): ╎ │ _FocusScope ← Semantics ← Focus-[GlobalObjectKey I/flutter ( 6559): ╎ │ MaterialPageRoute(875520219)] ← _ModalScope-[GlobalKey I/flutter ( 6559): ╎ │ 816151164] ← _OverlayEntry-[GlobalKey 727622716] ← Stack ← I/flutter ( 6559): ╎ │ _Theatre ← ⋯ I/flutter ( 6559): ╎ │ parentData: I/flutter ( 6559): ╎ │ constraints: BoxConstraints(w=411.4, h=683.4) I/flutter ( 6559): ╎ │ size: Size(411.4, 683.4) I/flutter ( 6559): ╎ │ translation: Offset(0.0, 0.0) I/flutter ( 6559): ╎ │ transformHitTests: true I/flutter ( 6559): ╎ │ I/flutter ( 6559): ╎ └─child: RenderRepaintBoundary I/flutter ( 6559): ╎ │ creator: RepaintBoundary ← FractionalTranslation ← I/flutter ( 6559): ╎ │ SlideTransition ← _MountainViewPageTransition ← IgnorePointer ← I/flutter ( 6559): ╎ │ Offstage ← _FocusScope ← Semantics ← Focus-[GlobalObjectKey I/flutter ( 6559): ╎ │ MaterialPageRoute(875520219)] ← _ModalScope-[GlobalKey I/flutter ( 6559): ╎ │ 816151164] ← _OverlayEntry-[GlobalKey 727622716] ← Stack ← ⋯ I/flutter ( 6559): ╎ │ parentData: I/flutter ( 6559): ╎ │ constraints: BoxConstraints(w=411.4, h=683.4) I/flutter ( 6559): ╎ │ size: Size(411.4, 683.4) I/flutter ( 6559): ╎ │ metrics: 83.3% useful (1 bad vs 5 good) I/flutter ( 6559): ╎ │ diagnosis: this is a useful repaint boundary and should be kept I/flutter ( 6559): ╎ │ I/flutter ( 6559): ╎ └─child: RenderDecoratedBox I/flutter ( 6559): ╎ │ creator: DecoratedBox ← Container ← AnimatedContainer ← Material I/flutter ( 6559): ╎ │ ← AppHome ← _ModalScopeStatus ← PageStorage-[GlobalKey I/flutter ( 6559): ╎ │ 619728754] ← RepaintBoundary ← FractionalTranslation ← I/flutter ( 6559): ╎ │ SlideTransition ← _MountainViewPageTransition ← IgnorePointer ← I/flutter ( 6559): ╎ │ ⋯ I/flutter ( 6559): ╎ │ parentData: I/flutter ( 6559): ╎ │ constraints: BoxConstraints(w=411.4, h=683.4) I/flutter ( 6559): ╎ │ size: Size(411.4, 683.4) I/flutter ( 6559): ╎ │ decoration: I/flutter ( 6559): ╎ │ I/flutter ( 6559): ╎ │ configuration: ImageConfiguration(bundle: I/flutter ( 6559): ╎ │ PlatformAssetBundle@367106502(), devicePixelRatio: 2.625, I/flutter ( 6559): ╎ │ platform: android) I/flutter ( 6559): ╎ │ I/flutter ( 6559): ╎ └─child: RenderDecoratedBox I/flutter ( 6559): ╎ │ creator: DecoratedBox ← Container ← DecoratedBox ← Container ← I/flutter ( 6559): ╎ │ AnimatedContainer ← Material ← AppHome ← _ModalScopeStatus ← I/flutter ( 6559): ╎ │ PageStorage-[GlobalKey 619728754] ← RepaintBoundary ← I/flutter ( 6559): ╎ │ FractionalTranslation ← SlideTransition ← ⋯ I/flutter ( 6559): ╎ │ parentData: I/flutter ( 6559): ╎ │ constraints: BoxConstraints(w=411.4, h=683.4) I/flutter ( 6559): ╎ │ size: Size(411.4, 683.4) I/flutter ( 6559): ╎ │ decoration: I/flutter ( 6559): ╎ │ backgroundColor: Color(0xfffafafa) I/flutter ( 6559): ╎ │ configuration: ImageConfiguration(bundle: I/flutter ( 6559): ╎ │ PlatformAssetBundle@367106502(), devicePixelRatio: 2.625, I/flutter ( 6559): ╎ │ platform: android) I/flutter ( 6559): ╎ │ I/flutter ( 6559): ╎ └─child: _RenderInkFeatures I/flutter ( 6559): ╎ │ creator: _InkFeature-[GlobalKey ink renderer] ← I/flutter ( 6559): ╎ │ NotificationListener ← DecoratedBox I/flutter ( 6559): ╎ │ ← Container ← DecoratedBox ← Container ← AnimatedContainer ← I/flutter ( 6559): ╎ │ Material ← AppHome ← _ModalScopeStatus ← PageStorage-[GlobalKey I/flutter ( 6559): ╎ │ 619728754] ← RepaintBoundary ← ⋯ I/flutter ( 6559): ╎ │ parentData: I/flutter ( 6559): ╎ │ constraints: BoxConstraints(w=411.4, h=683.4) I/flutter ( 6559): ╎ │ size: Size(411.4, 683.4) I/flutter ( 6559): ╎ │ I/flutter ( 6559): ╎ └─child: RenderPositionedBox I/flutter ( 6559): ╎ │ creator: Center ← DefaultTextStyle ← AnimatedDefaultTextStyle ← I/flutter ( 6559): ╎ │ _InkFeature-[GlobalKey ink renderer] ← I/flutter ( 6559): ╎ │ NotificationListener ← DecoratedBox I/flutter ( 6559): ╎ │ ← Container ← DecoratedBox ← Container ← AnimatedContainer ← I/flutter ( 6559): ╎ │ Material ← AppHome ← ⋯ I/flutter ( 6559): ╎ │ parentData: I/flutter ( 6559): ╎ │ constraints: BoxConstraints(w=411.4, h=683.4) I/flutter ( 6559): ╎ │ size: Size(411.4, 683.4) I/flutter ( 6559): ╎ │ alignment: Alignment.center I/flutter ( 6559): ╎ │ widthFactor: expand I/flutter ( 6559): ╎ │ heightFactor: expand I/flutter ( 6559): ╎ │ I/flutter ( 6559): ╎ └─child: RenderConstrainedBox relayoutBoundary=up1 I/flutter ( 6559): ╎ │ creator: ConstrainedBox ← MaterialButton ← FlatButton ← Center ← I/flutter ( 6559): ╎ │ DefaultTextStyle ← AnimatedDefaultTextStyle ← I/flutter ( 6559): ╎ │ _InkFeature-[GlobalKey ink renderer] ← I/flutter ( 6559): ╎ │ NotificationListener ← DecoratedBox I/flutter ( 6559): ╎ │ ← Container ← DecoratedBox ← Container ← ⋯ I/flutter ( 6559): ╎ │ parentData: offset=Offset(156.7, 323.7) I/flutter ( 6559): ╎ │ constraints: BoxConstraints(0.0 I/flutter ( 6559): ╎ │ constraints: BoxConstraints(88.0 I/flutter ( 6559): ╎ │ constraints: BoxConstraints(88.0 I/flutter ( 6559): ╎ │ constraints: BoxConstraints(88.0这是根RenderObject对象的toStringDeep函数的输出。 当调试布局问题时，关键要看的是size和constraints字段。约束沿着树向下传递，尺寸向上传递。 例如，在上面的转储中，您可以看到窗口大小，Size(411.4, 683.4)，它用于强制RenderPositionedBox下的所有渲染框到屏幕的大小， 约束条件为 BoxConstraints(w=411.4, h=683.4)。从RenderPositionedBox的转储中看到是由Center widget创建的（如creator字段所描述的）， 设置其孩子的约束为：BoxConstraints(0.0FlatButton定义的一部分，它在其内容上设置最小宽度为88像素，并且设置高度为36.0像素（这是Material Design设计规范中FlatButton类的尺寸标准）。 最内部RenderPositionedBox再次松开约束，这次是将按钮中的文本居中。 在RenderParagraph中基于它的内容来决定其大小。 如果您现在按照size链继续往下查看，您会看到文本的大小是如何影响其按钮的框的宽度的，它们都是根据孩子的尺寸自行调整大小。 另一种需要注意的是每个盒子描述的”relayoutSubtreeRoot”部分，它告诉你有多少祖先以某种方式依赖于这个元素的大小。 因此，RenderParagraph有一个relayoutSubtreeRoot=up8，这意味着当它RenderParagraph被标及为”dirty”时，它的八个祖先也必须被标记为”dirty”，因为它们可能受到新尺寸的影响。 如果您编写自己的渲染对象，则可以通过覆盖debugFillProperties()将信息添加到转储。 将DiagnosticsProperty对象作为方法的参数，并调用父类方法。 层 如果您尝试调试合成问题，则可以使用debugDumpLayerTree()。对于上面的例子，它会输出： I/flutter : TransformLayer I/flutter : │ creator: [root] I/flutter : │ offset: Offset(0.0, 0.0) I/flutter : │ transform: I/flutter : │ [0] 3.5,0.0,0.0,0.0 I/flutter : │ [1] 0.0,3.5,0.0,0.0 I/flutter : │ [2] 0.0,0.0,1.0,0.0 I/flutter : │ [3] 0.0,0.0,0.0,1.0 I/flutter : │ I/flutter : ├─child 1: OffsetLayer I/flutter : │ │ creator: RepaintBoundary ← _FocusScope ← Semantics ← Focus-[GlobalObjectKey MaterialPageRoute(560156430)] ← _ModalScope-[GlobalKey 328026813] ← _OverlayEntry-[GlobalKey 388965355] ← Stack ← Overlay-[GlobalKey 625702218] ← Navigator-[GlobalObjectKey _MaterialAppState(859106034)] ← Title ← ⋯ I/flutter : │ │ offset: Offset(0.0, 0.0) I/flutter : │ │ I/flutter : │ └─child 1: PictureLayer I/flutter : │ I/flutter : └─child 2: PictureLayer 这是根Layer的toStringDeep输出的。 根部的变换是应用设备像素比的变换; 在这种情况下，每个逻辑像素代表3.5个设备像素。 RepaintBoundary widget在渲染树的层中创建了一个RenderRepaintBoundary。这用于减少需要重绘的需求量。 语义 您还可以调用debugDumpSemanticsTree()获取语义树（呈现给系统可访问性API的树）的转储。 要使用此功能，必须首先启用辅助功能，例如启用系统辅助工具或SemanticsDebugger （下面讨论）。 对于上面的例子，它会输出: I/flutter : SemanticsNode(0; Rect.fromLTRB(0.0, 0.0, 411.4, 683.4)) I/flutter : ├SemanticsNode(1; Rect.fromLTRB(0.0, 0.0, 411.4, 683.4)) I/flutter : │ └SemanticsNode(2; Rect.fromLTRB(0.0, 0.0, 411.4, 683.4); canBeTapped) I/flutter : └SemanticsNode(3; Rect.fromLTRB(0.0, 0.0, 411.4, 683.4)) I/flutter : └SemanticsNode(4; Rect.fromLTRB(0.0, 0.0, 82.0, 36.0); canBeTapped; \"Dump App\") 调度 要找出相对于帧的开始/结束事件发生的位置，可以切换debugPrintBeginFrameBanner和debugPrintEndFrameBanner布尔值以将帧的开始和结束打印到控制台。 例如: I/flutter : ▄▄▄▄▄▄▄▄ Frame 12 30s 437.086ms ▄▄▄▄▄▄▄▄ I/flutter : Debug print: Am I performing this work more than once per frame? I/flutter : Debug print: Am I performing this work more than once per frame? I/flutter : ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ debugPrintScheduleFrameStacks还可以用来打印导致当前帧被调度的调用堆栈。 可视化调试 您也可以通过设置debugPaintSizeEnabled为true以可视方式调试布局问题。 这是来自rendering库的布尔值。它可以在任何时候启用，并在为true时影响绘制。 设置它的最简单方法是在void main()的顶部设置。 当它被启用时，所有的盒子都会得到一个明亮的深青色边框，padding（来自widget如Padding）显示为浅蓝色，子widget周围有一个深蓝色框， 对齐方式（来自widget如Center和Align）显示为黄色箭头. 空白（如没有任何子节点的Container）以灰色显示。 debugPaintBaselinesEnabled做了类似的事情，但对于具有基线的对象，文字基线以绿色显示，表意(ideographic)基线以橙色显示。 debugPaintPointersEnabled标志打开一个特殊模式，任何正在点击的对象都会以深青色突出显示。 这可以帮助您确定某个对象是否以某种不正确的方式进行hit测试（Flutter检测点击的位置是否有能响应用户操作的widget）,例如，如果它实际上超出了其父项的范围，首先不会考虑通过hit测试。 如果您尝试调试合成图层，例如以确定是否以及在何处添加RepaintBoundary widget，则可以使用debugPaintLayerBordersEnabled 标志， 该标志用橙色或轮廓线标出每个层的边界，或者使用debugRepaintRainbowEnabled标志， 只要他们重绘时，这会使该层被一组旋转色所覆盖。 所有这些标志只能在调试模式下工作。通常，Flutter框架中以“debug...” 开头的任何内容都只能在调试模式下工作。 调试动画 调试动画最简单的方法是减慢它们的速度。为此，请将timeDilation变量（在scheduler库中）设置为大于1.0的数字，例如50.0。 最好在应用程序启动时只设置一次。如果您在运行中更改它，尤其是在动画运行时将其值减小，则框架的观察时可能会倒退，这可能会导致断言并且通常会干扰您的工作。 调试性能问题 要了解您的应用程序导致重新布局或重新绘制的原因，您可以分别设置debugPrintMarkNeedsLayoutStacks和 debugPrintMarkNeedsPaintStacks标志。 每当渲染盒被要求重新布局和重新绘制时，这些都会将堆栈跟踪记录到控制台。如果这种方法对您有用，您可以使用services库中的debugPrintStack()方法按需打印堆栈痕迹。 衡量应用启动时间 要收集有关Flutter应用程序启动所需时间的详细信息，可以在运行flutter run时使用trace-startup和profile选项。 $ flutter run --trace-startup --profile 跟踪输出保存为start_up_info.json，在Flutter工程目录在build目录下。输出列出了从应用程序启动到这些跟踪事件（以微秒捕获）所用的时间： 进入Flutter引擎时. 展示应用第一帧时. 初始化Flutter框架时. 完成Flutter框架初始化时. 如 : { \"engineEnterTimestampMicros\": 96025565262, \"timeToFirstFrameMicros\": 2171978, \"timeToFrameworkInitMicros\": 514585, \"timeAfterFrameworkInitMicros\": 1657393 } 跟踪Dart代码性能 要执行自定义性能跟踪和测量Dart任意代码段的wall/CPU时间（类似于在Android上使用systrace）。 使用dart:developer的Timeline工具来包含你想测试的代码块，例如： Timeline.startSync('interesting function'); // iWonderHowLongThisTakes(); Timeline.finishSync(); 然后打开你应用程序的Observatory timeline页面，在”Recorded Streams”中选择’Dart’复选框，并执行你想测量的功能。 刷新页面将在Chrome的跟踪工具中显示应用按时间顺序排列的timeline记录。 请确保运行flutter run时带有--profile标志，以确保运行时性能特征与您的最终产品差异最小。 Performance Overlay 要获得应用程序性能图，请将MaterialApp构造函数的showPerformanceOverlay参数设置为true。 WidgetsApp构造函数也有类似的参数（如果你没有使用MaterialApp或者WidgetsApp，你可以通过将你的应用程序包装在一个stack中， 并将一个widget放在通过new PerformanceOverlay.allEnabled()创建的stack上来获得相同的效果）。 这将显示两个图表。第一个是GPU线程花费的时间，最后一个是CPU线程花费的时间。 图中的白线以16ms增量沿纵轴显示; 如果图中超过这三条线之一，那么您的运行频率低于60Hz。横轴代表帧。 该图仅在应用程序绘制时更新，因此如果它处于空闲状态，该图将停止移动。 这应该始终在发布模式（release mode）下测试，因为在调试模式下，故意牺牲性能来换取有助于开发调试的功能，如assert声明，这些都是非常耗时的，因此结果将会产生误导。 Material grid 在开发实现Material Design的应用程序时， 将Material Design基线网格覆盖在应用程序上可能有助于验证对齐。 为此，MaterialApp 构造函数 有一个debugShowMaterialGrid参数， 当在调试模式设置为true时，它将覆盖这样一个网格。 您也可以直接使用GridPaperwidget将这种网格覆盖在非Material应用程序上 。 "},"chapter2/thread_model_and_error_report.html":{"url":"chapter2/thread_model_and_error_report.html","title":"Dart线程模型及异常捕获","keywords":"","body":"Dart线程模型及异常捕获 Dart单线程模型 在Java和OC中，如果程序发生异常且没有被捕获，那么程序将会终止，但在Dart或JavaScript中则不会，究其原因，这和它们的运行机制有关系，Java和OC都是多线程模型的编程语言，任意一个线程触发异常且没被捕获时，整个进程就退出了。但Dart和JavaScript不同，它们都是单线程模型，运行机制很相似(但有区别)，下面我们通过Dart官方提供的一张图来看看dart大致运行原理： Dart 在单线程中是以消息循环机制来运行的，其中包含两个任务队列，一个是“微任务队列” microtask queue，另一个叫做“事件队列” event queue。从图中可以发现，微任务队列的执行优先级高于事件队列。 现在我们来介绍一下Dart线程运行过程，如上图中所示，入口函数 main() 执行完后，消息循环机制便启动了。首先会按照先进先出的顺序逐个执行微任务队列中的任务，当所有微任务队列执行完后便开始执行事件队列中的任务，事件任务执行完毕后再去执行微任务，如此循环往复，生生不息。 在Dart中，所有的外部事件任务都在事件队列中，如IO、计时器、点击、以及绘制事件等，而微任务通常来源于Dart内部，并且微任务非常少，之所以如此，是因为微任务队列优先级高，如果微任务太多，执行时间总和就越久，事件队列任务的延迟也就越久，对于GUI应用来说最直观的表现就是比较卡，所以必须得保证微任务队列不会太长。值得注意的是，我们可以通过Future.microtask(…)方法向微任务队列插入一个任务。 在事件循环中，当某个任务发生异常并没有被捕获时，程序并不会退出，而直接导致的结果是当前任务的后续代码就不会被执行了，也就是说一个任务中的异常是不会影响其它任务执行的。 Flutter异常捕获 Dart中可以通过try/catch/finally来捕获代码块异常，这个和其它编程语言类似，，如果读者不清楚，可以查看Dart语言文档，不在赘述，下面我们看看Flutter中的异常捕获。 Flutter框架异常捕获 Flutter 框架为我们在很多关键的方法进行了异常捕获。这里举一个例子，当我们布局发生越界或不合规范时，Flutter就会自动弹出一个错误界面，这是因为Flutter已经在执行build方法时添加了异常捕获，最终的源码如下： @override void performRebuild() { ... try { //执行build方法 built = build(); } catch (e, stack) { // 有异常时则弹出错误提示 built = ErrorWidget.builder(_debugReportException('building $this', e, stack)); } ... } 可以看到，在发生异常时，Flutter默认的处理方式是弹一个ErrorWidget，但如果我们想自己捕获异常并上报到报警平台的话应该怎么做？我们进入_debugReportException()方法看看： FlutterErrorDetails _debugReportException( String context, dynamic exception, StackTrace stack, { InformationCollector informationCollector }) { //构建错误详情对象 final FlutterErrorDetails details = FlutterErrorDetails( exception: exception, stack: stack, library: 'widgets library', context: context, informationCollector: informationCollector, ); //报告错误 FlutterError.reportError(details); return details; } 我们发现，错误是通过FlutterError.reportError方法上报的，继续跟踪： static void reportError(FlutterErrorDetails details) { ... if (onError != null) onError(details); //调用了onError回调 } 我们发现onError是FlutterError的一个静态属性，它有一个默认的处理方法 dumpErrorToConsole，到这里就清晰了，如果我们想自己上报异常，只需要提供一个自定义的错误处理回调即可，如： void main() { FlutterError.onError = (FlutterErrorDetails details) { reportError(details); }; ... } 这样我们就可以处理那些Flutter为我们捕获的异常了，接下来我们看看如何捕获其它异常。 其它异常捕获与日志收集 在Flutter中，还有一些Flutter没有为我们捕获的异常，如调用空对象方法异常、Future中的异常。在Dart中，异常分两类：同步异常和异步异常，同步异常可以通过try/catch捕获，而异步异常则比较麻烦，如下面的代码是捕获不了Future的异常的： try{ Future.delayed(Duration(seconds: 1)).then((e) => Future.error(\"xxx\")); }catch (e){ print(e) } Dart中有一个runZoned(...) 方法，可以给执行对象指定一个Zone。Zone表示一个代码执行的环境范围，为了方便理解，读者可以将Zone类比为一个代码执行沙箱，不同沙箱的之间是隔离的，沙箱可以捕获、拦截或修改一些代码行为，如Zone中可以捕获日志输出、Timer创建、微任务调度的行为，同时Zone也可以捕获所有未处理的异常。下面我们看看runZoned(...)方法定义： R runZoned(R body(), { Map zoneValues, ZoneSpecification zoneSpecification, Function onError, }) zoneValues: Zone 的私有数据，可以通过实例zone[key]获取，可以理解为每个“沙箱”的私有数据。 zoneSpecification：Zone的一些配置，可以自定义一些代码行为，比如拦截日志输出行为等，举个例子： 下面是拦截应用中所有调用print输出日志的行为。 main() { runZoned(() => runApp(MyApp()), zoneSpecification: new ZoneSpecification( print: (Zone self, ZoneDelegate parent, Zone zone, String line) { parent.print(zone, \"Intercepted: $line\"); }), ); } 这样一来，我们APP中所有调用print方法输出日志的行为都会被拦截，通过这种方式，我们也可以在应用中记录日志，等到应用触发未捕获的异常时，将异常信息和日志统一上报。ZoneSpecification还可以自定义一些其他行为，读者可以查看API文档。 onError：Zone中未捕获异常处理回调，如果开发者提供了onError回调或者通过ZoneSpecification.handleUncaughtError指定了错误处理回调，那么这个zone将会变成一个error-zone，该error-zone中发生未捕获异常(无论同步还是异步)时都会调用开发者提供的回调，如： runZoned(() { runApp(MyApp()); }, onError: (Object obj, StackTrace stack) { var details=makeDetails(obj,stack); reportError(details); }); 这样一来，结合上面的FlutterError.onError我们就可以捕获我们Flutter应用中全部错误了！需要注意的是，error-zone内部发生的错误是不会跨越当前error-zone的边界的，如果想跨越error-zone边界去捕获异常，可以通过共同的“源”zone来捕获，如： var future = new Future.value(499); runZoned(() { var future2 = future.then((_) { throw \"error in first error-zone\"; }); runZoned(() { var future3 = future2.catchError((e) { print(\"Never reached!\"); }); }, onError: (e) { print(\"unused error handler\"); }); }, onError: (e) { print(\"catches error of first error-zone.\"); }); 总结 我们最终的异常捕获和上报代码如下： void collectLog(String line){ ... //收集日志 } void reportErrorAndLog(FlutterErrorDetails details){ ... //上报错误和日志逻辑 } FlutterErrorDetails makeDetails(Object obj, StackTrace stack){ ...// 构建错误信息 } void main() { FlutterError.onError = (FlutterErrorDetails details) { reportErrorAndLog(details); }; runZoned( () => runApp(MyApp()), zoneSpecification: ZoneSpecification( print: (Zone self, ZoneDelegate parent, Zone zone, String line) { collectLog(line); //手机日志 }, ), onError: (Object obj, StackTrace stack) { var details = makeDetails(obj, stack); reportErrorAndLog(details); }, ); } "},"chapter3/":{"url":"chapter3/","title":"基础Widgets","keywords":"","body":"基础Widget 本节介绍一下Flutter中常用的一些基础widget，由于大多数widget的属性都比较多，我们在介绍widget时会着重介绍常用的属性，而不会像API文档一样所有属性都介绍，关于属性详细的信息请参考Flutter SDK文档。 本章目录 Widget简介 文本、字体样式 按钮 图片和Icon 单选框和复选框 输入框和表单 "},"chapter3/flutter_widget_intro.html":{"url":"chapter3/flutter_widget_intro.html","title":"Widget简介","keywords":"","body":"Widget简介 概念 在前面的介绍中，我们知道Flutter中几乎所有的对象都是一个Widget，与原生开发中“控件”不同的是，Flutter中的widget的概念更广泛，它不仅可以表示UI元素，也可以表示一些功能性的组件如：用于手势检测的 GestureDetector widget、用于应用主题数据传递的Theme等等。而原生开发中的控件通常只是指UI元素。在后面的内容中，我们在描述UI元素时，我们可能会用到“控件”、“组件”这样的概念，读者心里需要知道他们就是widget，只是在不同场景的不同表述而已。由于Flutter主要就是用于构建用户界面的，所以，在大多数时候，读者可以认为widget就是一个控件，不必纠结于概念。 Widget与Element 在Flutter中，Widget的功能是“描述一个UI元素的配置数据”，它就是说，Widget其实并不是表示最终绘制在设备屏幕上的显示元素，而只是显示元素的一个配置数据。实际上，Flutter中真正代表屏幕上显示元素的类是Element，也就是说Widget只是描述Element的一个配置，有关Element的详细介绍我们将在本书后面的高级部分深入介绍，读者现在只需要知道，Widget只是UI元素的一个配置数据，并且一个Widget可以对应多个Element，这是因为同一个Widget对象可以被添加到UI树的不同部分，而真正渲染时，UI树的每一个Widget节点都会对应一个Element对象。总结一下： Widget实际上就是Element的配置数据，Widget树实际上是一个配置树，而真正的UI渲染树是由Element构成；不过，由于Element是通过Widget生成，所以它们之间有对应关系，所以在大多数场景，我们可以宽泛地认为Widget树就是指UI控件树或UI渲染树。 一个Widget对象可以对应多个Element对象。这很好理解，根据同一份配置（Widget），可以创建多个实例（Element）。 读者应该将这两点牢记在心中。 主要接口 我们先来看一下Widget类的声明： @immutable abstract class Widget extends DiagnosticableTree { const Widget({ this.key }); final Key key; @protected Element createElement(); @override String toStringShort() { return key == null ? '$runtimeType' : '$runtimeType-$key'; } @override void debugFillProperties(DiagnosticPropertiesBuilder properties) { super.debugFillProperties(properties); properties.defaultDiagnosticsTreeStyle = DiagnosticsTreeStyle.dense; } static bool canUpdate(Widget oldWidget, Widget newWidget) { return oldWidget.runtimeType == newWidget.runtimeType && oldWidget.key == newWidget.key; } } Widget类继承自DiagnosticableTree，DiagnosticableTree即“诊断树”，主要作用是提供调试信息。 Key: 这个key属性类似于React/Vue中的key，主要的作用是决定是否在下一次build时复用旧的widget，决定的条件在canUpdate()方法中。 createElement()：正如前文所述“一个Widget可以对应多个Element”；Flutter Framework在构建UI树时，会先调用此方法生成对应节点的Element对象。此方法是Flutter Framework隐式调用的，在我们开发过程中基本不会调用到。 debugFillProperties(...) 复写父类的方法，主要是设置诊断树的一些特性。 canUpdate(...)是一个静态方法，它主要用于在Widget树重新build时复用旧的widget，其实具体来说，应该是：是否用新的Widget对象去更新旧UI树上所对应的Element对象的配置；通过其源码我们可以看到，只要newWidget与oldWidget的runtimeType和key同时相等时就会用newWidget去更新Element对象的配置，否则就会创建新的Element。 有关Key和Widget复用的细节将会在本书后面高级部分深入讨论，读者现在只需知道，为Widget显式添加key的话可能（但不一定）会使UI在重新构建时变的高效，读者目前可以先忽略此参数。本书后面的示例中，我们只在构建列表项UI时会显式指定Key。 另外Widget类本身是一个抽象类，其中最核心的就是定义了createElement()接口，在Flutter开发中，我们一般都不用直接继承Widget类来实现Widget，相反，我们通常会通过继承StatelessWidget和StatefulWidget来间接继承Widget类来实现，而StatelessWidget和StatefulWidget都是直接继承自Widget类，而这两个类也正是Flutter中非常重要的两个抽象类，它们引入了两种Widget模型，接下来我们将重点介绍一下这两个类。 Stateless Widget 在之前的章节中，我们已经简单介绍过StatelessWidget，StatelessWidget相对比较简单，它继承自Widget，重写了createElement()方法： @override StatelessElement createElement() => new StatelessElement(this); StatelessElement 间接继承自Element类，与StatelessWidget相对应（作为其配置数据）。 StatelessWidget用于不需要维护状态的场景，它通常在build方法中通过嵌套其它Widget来构建UI，在构建过程中会递归的构建其嵌套的Widget。我们看一个简单的例子： class Echo extends StatelessWidget { const Echo({ Key key, @required this.text, this.backgroundColor:Colors.grey, }):super(key:key); final String text; final Color backgroundColor; @override Widget build(BuildContext context) { return Center( child: Container( color: backgroundColor, child: Text(text), ), ); } } 上面的代码，实现了一个回显字符串的Echo widget。 按照惯例，widget的构造函数应使用命名参数，命名参数中的必要参数要添加@required标注，这样有利于静态代码分析器进行检查，另外，在继承widget时，第一个参数通常应该是Key，如果接受子widget的child参数，那么通常应该将它放在参数列表的最后。同样是按照惯例，widget的属性应被声明为final，防止被意外改变。 然后我们可以通过如下方式使用它： Widget build(BuildContext context) { return Echo(text: \"hello world\"); } Stateful Widget 和StatelessWidget一样，StatefulWidget也是继承自widget类，并重写了createElement()方法，不同的是返回的Element 对象并不相同；另外StatefulWidget类中添加了一个新的接口createState()，下面我们看看StatefulWidget的类定义： abstract class StatefulWidget extends Widget { const StatefulWidget({ Key key }) : super(key: key); @override StatefulElement createElement() => new StatefulElement(this); @protected State createState(); } StatefulElement 间接继承自Element类，与StatefulWidget相对应（作为其配置数据）。StatefulElement中可能会多次调用createState()来创建状态(State)对象。 createState() 用于创建和Stateful widget相关的状态，它在Stateful widget的生命周期中可能会被多次调用。例如，当一个Stateful widget同时插入到widget树的多个位置时，Flutter framework就会调用该方法为每一个位置生成一个独立的State实例，其实，本质上就是一个StatefulElement对应一个State实例。 在本书中经常会出现“树“的概念，在不同的场景可能指不同的意思，在说“widget树”时它可以指widget结构树，但由于widget与Element有对应关系（一可能对多），在有些场景（Flutter的SDK文档中）也代指“UI树”的意思。而在stateful widget中，State对象也和StatefulElement具有对应关系（一对一），所以在Flutter的SDK文档中，可以经常看到“从树中移除State对象”或“插入State对象到树中”这样的描述。其实，无论哪种描述，其意思都是在描述“一棵构成用户界面的节点元素的树”，读者不必纠结于这些概念，还是那句话“得其神，忘其形”，因此，本书中出现的各种“树”，如果没有特别说明，读者都可抽象的认为它是“一棵构成用户界面的节点元素的树”。 State 一个StatefulWidget类会对应一个State类，State表示与其对应的StatefulWidget要维护的状态，State中的保存的状态信息可以： 在widget build时可以被同步读取。 在widget生命周期中可以被改变，当State被改变时，可以手动调用其setState()方法通知Flutter framework状态发生改变，Flutter framework在收到消息后，会重新调用其build方法重新构建widget树，从而达到更新UI的目的。 State中有两个常用属性： widget，它表示与该State实例关联的widget实例，由Flutter framework动态设置。注意，这种关联并非永久的，因为在应用声明周期中，UI树上的某一个节点的widget实例在重新构建时可能会变化，但State实例只会在第一次插入到树中时被创建，当在重新构建时，如果widget被修改了，Flutter framework会动态设置State.widget为新的widget实例。 context，它是BuildContext类的一个实例，表示构建widget的上下文，它是操作widget在树中位置的一个句柄，它包含了一些查找、遍历当前Widget树的一些方法。每一个widget都有一个自己的context对象。 对于BuildContext读者现在可以先作了解，随着本书后面内容的展开，也会用到Context的一些方法，读者可以通过具体的场景对其有个直观的认识。关于BuildContext更多的内容，我们也将在后面高级部分再深入介绍。 State生命周期 理解State的生命周期对flutter开发非常重要，为了加深读者印象，本节我们通过一个实例来演示一下State的生命周期。在接下来的示例中，我们实现一个计数器widget，点击它可以使计数器加1，由于要保存计数器的数值状态，所以我们应继承StatefulWidget，代码如下： class CounterWidget extends StatefulWidget { const CounterWidget({ Key key, this.initValue: 0 }); final int initValue; @override _CounterWidgetState createState() => new _CounterWidgetState(); } CounterWidget接收一个initValue整形参数，它表示计数器的初始值。下面我们看一下State的代码： class _CounterWidgetState extends State { int _counter; @override void initState() { super.initState(); //初始化状态 _counter=widget.initValue; print(\"initState\"); } @override Widget build(BuildContext context) { print(\"build\"); return Center( child: FlatButton( child: Text('$_counter'), //点击后计数器自增 onPressed:()=>setState(()=> ++_counter) , ), ); } @override void didUpdateWidget(CounterWidget oldWidget) { super.didUpdateWidget(oldWidget); print(\"didUpdateWidget\"); } @override void deactivate() { super.deactivate(); print(\"deactive\"); } @override void dispose() { super.dispose(); print(\"dispose\"); } @override void reassemble() { super.reassemble(); print(\"reassemble\"); } @override void didChangeDependencies() { super.didChangeDependencies(); print(\"didChangeDependencies\"); } } 接下来，我们创建一个新路由，在新路由中，我们只显示一个CounterWidget： Widget build(BuildContext context) { return CounterWidget(); } 我们运行应用并打开该路由页面，在新路由页打开后，屏幕中央就会出现一个数字0，然后控制台日志输出： I/flutter ( 5436): initState I/flutter ( 5436): didChangeDependencies I/flutter ( 5436): build 可以看到，在StatefulWidget插入到Widget树时首先initState方法会被调用。 然后我们点击⚡️按钮热重载，控制台输出日志如下： I/flutter ( 5436): reassemble I/flutter ( 5436): didUpdateWidget I/flutter ( 5436): build 可以看到此时initState 和didChangeDependencies都没有被调用，而此时didUpdateWidget被调用。 接下来，我们在widget树中移除CounterWidget，将路由build方法改为： Widget build(BuildContext context) { //移除计数器 //return CounterWidget(); //随便返回一个Text() return Text(\"xxx\"); } 然后热重载，日志如下： I/flutter ( 5436): reassemble I/flutter ( 5436): deactive I/flutter ( 5436): dispose 我们可以看到，在CounterWidget从widget树中移除时，deactive和dispose会依次被调用。 下面我们来看看各个回调函数： initState：当Widget第一次插入到Widget树时会被调用，对于每一个State对象，Flutter framework只会调用一次该回调，所以，通常在该回调中做一些一次性的操作，如状态初始化、订阅子树的事件通知等。不能在该回调中调用BuildContext.inheritFromWidgetOfExactType（该方法用于在Widget树上获取离当前widget最近的一个父级InheritFromWidget，关于InheritedWidget我们将在后面章节介绍），原因是在初始化完成后，Widget树中的InheritFromWidget也可能会发生变化，所以正确的做法应该在在build（）方法或didChangeDependencies()中调用它。 didChangeDependencies()：当State对象的依赖发生变化时会被调用；例如：在之前build() 中包含了一个InheritedWidget，然后在之后的build() 中InheritedWidget发生了变化，那么此时InheritedWidget的子widget的didChangeDependencies()回调都会被调用。典型的场景是当系统语言Locale或应用主题改变时，Flutter framework会通知widget调用此回调。 build()：此回调读者现在应该已经相当熟悉了，它主要是用于构建Widget子树的，会在如下场景被调用： 在调用initState()之后。 在调用didUpdateWidget()之后。 在调用setState()之后。 在调用didChangeDependencies()之后。 在State对象从树中一个位置移除后（会调用deactivate）又重新插入到树的其它位置之后。 reassemble()：此回调是专门为了开发调试而提供的，在热重载(hot reload)时会被调用，此回调在Release模式下永远不会被调用。 didUpdateWidget()：在widget重新构建时，Flutter framework会调用Widget.canUpdate来检测Widget树中同一位置的新旧节点，然后决定是否需要更新，如果Widget.canUpdate返回true则会调用此回调。正如之前所述，Widget.canUpdate会在新旧widget的key和runtimeType同时相等时会返回true，也就是说在在新旧widget的key和runtimeType同时相等时didUpdateWidget()就会被调用。 deactivate()：当State对象从树中被移除时，会调用此回调。在一些场景下，Flutter framework会将State对象重新插到树中，如包含此State对象的子树在树的一个位置移动到另一个位置时（可以通过GlobalKey来实现）。如果移除后没有重新插入到树中则紧接着会调用dispose()方法。 dispose()：当State对象从树中被永久移除时调用；通常在此回调中释放资源。 todo: 这里缺一张生命周期图 注意：在继承StatefulWidget重写其方法时，对于包含@mustCallSuper标注的父类方法，都要在子类方法中先调用父类方法。 状态管理 响应式的编程框架中都会有一个永恒的主题——“状态管理”，无论是在React/Vue（两者都是支持响应式编程的web开发框架）还是Flutter，他们讨论的问题和解决的思想都是一致的。所以，如果你对React/Vue的状态管理有了解，可以跳过本节。言归正传，我们想一个问题，stateful widget的状态应该被谁管理？widget本身？父widget？都会？还是另一个对象？答案是取决于实际情况！以下是管理状态的最常见的方法： Widget管理自己的state。 父widget管理子widget状态。 混合管理（父widget和子widget都管理状态）。 如何决定使用哪种管理方法？以下原则可以帮助你决定： 如果状态是用户数据，如复选框的选中状态、滑块的位置，则该状态最好由父widget管理。 如果状态是有关界面外观效果的，例如颜色、动画，那么状态最好由widget本身来管理。 如果某一个状态是不同widget共享的则最好由它们共同的父widget管理。 在widget内部管理状态封装性会好一些，而在父widget中管理会比较灵活。有些时候，如果不确定到底该怎么管理状态，那么推荐的首选是在父widget中管理（灵活会显得更重要一些）。 接下来，我们将通过创建三个简单示例TapboxA、TapboxB和TapboxC来说明管理状态的不同方式。 这些例子功能是相似的 ——创建一个盒子，当点击它时，盒子背景会在绿色与灰色之间切换。状态 _active确定颜色：绿色为true ，灰色为false。 下面的例子将使用GestureDetector来识别点击事件，关于该GestureDetector的详细内容我们将在后面“事件处理”一章中介绍。 Widget管理自身状态 _TapboxAState 类: 管理TapboxA的状态。 定义_active：确定盒子的当前颜色的布尔值。 定义_handleTap()函数，该函数在点击该盒子时更新_active，并调用setState()更新UI。 实现widget的所有交互式行为。 // TapboxA 管理自身状态. //------------------------- TapboxA ---------------------------------- class TapboxA extends StatefulWidget { TapboxA({Key key}) : super(key: key); @override _TapboxAState createState() => new _TapboxAState(); } class _TapboxAState extends State { bool _active = false; void _handleTap() { setState(() { _active = !_active; }); } Widget build(BuildContext context) { return new GestureDetector( onTap: _handleTap, child: new Container( child: new Center( child: new Text( _active ? 'Active' : 'Inactive', style: new TextStyle(fontSize: 32.0, color: Colors.white), ), ), width: 200.0, height: 200.0, decoration: new BoxDecoration( color: _active ? Colors.lightGreen[700] : Colors.grey[600], ), ), ); } } 父widget管理子widget的state 对于父widget来说，管理状态并告诉其子widget何时更新通常是比较好的方式。 例如，IconButton是一个图片按钮，但它是一个无状态的widget，因为我们认为父widget需要知道该按钮是否被点击来采取相应的处理。 在以下示例中，TapboxB通过回调将其状态导出到其父项。由于TapboxB不管理任何状态，因此它的父类为StatelessWidget。 ParentWidgetState 类: 为TapboxB 管理_active状态. 实现_handleTapboxChanged()，当盒子被点击时调用的方法. 当状态改变时，调用setState()更新UI. TapboxB 类: 继承StatelessWidget类，因为所有状态都由其父widget处理。 当检测到点击时，它会通知父widget。 // ParentWidget 为 TapboxB 管理状态. //------------------------ ParentWidget -------------------------------- class ParentWidget extends StatefulWidget { @override _ParentWidgetState createState() => new _ParentWidgetState(); } class _ParentWidgetState extends State { bool _active = false; void _handleTapboxChanged(bool newValue) { setState(() { _active = newValue; }); } @override Widget build(BuildContext context) { return new Container( child: new TapboxB( active: _active, onChanged: _handleTapboxChanged, ), ); } } //------------------------- TapboxB ---------------------------------- class TapboxB extends StatelessWidget { TapboxB({Key key, this.active: false, @required this.onChanged}) : super(key: key); final bool active; final ValueChanged onChanged; void _handleTap() { onChanged(!active); } Widget build(BuildContext context) { return new GestureDetector( onTap: _handleTap, child: new Container( child: new Center( child: new Text( active ? 'Active' : 'Inactive', style: new TextStyle(fontSize: 32.0, color: Colors.white), ), ), width: 200.0, height: 200.0, decoration: new BoxDecoration( color: active ? Colors.lightGreen[700] : Colors.grey[600], ), ), ); } } 混合管理 对于一些widget来说，混合管理的方式非常有用。在这种情况下，widget自身管理一些内部状态，而父widget管理一些其他外部状态。 在下面TapboxC示例中，按下时，盒子的周围会出现一个深绿色的边框。抬起时，边框消失；点击生效，盒子的颜色改变。 TapboxC将其_active状态导出到其父widget中，但在内部管理其_highlight状态。这个例子有两个状态对象_ParentWidgetState和_TapboxCState。 _ParentWidgetStateC 对象: 管理_active 状态。 实现 _handleTapboxChanged() ，当盒子被点击时调用。 当点击盒子并且_active状态改变时调用setState()更新UI。 _TapboxCState 对象: 管理_highlight state。 GestureDetector监听所有tap事件。当用户点下时，它添加高亮（深绿色边框）；当用户释放时，会移除高亮。 当按下、抬起、或者取消点击时更新_highlight状态，调用setState()更新UI。 当点击时，将状态的改变传递给父widget. //---------------------------- ParentWidget ---------------------------- class ParentWidgetC extends StatefulWidget { @override _ParentWidgetCState createState() => new _ParentWidgetCState(); } class _ParentWidgetCState extends State { bool _active = false; void _handleTapboxChanged(bool newValue) { setState(() { _active = newValue; }); } @override Widget build(BuildContext context) { return new Container( child: new TapboxC( active: _active, onChanged: _handleTapboxChanged, ), ); } } //----------------------------- TapboxC ------------------------------ class TapboxC extends StatefulWidget { TapboxC({Key key, this.active: false, @required this.onChanged}) : super(key: key); final bool active; final ValueChanged onChanged; _TapboxCState createState() => new _TapboxCState(); } class _TapboxCState extends State { bool _highlight = false; void _handleTapDown(TapDownDetails details) { setState(() { _highlight = true; }); } void _handleTapUp(TapUpDetails details) { setState(() { _highlight = false; }); } void _handleTapCancel() { setState(() { _highlight = false; }); } void _handleTap() { widget.onChanged(!widget.active); } Widget build(BuildContext context) { // 在按下时添加绿色边框，当抬起时，取消高亮 return new GestureDetector( onTapDown: _handleTapDown, // 处理按下事件 onTapUp: _handleTapUp, // 处理抬起事件 onTap: _handleTap, onTapCancel: _handleTapCancel, child: new Container( child: new Center( child: new Text(widget.active ? 'Active' : 'Inactive', style: new TextStyle(fontSize: 32.0, color: Colors.white)), ), width: 200.0, height: 200.0, decoration: new BoxDecoration( color: widget.active ? Colors.lightGreen[700] : Colors.grey[600], border: _highlight ? new Border.all( color: Colors.teal[700], width: 10.0, ) : null, ), ), ); } } 另一种实现可能会将高亮状态导出到父widget，同时保持_active状态为内部，但如果你要将该TapBox给其它人使用，可能没有什么意义。 开发人员只会关心该框是否处于Active状态，而不在乎高亮显示是如何管理的，所以应该让TapBox内部处理这些细节。 全局状态管理 当应用中包括一些跨widget（甚至跨路由）的状态需要同步时，上面介绍的方法很难胜任了。比如，我们有一个设置页，里面可以设置应用语言，但是我们为了让设置实时生效，我们期望在语言状态发生改变时，我们的APP Widget能够重新build一下，但我们的APP Widget和设置页并不在一起。正确的做法是通过一个全局状态管理器来处理这种“相距较远”的widget之间的通信。目前主要有两种办法： 实现一个全局的事件总线，将语言状态改变对应为一个事件，然后在APP Widget所在的父widgetinitState 方法中订阅语言改变的事件，当用户在设置页切换语言后，我们触发语言改变事件，然后APP Widget那边就会收到通知，然后重新build一下即可。 使用redux这样的全局状态包，读者可以在pub上查看其详细信息。 本书后面事件处理一章中会实现一个全局事件总线。 Flutter widget库介绍 Flutter提供了一套丰富、强大的基础widget，在基础widget库之上Flutter又提供了一套Material风格（Android默认的视觉风格）和一套Cupertino风格（iOS视觉风格）的widget库。要使用基础widget库，需要先导入： import 'package:flutter/widgets.dart'; 下面我们介绍一下常用的widget。 基础widget Text：该 widget 可让您创建一个带格式的文本。 Row、 Column： 这些具有弹性空间的布局类Widget可让您在水平（Row）和垂直（Column）方向上创建灵活的布局。其设计是基于web开发中的Flexbox布局模型。 Stack： 取代线性布局 (译者语：和Android中的FrameLayout相似)，Stack允许子 widget 堆叠， 你可以使用 Positioned 来定位他们相对于Stack的上下左右四条边的位置。Stacks是基于Web开发中的绝对定位（absolute positioning )布局模型设计的。 Container： Container 可让您创建矩形视觉元素。container 可以装饰一个BoxDecoration, 如 background、一个边框、或者一个阴影。 Container 也可以具有边距（margins）、填充(padding)和应用于其大小的约束(constraints)。另外， Container可以使用矩阵在三维空间中对其进行变换。 Material widget Flutter提供了一套丰富的Material widget，可帮助您构建遵循Material Design的应用程序。Material应用程序以MaterialApp widget开始， 该widget在应用程序的根部创建了一些有用的widget，比如一个Theme，它配置了应用的主题。 是否使用MaterialApp完全是可选的，但是使用它是一个很好的做法。在之前的示例中，我们已经使用过多个Material widget了，如：Scaffold、AppBar、FlatButton等。要使用Material widget，需要先引入它： import 'package:flutter/material.dart'; Cupertino widget Flutter也提供了一套丰富的Cupertino风格的widget，尽管目前还没有Material widget那么丰富，但也在不断的完善中。值得一提的是在Material widget库中，有一些widget可以根据实际运行平台来切换表现风格，比如MaterialPageRoute，在路由切换时，如果是Android系统，它将会使用Android系统默认的页面切换动画(从底向上)，如果是iOS系统时，它会使用iOS系统默认的页面切换动画（从右向左）。由于在前面的示例中还没有Cupertino widget的示例，我们实现一个简单的Cupertino页面： //导入cupertino widget库 import 'package:flutter/cupertino.dart'; class CupertinoTestRoute extends StatelessWidget { @override Widget build(BuildContext context) { return CupertinoPageScaffold( navigationBar: CupertinoNavigationBar( middle: Text(\"Cupertino Demo\"), ), child: Center( child: CupertinoButton( color: CupertinoColors.activeBlue, child: Text(\"Press\"), onPressed: () {} ), ), ); } } 下面是在iPhoneX上页面效果截图： 总结 Flutter提供了丰富的widget，在实际的开发中你可以随意使用它们，不要怕引入过多widget库会让你的应用安装包变大，这不是web开发，dart在编译时只会编译你使用了的代码。由于Material和Cupertino都是在基础widget库之上的，所以如果你的应用中引入了这两者之一，则不需要再引入flutter/widgets.dart了，因为它们内部已经引入过了。 "},"chapter3/text.html":{"url":"chapter3/text.html","title":"文本、字体样式","keywords":"","body":"文本及样式 Text Text用于显示简单样式文本，它包含一些控制文本显示样式的一些属性，一个简单的例子如下： Text(\"Hello world\", textAlign: TextAlign.center, ); Text(\"Hello world! I'm Jack. \"*4, maxLines: 1, overflow: TextOverflow.ellipsis, ); Text(\"Hello world\", textScaleFactor: 1.5, ); 运行效果如下： textAlign：文本的对齐方式；可以选择左对齐、右对齐还是居中。注意，对齐的参考系是Text widget本身。本例中虽然是指定了居中对齐，但因为Text文本内容宽度不足一行，Text的宽度和文本内容长度相等，那么这时指定对齐方式是没有意义的，只有Text宽度大于文本内容长度时指定此属性才有意义。下面我们指定一个较长的字符串： Text(\"Hello world \"*6, //字符串重复六次 textAlign: TextAlign.center, )； 运行效果如下： ​ 字符串内容超过一行，Text宽度等于屏幕宽度，第二行文本便会居中显示。 maxLines、overflow：指定文本显示的最大行数，默认情况下，文本是自动折行的，如果指定此参数，则文本最多不会超过指定的行。如果有多余的文本，可以通过overflow来指定截断方式，默认是直接截断，本例中指定的截断方式TextOverflow.ellipsis，它会将多余文本截断后以省略符“...”表示；TextOverflow的其它截断方式请参考SDK文档。 textScaleFactor：代表文本相对于当前字体大小的缩放因子，相对于去设置文本的样式style属性的fontSize，它是调整字体大小的一个快捷方式。该属性的默认值可以通过MediaQueryData.textScaleFactor获得，如果没有MediaQuery，那么会默认值将为1.0。 TextStyle TextStyle用于指定文本显示的样式如颜色、字体、粗细、背景等。我们看一个示例： Text(\"Hello world\", style: TextStyle( color: Colors.blue, fontSize: 18.0, height: 1.2, fontFamily: \"Courier\", background: new Paint()..color=Colors.yellow, decoration:TextDecoration.underline, decorationStyle: TextDecorationStyle.dashed ), ); 效果如下： 此示例只展示了TextStyle的部分属性，它还有一些其它属性，属性名基本都是自解释的，在此不再赘述，读者可以查阅SDK文档。值得注意的是： height：该属性用于指定行高，但它并不是一个绝对值，而是一个因子，具体的行高等于fontSize*height。 fontFamily ：由于不同平台默认支持的字体集不同，所以在手动指定字体时一定要先在不同平台测试一下。 fontSize：该属性和Text的textScaleFactor都用于控制字体大小。但是有两给主要区别： fontSize可以精确指定字体大小，而textScaleFactor只能通过缩放比例来控制。 textScaleFactor主要是用于系统字体大小设置改变时对Flutter应用字体进行全局调整，而fontSize通常用于单个文本。 TextSpan 在上面的例子中，Text的所有文本内容只能按同一种样式，如果我们需要对一个Text内容的不同部分按照不同的样式显示，这时就可以使用TextSpan，它代表文本的一个“片段”。我们看看TextSpan的定义: const TextSpan({ TextStyle style, Sting text, List children, GestureRecognizer recognizer, }); 其中style 和 text属性代表该文本片段的样式和内容。 children是一个TextSpan的数组，也就是说TextSpan可以包括其他TextSpan。而recognizer用于对该文本片段上用于手势进行识别处理。下面我们看一个效果，然后用TextSpan实现它。 源码： Text.rich(TextSpan( children: [ TextSpan( text: \"Home: \" ), TextSpan( text: \"https://flutterchina.club\", style: TextStyle( color: Colors.blue ), recognizer: _tapRecognizer ), ] )) 上面代码中，我们通过TextSpan实现了一个基础文本片段和一个链接片段，然后通过Text.rich 方法将TextSpan 添加到Text中，之所以可以这样做，是因为Text其实就是RichText的一个包装，而RichText是可以显示多种样式(富文本)的widget。 _tapRecognizer，它是点击链接后的一个处理器（代码已省略），关于手势识别的更多内容我们将在后面单独介绍。 DefaultTextStyle 在widget树中，文本的样式默认是可以被继承的，因此，如果在widget树的某一个节点处设置一个默认的文本样式，那么该节点的子树中所有文本都会默认使用这个样式，而DefaultTextStyle正是用于设置默认文本样式的。下面我们看一个例子： DefaultTextStyle( //1.设置文本默认样式 style: TextStyle( color:Colors.red, fontSize: 20.0, ), textAlign: TextAlign.start, child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Text(\"hello world\"), Text(\"I am Jack\"), Text(\"I am Jack\", style: TextStyle( inherit: false, //2.不继承默认样式 color: Colors.grey ), ), ], ), ); 上面代码中，我们首先设置了一个默认的文本样式，即字体为20像素(逻辑像素)、颜色为红色。然后通过DefaultTextStyle 设置给了子树Column节点处，这样一来Column的所有子孙Text默认都会继承该样式，除非Text显示指定不继承样式，如代码中注释2。示例运行效果如下： 使用字体 可以在Flutter应用程序中使用不同的字体。例如，我们可能会使用设计人员创建的自定义字体，或者其它第三方的字体，如Google Fonts中的字体。本节将介绍如何为Flutter应用配置字体，并在渲染文本时使用它们。 在Flutter中使用字体分两步完成。首先在pubspec.yaml中声明它们，以确保它们会打包到应用程序中。然后通过TextStyle属性使用字体。 在asset中声明 要将字体打文件打包到应用中，和使用其它资源一样，要先在pubspec.yaml中声明它。然后将字体文件复制到在pubspec.yaml中指定的位置。如： flutter: fonts: - family: Raleway fonts: - asset: assets/fonts/Raleway-Regular.ttf - asset: assets/fonts/Raleway-Medium.ttf weight: 500 - asset: assets/fonts/Raleway-SemiBold.ttf weight: 600 - family: AbrilFatface fonts: - asset: assets/fonts/abrilfatface/AbrilFatface-Regular.ttf 使用字体 // 声明文本样式 const textStyle = const TextStyle( fontFamily: 'Raleway', ); // 使用文本样式 var buttonText = const Text( \"Use the font for this text\", style: textStyle, ); Package中的字体 要使用Package中定义的字体，必须提供package参数。例如，假设上面的字体声明位于my_package包中。然后创建TextStyle的过程如下： const textStyle = const TextStyle( fontFamily: 'Raleway', package: 'my_package', //指定包名 ); 如果在package包内部使用它自己定义的字体，也应该在创建文本样式时指定package参数，如上例所示。 一个包也可以只提供字体文件而不需要在pubspec.yaml中声明。 这些文件应该存放在包的lib/文件夹中。字体文件不会自动绑定到应用程序中，应用程序可以在声明字体时有选择地使用这些字体。假设一个名为my_package的包中有一个字体文件： lib/fonts/Raleway-Medium.ttf 然后，应用程序可以声明一个字体，如下面的示例所示： flutter: fonts: - family: Raleway fonts: - asset: assets/fonts/Raleway-Regular.ttf - asset: packages/my_package/fonts/Raleway-Medium.ttf weight: 500 lib/是隐含的，所以它不应该包含在asset路径中。 在这种情况下，由于应用程序本地定义了字体，所以在创建TextStyle时可以不指定package参数： const textStyle = const TextStyle( fontFamily: 'Raleway', ); "},"chapter3/buttons.html":{"url":"chapter3/buttons.html","title":"按钮","keywords":"","body":"按钮 Material widget库中提供了多种按钮Widget如RaisedButton、FlatButton、OutlineButton等，它们都是直接或间接对RawMaterialButton的包装定制，所以他们大多数属性都和RawMaterialButton一样。在介绍各个按钮时我们先介绍其默认外观，而按钮的外观大都可以通过属性来自定义，我们在后面统一介绍这些属性。另外，所有Material 库中的按钮都有如下相同点： 按下时都会有“水波动画”。 有一个onPressed属性来设置点击回调，当按钮按下时会执行该回调，如果不提供该回调则按钮会处于禁用状态，禁用状态不响应用户点击。 RaisedButton RaisedButton 即\"漂浮\"按钮，它默认带有阴影和灰色背景。按下后，阴影会变大，如： 使用RaisedButton非常简单，如： RaisedButton( child: Text(\"normal\"), onPressed: () => {}, ); FlatButton FlatButton即扁平按钮，默认背景透明并不带阴影。按下后，会有背景色： 使用FlatButton也很简单，代码如下： FlatButton( child: Text(\"normal\"), onPressed: () => {}, ) OutlineButton OutlineButton默认有一个边框，不带阴影且背景透明。按下后，边框颜色会变亮、同时出现背景和阴影(较弱)： 使用OutlineButton也很简单，代码如下： OutlineButton( child: Text(\"normal\"), onPressed: () => {}, ) IconButton IconButton是一个可点击的Icon，不包括文字，默认没有背景，点击后会出现背景： 使用代码如下： IconButton( icon: Icon(Icons.thumb_up), onPressed: () => {}, ) 自定义按钮外观 按钮外观可以通过其属性来定义，不同按钮属性大同小异，我们以FlatButton为例，介绍一下常见的按钮属性，详细的信息可以查看API文档。 const FlatButton({ ... @required this.onPressed, //按钮点击回调 this.textColor, //按钮文字颜色 this.disabledTextColor, //按钮禁用时的文字颜色 this.color, //按钮背景颜色 this.disabledColor,//按钮禁用时的背景颜色 this.highlightColor, //按钮按下时的背景颜色 this.splashColor, //点击时，水波动画中水波的颜色 this.colorBrightness,//按钮主题，默认是浅色主题 this.padding, //按钮的填充 this.shape, //外形 @required this.child, //按钮的内容 }) 其中大多数属性名都是自解释的，我们不赘述。下面我们通过一个示例来看看如何自定义按钮。 示例 定义一个背景蓝色，两边圆角的按钮。效果如下： 代码如下： FlatButton( color: Colors.blue, highlightColor: Colors.blue[700], colorBrightness: Brightness.dark, splashColor: Colors.grey, child: Text(\"Submit\"), shape:RoundedRectangleBorder(borderRadius: BorderRadius.circular(20.0)), onPressed: () => {}, ) 很简单吧，在上面的代码中，我们主要通过shape来指定其外形为一个圆角矩形。因为按钮背景是蓝色(深色)，我们需要指定按钮主题colorBrightness为Brightness.dark，这是为了保证按钮文字颜色为浅色。 细心的读者可能会发现这个按钮没有阴影(点击之后也没有)，这样会显得没有质感。其实这也很容易，将上面的FlatButton换成RaisedButton就行，其它代码不用改，换了之后我们看看效果： 是不是有质感了！之所以会这样，是因为RaisedButton默认有配置阴影： const RaisedButton({ ... this.elevation = 2.0, //正常状态下的阴影 this.highlightElevation = 8.0,//按下时的阴影 this.disabledElevation = 0.0,// 禁用时的阴影 ... } 值得注意的是，在Material widget库中，我们会在很多widget中见到elevation相关的属性，它们都是用来控制阴影的，这是因为阴影在Material设计风格中是一种很重要的表现形式，以后在介绍其它widget时，便不再赘述。 如果我们想实现一个背景渐变的圆角按钮，按钮有没有相应的属性呢？答案是否定的，但是，我们可以通过其它方式来实现，本文将在后面介绍Container时来介绍如何实现。 "},"chapter3/img_and_icon.html":{"url":"chapter3/img_and_icon.html","title":"图片和Icon","keywords":"","body":"图片及ICON 图片 Flutter中，我们可以通过Image来加载并显示图片，Image的数据源可以是asset、文件、内存以及网络。 ImageProvider ImageProvider 是一个抽象类，主要定义了图片数据获取的接口load()，从不同的数据源获取图片需要实现不同的ImageProvider ，如AssetImage是实现了从Asset中加载图片的ImageProvider，而NetworkImage实现了从网络加载图片的ImageProvider。 Image Image widget有一个必选的image参数，它对应一个ImageProvider。下面我们分别演示一下如何从asset和网络加载图片。 从asset中加载图片 在工程根目录下创建一个images目录，并将图片avatar.png拷贝到该目录。 在pubspec.yml中的flutter部分添加如下内容： assets: - images/avatar.png 加载该图片 Image( image: AssetImage(\"images/avatar.png\"), width: 100.0 ); Image也提供了一个快捷的构造函数Image.asset用于从asset中加载、显示图片： Image.asset(\"images/avatar.png\", width: 100.0, ) 从网络加载图片 Image( image: NetworkImage( \"https://avatars2.githubusercontent.com/u/20411648?s=460&v=4\"), width: 100.0, ) Image也提供了一个快捷的构造函数Image.network用于从网络加载、显示图片： Image.network( \"https://avatars2.githubusercontent.com/u/20411648?s=460&v=4\", width: 100.0, ) 运行上面两个示例，图片加载成功后显示如下： 参数 Image在显示图片时定义了一系列参数，通过这些参数我们可以控制图片的显示外观、大小、混合效果等。我们看一下Image的主要参数： const Image({ ... this.width, //图片的宽 this.height, //图片高度 this.color, //图片的混合色值 this.colorBlendMode, //混合模式 this.fit,//缩放模式 this.alignment = Alignment.center, //对齐方式 this.repeat = ImageRepeat.noRepeat, //重复方式 ... }) width、height：用于设置图片的宽、高，当不指定宽高时，图片会根据当前父容器的限制，尽可能的显示其原始大小，如果只设置width、height的其中一个，那么另一个属性默认会按比例缩放，但可以通过下面介绍的fit属性来指定适应规则。 fit：该属性用于在图片的显示空间和图片本身大小不同时指定图片的适应模式。适应模式是在BoxFit中定义，它是一个枚举类型，有如下值： fill：会拉伸填充满显示空间，图片本身长宽比会发生变化，图片会变形。 cover：会按图片的长宽比放大后居中填满显示空间，图片不会变形，超出显示空间部分会被剪裁。 contain：这是图片的默认适应规则，图片会在保证图片本身长宽比不变的情况下缩放以适应当前显示空间，图片不会变形。 fitWidth：图片的宽度会缩放到显示空间的宽度，高度会按比例缩放，然后居中显示，图片不会变形，超出显示空间部分会被剪裁。 fitHeight：图片的高度会缩放到显示空间的高度，宽度会按比例缩放，然后居中显示，图片不会变形，超出显示空间部分会被剪裁。 none：图片没有适应策略，会在显示空间内显示图片，如果图片比显示空间大，则显示空间只会显示图片中间部分。 一图胜万言： color和 colorBlendMode：在图片绘制时可以对每一个像素进行颜色混合处理，color指定混合色，而colorBlendMode指定混合模式，下面是一个简单的示例： Image( image: AssetImage(\"images/avatar.png\"), width: 100.0, color: Colors.blue, colorBlendMode: BlendMode.difference, ); 运行效果如下（彩色）: repeat：当图片本身大小小于显示空间时，指定图片的重复规则。简单示例如下： Image( image: AssetImage(\"images/avatar.png\"), width: 100.0, height: 200.0, repeat: ImageRepeat.repeatY , ) 运行后效果如下： ICON Flutter中，可以像web开发一样使用iconfont，iconfont即“字体图标”，它是将图标做成字体文件，然后通过指定不同的字符而显示不同的图片。 在字体文件中，每一个字符都对应一个位码，而每一个位码对应一个显示字形，不同的字体就是指字形不同，即字符对应的字形是不同的。而在iconfont中，只是将位码对应的字形做成了图标，所以不同的字符最终就会渲染成不同的图标。 在Flutter开发中，iconfont和图片相比有如下优势： 体积小：可以减小安装包大小。 矢量的：iconfont都是矢量图标，放大不会影响其清晰度。 可以应用文本样式：可以像文本一样改变字体图标的颜色、大小对齐等。 可以通过TextSpan和文本混用。 使用Material Design字体图标 Flutter默认包含了一套Material Design的字体图标，在pubspec.yaml文件中的配置如下 flutter: uses-material-design: true Material Design所有图标可以在其官网查看：https://material.io/tools/icons/ 我们看一个简单的例子： String icons = \"\"; // accessible: &#xE914; or 0xE914 or E914 icons += \"\\uE914\"; // error: &#xE000; or 0xE000 or E000 icons += \" \\uE000\"; // fingerprint: &#xE90D; or 0xE90D or E90D icons += \" \\uE90D\"; Text(icons, style: TextStyle( fontFamily: \"MaterialIcons\", fontSize: 24.0, color: Colors.green ), ); 运行效果如下： 通过这个示例可以看到，使用图标就像使用文本一样，但是这种方式需要我们提供每个图标的码点，这并对开发者不友好，所以，Flutter封装了一个IconData和Icon来专门显示字体图标，上面的例子也可以用如下方式实现： Row( mainAxisAlignment: MainAxisAlignment.center, children: [ Icon(Icons.accessible,color: Colors.green,), Icon(Icons.error,color: Colors.green,), Icon(Icons.fingerprint,color: Colors.green,), ], ) Icons类中包含了所有Material Design图标的IconData静态变量定义。 使用自定义字体图标 我们也可以使用自定义字体图标。iconfont.cn上有很多字体图标素材，我们可以选择自己需要的图标打包下载后，会生成一些不同格式的字体文件，在Flutter中，我们使用ttf格式即可。 假设我们项目中需要使用一个书籍图标和微信图标，我们打包下载后导入： 导入字体图标文件；这一步和导入字体文件相同，假设我们的字体图标文件保存在项目根目录下，路径为\"fonts/iconfont.ttf\"： fonts: - family: myIcon #指定一个字体名 fonts: - asset: fonts/iconfont.ttf 为了使用方便，我们定义一个MyIcons类，功能和Icons类一样：将字体文件中的所有图标都定义成静态变量： class MyIcons{ // book 图标 static const IconData book = const IconData( 0xe614, fontFamily: 'myIcon', matchTextDirection: true ); // 微信图标 static const IconData wechat = const IconData( 0xec7d, fontFamily: 'myIcon', matchTextDirection: true ); } 使用 Row( mainAxisAlignment: MainAxisAlignment.center, children: [ Icon(MyIcons.book,color: Colors.purple,), Icon(MyIcons.wechat,color: Colors.green,), ], ) 运行后效果如下： "},"chapter3/radio_and_checkbox.html":{"url":"chapter3/radio_and_checkbox.html","title":"单选框和复选框","keywords":"","body":"单选开关和复选框 Material widgets库中提供了Material风格的单选开关Switch和复选框Checkbox，它们都是继承自StatelessWidget，所以它们本身不会保存当前选择状态，所以一般都是在父widget中管理选中状态。当用户点击Switch或Checkbox时，它们会触发onChanged回调，我们可以在此回调中处理选中状态改变逻辑。我们看一个简单的示例： class SwitchAndCheckBoxTestRoute extends StatefulWidget { @override _SwitchAndCheckBoxTestRouteState createState() => new _SwitchAndCheckBoxTestRouteState(); } class _SwitchAndCheckBoxTestRouteState extends State { bool _switchSelected=true; //维护单选开关状态 bool _checkboxSelected=true;//维护复选框状态 @override Widget build(BuildContext context) { return Column( children: [ Switch( value: _switchSelected,//当前状态 onChanged:(value){ //重新构建页面 setState(() { _switchSelected=value; }); }, ), Checkbox( value: _checkboxSelected, activeColor: Colors.red, //选中时的颜色 onChanged:(value){ setState(() { _checkboxSelected=value; }); } , ) ], ); } } 上面代码中，由于要维护Switch和Checkbox状态，所以SwitchAndCheckBoxTestRoute继承自StatefulWidget 。在其build方法中分别构建了一个Switch和Checkbox，初始状态都为选中状态，当用户点击时，会将状态置反，然后回调用setState()通知framework重新构建UI。 属性及外观 Switch和Checkbox属性比较简单，读者可以查看API文档，它们都有一个activeColor属性，用于设置激活态的颜色。至于大小，到目前为止，Checkbox的大小是固定的，无法自定义，而Switch只能定义宽度，高度也是固定的。值得一提的是Checkbox有一个属性tristate ，表示是否为三态，其默认值为false ，这时Checkbox有两种状态即“选中”和“不选中”，对应的value值为true和false ；如果其值为true时，value的值会增加一个状态null，读者可以自行了解。 总结 通过Switch和Checkbox我们可以看到，虽然它们本身是与状态（是否选中）关联的，但它们却不是自己来维护状态，而是需要父widget来管理状态，然后当用户点击时，再通过事件通知给父widget，这样是合理的，因为Switch和Checkbox是否选中本就和用户数据关联，而这些用户数据也不可能是它们的私有状态。我们在自定义widget时也应该思考一下哪种状态的管理方式最为合理。 "},"chapter3/input_and_form.html":{"url":"chapter3/input_and_form.html","title":"输入框和表单","keywords":"","body":"输入框及表单 Material widget库中提供了丰富的输入框及表单Widget。下面我们分别介绍一下。 TextField TextField用于文本输入，它提供了很多属性，我们先简单介绍一下主要属性的作用，然后通过几个示例来演示一下关键属性的用法。 const TextField({ ... TextEditingController controller, FocusNode focusNode, InputDecoration decoration = const InputDecoration(), TextInputType keyboardType, TextInputAction textInputAction, TextStyle style, TextAlign textAlign = TextAlign.start, bool autofocus = false, bool obscureText = false, int maxLines = 1, int maxLength, bool maxLengthEnforced = true, ValueChanged onChanged, VoidCallback onEditingComplete, ValueChanged onSubmitted, List inputFormatters, bool enabled, this.cursorWidth = 2.0, this.cursorRadius, this.cursorColor, ... }) controller：编辑框的控制器，通过它可以设置/获取编辑框的内容、选择编辑内容、监听编辑文本改变事件。大多数情况下我们都需要显式提供一个controller来与文本框交互。如果没有提供controller，则TextField内部会自动创建一个。 focusNode：用于控制TextField是否占有当前键盘的输入焦点。它是我们和键盘交互的一个handle。 InputDecoration：用于控制TextField的外观显示，如提示文本、背景颜色、边框等。 keyboardType：用于设置该输入框默认的键盘输入类型，取值如下： | TextInputType枚举值 | 含义 | | ------------------- | --------------------------------------------------- | | text | 文本输入键盘 | | multiline | 多行文本，需和maxLines配合使用(设为null或大于1) | | number | 数字；会弹出数字键盘 | | phone | 优化后的电话号码输入键盘；会弹出数字键盘并显示\"* #\" | | datetime | 优化后的日期输入键盘；Android上会显示“: -” | | emailAddress | 优化后的电子邮件地址；会显示“@ .” | | url | 优化后的url输入键盘； 会显示“/ .” | textInputAction：键盘动作按钮图标(即回车键位图标)，它是一个枚举值，有多个可选值，全部的取值列表读者可以查看API文档，下面是当值为TextInputAction.search时，原生Android系统下键盘样式： style：正在编辑的文本样式。 textAlign: 输入框内编辑文本在水平方向的对齐方式。 autofocus: 是否自动获取焦点。 obscureText：是否隐藏正在编辑的文本，如用于输入密码的场景等，文本内容会用“•”替换。 maxLines：输入框的最大行数，默认为1；如果为null，则无行数限制。 maxLength和maxLengthEnforced ：maxLength代表输入框文本的最大长度，设置后输入框右下角会显示输入的文本计数。maxLengthEnforced决定当输入文本长度超过maxLength时是否阻止输入，为true时会阻止输入，为false时不会阻止输入但输入框会变红。 onChange：输入框内容改变时的回调函数；注：内容改变事件也可以通过controller来监听。 onEditingComplete和onSubmitted：这两个回调都是在输入框输入完成时触发，比如按了键盘的完成键（对号图标）或搜索键（🔍图标）。不同的是两个回调签名不同，onSubmitted回调是ValueChanged类型，它接收当前输入内容做为参数，而onEditingComplete不接收参数。 inputFormatters：用于指定输入格式；当用户输入内容改变时，会根据指定的格式来校验。 enable：如果为false，则输入框会被禁用，禁用状态不接收输入和事件，同时显示禁用态样式（在其decoration中定义）。 cursorWidth、cursorRadius和cursorColor：这三个属性是用于自定义输入框光标宽度、圆角和颜色的。 示例：登录输入框 布局 Column( children: [ TextField( autofocus: true, decoration: InputDecoration( labelText: \"用户名\", hintText: \"用户名或邮箱\", prefixIcon: Icon(Icons.person) ), ), TextField( decoration: InputDecoration( labelText: \"密码\", hintText: \"您的登录密码\", prefixIcon: Icon(Icons.lock) ), obscureText: true, ), ], ); 获取输入内容 获取输入内容有两种方式： 定义两个变量，用于保存用户名和密码，然后在onChange触发时，各自保存一下输入内容。 通过controller直接获取。 第一种方式比较简单，不在举例，我们来重点看一下第二种方式，我们以用户名输入框举例： 定义一个controller： //定义一个controller TextEditingController _unameController=new TextEditingController(); 然后设置输入框controller： TextField( autofocus: true, controller: _unameController, //设置controller ... ) 通过controller获取输入框内容 print(_unameController.text) 监听文本变化 监听文本变化也有两种方式： 设置onChange回调，如： TextField( autofocus: true, onChanged: (v) { print(\"onChange: $v\"); } ) 通过controller监听，如： @override void initState() { //监听输入改变 _unameController.addListener((){ print(_unameController.text); }); } 两种方式相比，onChanged是专门用于监听文本变化，而controller的功能却多一些，除了能监听文本变化外，它还可以设置默认值、选择文本，下面我们看一个例子： 创建一个controller: TextEditingController _selectionController = new TextEditingController(); 设置默认值，并从第三个字符开始选中后面的字符 _selectionController.text=\"hello world!\"; _selectionController.selection=TextSelection( baseOffset: 2, extentOffset: _selectionController.text.length ); 设置controller: TextField( controller: _selectionController, ) 运行效果如下： 控制焦点 焦点可以通过FocusNode和FocusScopeNode来控制，默认情况下，焦点由FocusScope来管理，它代表焦点控制范围，可以在这个范围内可以通过FocusScopeNode在输入框之间移动焦点、设置默认焦点等。我们可以通过FocusScope.of(context) 来获取widget树中默认的FocusScopeNode。下面看一个示例，在此示例中创建两个TextField，第一个自动获取焦点，然后创建两个按钮： 点击第一个按钮可以将焦点从第一个TextField挪到第二个TextField。 点击第二个按钮可以关闭键盘。 界面如下： 代码如下： class FocusTestRoute extends StatefulWidget { @override _FocusTestRouteState createState() => new _FocusTestRouteState(); } class _FocusTestRouteState extends State { FocusNode focusNode1 = new FocusNode(); FocusNode focusNode2 = new FocusNode(); FocusScopeNode focusScopeNode; @override Widget build(BuildContext context) { return Padding( padding: EdgeInsets.all(16.0), child: Column( children: [ TextField( autofocus: true, focusNode: focusNode1,//关联focusNode1 decoration: InputDecoration( labelText: \"input1\" ), ), TextField( focusNode: focusNode2,//关联focusNode2 decoration: InputDecoration( labelText: \"input2\" ), ), Builder(builder: (ctx) { return Column( children: [ RaisedButton( child: Text(\"移动焦点\"), onPressed: () { //将焦点从第一个TextField移到第二个TextField // 这是一种写法 FocusScope.of(context).requestFocus(focusNode2); // 这是第二种写法 if(null == focusScopeNode){ focusScopeNode = FocusScope.of(context); } focusScopeNode.requestFocus(focusNode2); }, ), RaisedButton( child: Text(\"隐藏键盘\"), onPressed: () { // 当所有编辑框都失去焦点时键盘就会收起 focusNode1.unfocus(); focusNode2.unfocus(); }, ), ], ); }, ), ], ), ); } } FocusNode和FocusScopeNode还有一些其它的方法，详情可以查看API文档。 监听焦点状态改变事件 FocusNode继承自ChangeNotifier，通过FocusNode可以监听焦点的改变事件，如： ... // 创建 focusNode FocusNode focusNode = new FocusNode(); ... // focusNode绑定输入框 TextField(focusNode: focusNode); ... // 监听焦点变化 focusNode.addListener((){ print(focusNode.hasFocus); }); 获得焦点时focusNode.hasFocus值为true，失去焦点时为false。 自定义样式 虽然我们可以通过decoration属性来定义输入框样式，但是有一些样式如下划线默认颜色及宽度都是不能直接自定义的，下面的代码没有效果： TextField( ... decoration: InputDecoration( border: UnderlineInputBorder( //下面代码没有效果 borderSide: BorderSide( color: Colors.red, width: 5.0 )), prefixIcon: Icon(Icons.person) ), ), 之所以如此，是由于TextField在绘制下划线时使用的颜色是主题色里面的hintColor，但提示文本颜色也是用的hintColor， 如果我们直接修改hintColor，那么下划线和提示文本的颜色都会变。值得高兴的是decoration中可以设置hintStyle，它可以覆盖hintColor，并且主题中可以通过inputDecorationTheme来设置输入框默认的decoration。所以我们可以通过主题来自定义，代码如下： Theme( data: Theme.of(context).copyWith( hintColor: Colors.grey[200], //定义下划线颜色 inputDecorationTheme: InputDecorationTheme( labelStyle: TextStyle(color: Colors.grey),//定义label字体样式 hintStyle: TextStyle(color: Colors.grey, fontSize: 14.0)//定义提示文本样式 ) ), child: Column( children: [ TextField( decoration: InputDecoration( labelText: \"用户名\", hintText: \"用户名或邮箱\", prefixIcon: Icon(Icons.person) ), ), TextField( decoration: InputDecoration( prefixIcon: Icon(Icons.lock), labelText: \"密码\", hintText: \"您的登录密码\", hintStyle: TextStyle(color: Colors.grey, fontSize: 13.0) ), obscureText: true, ) ], ) ) 运行效果如下： 我们成功的自定义了下划线颜色和提问文字样式，细心的读者可能已经发现，通过这种方式自定义后，输入框在获取焦点时，labelText不会高亮显示了，正如上图中的\"用户名\"本应该显示蓝色，但现在却显示为灰色，并且我们还是无法定义下划线宽度。另一种灵活的方式是直接隐藏掉TextField本身的下划线，然后通过Container去嵌套定义样式，如: Container( child: TextField( keyboardType: TextInputType.emailAddress, decoration: InputDecoration( labelText: \"Email\", hintText: \"电子邮件地址\", prefixIcon: Icon(Icons.email), border: InputBorder.none //隐藏下划线 ) ), decoration: BoxDecoration( // 下滑线浅灰色，宽度1像素 border: Border(bottom: BorderSide(color: Colors.grey[200], width: 1.0)) ), ) 运行效果： 通过这种widget组合的方式，也可以定义背景圆角等。一般来说，优先通过decoration来自定义样式，如果decoration实现不了，再用widget组合的方式。 思考题：在这个示例中，下划线颜色是固定的，所以获得焦点后颜色仍然为灰色，如何实现点击后下滑线也变色呢？ 表单Form 实际业务中，在正式向服务器提交数据前，都会对各个输入框数据进行合法性校验，但是对每一个TextField都分别进行校验将会是一件很麻烦的事。还有，如果用户想清除一组TextField的内容，除了一个一个清除有没有什么更好的办法呢？为此，Flutter提供了一个Form widget，它可以对输入框进行分组，然后进行一些统一操作，如输入内容校验、输入框重置以及输入内容保存。 Form Form继承自StatefulWidget对象，它对应的状态类为FormState。我们先看看Form类的定义： Form({ @required Widget child, bool autovalidate = false, WillPopCallback onWillPop, VoidCallback onChanged, }) autovalidate：是否自动校验输入内容；当为true时，每一个子FormField内容发生变化时都会自动校验合法性，并直接显示错误信息。否则，需要通过调用FormState.validate()来手动校验。 onWillPop：决定Form所在的路由是否可以直接返回（如点击返回按钮），该回调返回一个Future对象，如果Future的最终结果是false，则当前路由不会返回；如果为true，则会返回到上一个路由。此属性通常用于拦截返回按钮。 onChanged：Form的任意一个子FormField内容发生变化时会触发此回调。 FormField Form的子孙元素必须是FormField类型，FormField是一个抽象类，定义几个属性，FormState内部通过它们来完成操作，FormField部分定义如下： const FormField({ ... FormFieldSetter onSaved, //保存回调 FormFieldValidator validator, //验证回调 T initialValue, //初始值 bool autovalidate = false, //是否自动校验。 }) 为了方便使用，Flutter提供了一个TextFormField widget，它继承自FormField类，也是TextField的一个包装类，所以除了FormField定义的属性之外，它还包括TextField的属性。 FormState FormState为Form的State类，可以通过Form.of()或GlobalKey获得。我们可以通过它来对Form的子孙FormField进行统一操作。我们看看其常用的三个方法： FormState.validate()：调用此方法后，会调用Form子孙FormField的validate回调，如果有一个校验失败，则返回false，所有校验失败项都会返回用户返回的错误提示。 FormState.save()：调用此方法后，会调用Form子孙FormField的save回调，用于保存表单内容 FormState.reset()：调用此方法后，会将子孙FormField的内容清空。 示例 我们修改一下上面用户登录的示例，在提交之前校验： 用户名不能为空，如果为空则提示“用户名不能为空”。 密码不能小于6位，如果小于6为则提示“密码不能少于6位”。 完整代码： class FormTestRoute extends StatefulWidget { @override _FormTestRouteState createState() => new _FormTestRouteState(); } class _FormTestRouteState extends State { TextEditingController _unameController = new TextEditingController(); TextEditingController _pwdController = new TextEditingController(); GlobalKey _formKey= new GlobalKey(); @override Widget build(BuildContext context) { return PageScaffold( title: \"Form Test\", body: Padding( padding: const EdgeInsets.symmetric(vertical: 16.0, horizontal: 24.0), child: Form( key: _formKey, //设置globalKey，用于后面获取FormState autovalidate: true, //开启自动校验 child: Column( children: [ TextFormField( autofocus: true, controller: _unameController, decoration: InputDecoration( labelText: \"用户名\", hintText: \"用户名或邮箱\", icon: Icon(Icons.person) ), // 校验用户名 validator: (v) { return v .trim() .length > 0 ? null : \"用户名不能为空\"; } ), TextFormField( controller: _pwdController, decoration: InputDecoration( labelText: \"密码\", hintText: \"您的登录密码\", icon: Icon(Icons.lock) ), obscureText: true, //校验密码 validator: (v) { return v .trim() .length > 5 ? null : \"密码不能少于6位\"; } ), // 登录按钮 Padding( padding: const EdgeInsets.only(top: 28.0), child: Row( children: [ Expanded( child: RaisedButton( padding: EdgeInsets.all(15.0), child: Text(\"登录\"), color: Theme .of(context) .primaryColor, textColor: Colors.white, onPressed: () { //在这里不能通过此方式获取FormState，context不对 //print(Form.of(context)); // 通过_formKey.currentState 获取FormState后， // 调用validate()方法校验用户名密码是否合法，校验 // 通过后再提交数据。 if((_formKey.currentState as FormState).validate()){ //验证通过提交数据 } }, ), ), ], ), ) ], ), ), ), ); } } 运行后： 注意，登录按钮的onPressed方法中不能通过Form.of(context)来获取，原因是，此处的context为FormTestRoute的context，而Form.of(context)是根据所指定context向根去查找，而FormState是在FormTestRoute的子树中，所以不行。正确的做法是通过Builder来构建登录按钮，Builder会将widget节点的context作为回调参数： Expanded( // 通过Builder来获取RaisedButton所在widget树的真正context(Element) child:Builder(builder: (context){ return RaisedButton( ... onPressed: () { //由于本widget也是Form的子代widget，所以可以通过下面方式获取FormState if(Form.of(context).validate()){ //验证通过提交数据 } }, ); }) ) 其实context正是操作Widget所对应的Element的一个接口，由于Widget树对应的Element都是不同的，所以context也都是不同的，有关context的更多内容会在后面高级部分详细讨论。Flutter中有很多“of(context)”这种方法，在使用时读者一定要注意context是否正确。 "},"chapter4/":{"url":"chapter4/","title":"布局类Widgets","keywords":"","body":"本章目录 布局类Widgets简介 线性布局Row、Column 弹性布局Flex 流式布局Wrap、Flow 层叠布局Stack、Positioned "},"chapter4/intro.html":{"url":"chapter4/intro.html","title":"布局类Widgets简介","keywords":"","body":"布局类Widget 简介 布局类Widget都会包含一个或多个子widget，不同的布局类Widget对子widget排版(layout)方式不同。我们在前面说过Element树才是最终的绘制树，Element树是通过widget树来创建的（通过Widget.createElement()），widget其实就是Element的配置数据。Flutter中，根据Widget是否需要包含子节点将Widget分为了三类，分别对应三种Element，如下表： Widget 对应的Element 用途 LeafRenderObjectWidget LeafRenderObjectElement Widget树的叶子节点，用于没有子节点的widget，通常基础widget都属于这一类，如Text、Image。 SingleChildRenderObjectWidget SingleChildRenderObjectElement 包含一个子Widget，如：ConstrainedBox、DecoratedBox等 MultiChildRenderObjectWidget MultiChildRenderObjectElement 包含多个子Widget，一般都有一个children参数，接受一个Widget数组。如Row、Column、Stack等 注意，Flutter中的很多Widget是直接继承自StatelessWidget或StatefulWidget，然后在build()方法中构建真正的RenderObjectWidget，如Text，它其实是继承自StatelessWidget，然后在build()方法中通过RichText来构建其子树，而RichText才是继承自LeafRenderObjectWidget。所以为了方便叙述，我们也可以直接说Text属于LeafRenderObjectWidget（其它widget也可以这么描述），这才是本质。读到这里我们也会发现，其实StatelessWidget和StatefulWidget就是两个用于组合Widget的基类，它们本身并不关联最终的渲染对象（RenderObjectWidget）。 布局类Widget就是指直接或间接继承(包含)MultiChildRenderObjectWidget的Widget，它们一般都会有一个children属性用于接收子Widget。我们看一下继承关系 Widget > RenderObjectWidget > (Leaf/SingleChild/MultiChild)RenderObjectWidget 。RenderObjectWidget类中定义了创建、更新RenderObject的方法，子类必须实现他们，关于RenderObject我们现在只需要知道它是最终布局、渲染UI界面的对象即可，也就是说，对于布局类Widget来说，其布局算法都是通过对应的RenderObject对象来实现的，所以读者如果对接下来介绍的某个布局类Widget原理感兴趣，可以查看其RenderObject的实现，而在本章中，为了让读者对布局类Widget有个快速的认识，所以我们不会深入到RenderObject的细节中区。在学习本章时，读者的重点是掌握不同布局类Widget的布局特点，具体原理和细节我们会在后面高级部分介绍。 "},"chapter4/row_and_column.html":{"url":"chapter4/row_and_column.html","title":"线性布局Row、Column","keywords":"","body":"线性布局Row和Column 所谓线性布局，即指沿水平或垂直方向排布子Widget。Flutter中通过Row和Column来实现线性布局，类似于Android中的LinearLayout控件。Row和Column都继承自Flex，我们将在弹性布局一节中详细介绍Flex。 主轴和纵轴 对于线性布局，有主轴和纵轴之分，如果布局是沿水平方，那么主轴就指是水平方向，而纵轴即垂直方向；如果布局沿垂直方向，那么主轴就是指垂直方向，而纵轴就是水平方向。在线性布局中，有两个定义对齐方式的枚举类MainAxisAlignment和CrossAxisAlignment，分别代表主轴对齐和纵轴对齐。 Row Row可以在水平方向排列其子widget。定义如下： Row({ ... TextDirection textDirection, MainAxisSize mainAxisSize = MainAxisSize.max, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, VerticalDirection verticalDirection = VerticalDirection.down, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, List children = const [], }) textDirection：表示水平方向子widget的布局顺序(是从左往右还是从右往左)，默认为系统当前Locale环境的文本方向(如中文、英语都是从左往右，而阿拉伯语是从右往左)。 mainAxisSize：表示Row在主轴(水平)方向占用的空间，默认是MainAxisSize.max，表示尽可能多的占用水平方向的空间，此时无论子widgets实际占用多少水平空间，Row的宽度始终等于水平方向的最大宽度；而MainAxisSize.min表示尽可能少的占用水平空间，当子widgets没有占满水平剩余空间，则Row的实际宽度等于所有子widgets占用的的水平空间； mainAxisAlignment：表示子Widgets在Row所占用的水平空间内对齐方式，如果mainAxisSize值为MainAxisSize.min，则此属性无意义，因为子widgets的宽度等于Row的宽度。只有当mainAxisSize的值为MainAxisSize.max时，此属性才有意义，MainAxisAlignment.start表示沿textDirection的初始方向对齐，如textDirection取值为TextDirection.ltr时，则MainAxisAlignment.start表示左对齐，textDirection取值为TextDirection.rtl时表示从右对齐。而MainAxisAlignment.end和MainAxisAlignment.start正好相反；MainAxisAlignment.center表示居中对齐。读者可以这么理解：textDirection是mainAxisAlignment的参考系。 verticalDirection：表示Row纵轴（垂直）的对齐方向，默认是VerticalDirection.down，表示从上到下。 crossAxisAlignment：表示子Widgets在纵轴方向的对齐方式，Row的高度等于子Widgets中最高的子元素高度，它的取值和MainAxisAlignment一样(包含start、end、 center三个值)，不同的是crossAxisAlignment的参考系是verticalDirection，即verticalDirection值为VerticalDirection.down时crossAxisAlignment.start指顶部对齐，verticalDirection值为VerticalDirection.up时，crossAxisAlignment.start指底部对齐；而crossAxisAlignment.end和crossAxisAlignment.start正好相反； children ：子Widgets数组。 示例 请阅读下面代码，想象一下运行的结果： Column( //测试Row对齐方式，排除Column默认居中对齐的干扰 crossAxisAlignment: CrossAxisAlignment.start, children: [ Row( mainAxisAlignment: MainAxisAlignment.center, children: [ Text(\" hello world \"), Text(\" I am Jack \"), ], ), Row( mainAxisSize: MainAxisSize.min, mainAxisAlignment: MainAxisAlignment.center, children: [ Text(\" hello world \"), Text(\" I am Jack \"), ], ), Row( mainAxisAlignment: MainAxisAlignment.end, textDirection: TextDirection.rtl, children: [ Text(\" hello world \"), Text(\" I am Jack \"), ], ), Row( crossAxisAlignment: CrossAxisAlignment.start, verticalDirection: VerticalDirection.up, children: [ Text(\" hello world \", style: TextStyle(fontSize: 30.0),), Text(\" I am Jack \"), ], ), ], ); 运行结果： 解释：第一个Row很简单，默认为居中对齐；第二个Row，由于mainAxisSize值为MainAxisSize.min，Row的宽度等于两个Text的宽度和，所以对齐是无意义的，所以会从左往右显示；第三个Row设置textDirection值为TextDirection.rtl，所以子widget会从右向左的顺序排列，而此时MainAxisAlignment.end表示左对齐，所以最终显示结果就是图中第三行的样子；第四个Row测试的是纵轴的对齐方式，由于两个子Text字体不一样，所以其高度也不同，我们指定了verticalDirection值为VerticalDirection.up，即从低向顶排列，而此时crossAxisAlignment值为CrossAxisAlignment.start表示底对齐。 Column Column可以在垂直方向排列其子widget。参数和Row一样，不同的是布局方向为垂直，主轴纵轴正好相反，读者可类比Row来理解，在此不再赘述。 特殊情况 如果Row里面嵌套Row，或者Column里面再嵌套Column，那么只有对最外面的Row或Column会占用尽可能大的空间，里面Row或Column所占用的空间为实际大小，下面以Column为例说明： Container( color: Colors.green, child: Padding( padding: const EdgeInsets.all(16.0), child: Column( crossAxisAlignment: CrossAxisAlignment.start, mainAxisSize: MainAxisSize.max, //有效，外层Colum高度为整个屏幕 children: [ Container( color: Colors.red, child: Column( mainAxisSize: MainAxisSize.max,//无效，内层Colum高度为实际高度 children: [ Text(\"hello world \"), Text(\"I am Jack \"), ], ), ) ], ), ), ); 运行结果： 如果要让里面的Colum占满外部Colum，可以使用Expanded widget： Expanded( child: Container( color: Colors.red, child: Column( mainAxisAlignment: MainAxisAlignment.center, //垂直方向居中对齐 children: [ Text(\"hello world \"), Text(\"I am Jack \"), ], ), ), ) 运行效果： 我们将在介绍弹性布局时详细介绍Expanded。 "},"chapter4/flex.html":{"url":"chapter4/flex.html","title":"弹性布局Flex","keywords":"","body":"弹性布局 弹性布局允许子widget按照一定比例来分配父容器空间，弹性布局的概念在其UI系统中也都存在，如H5中的弹性盒子布局，Android中的FlexboxLayout。Flutter中的弹性布局主要通过Flex和Expanded来配合实现。 Flex Flex可以沿着水平或垂直方向排列子widget，如果你知道主轴方向，使用Row或Column会方便一些，因为Row和Column都继承自Flex，参数基本相同，所以能使用Flex的地方一定可以使用Row或Column。Flex本身功能是很强大的，它也可以和Expanded配合实现弹性布局，接下来我们只讨论Flex和弹性布局相关的属性(其它属性已经在介绍Row和Column时介绍过了)。 Flex({ ... @required this.direction, //弹性布局的方向, Row默认为水平方向，Column默认为垂直方向 List children = const [], }) Flex继承自MultiChildRenderObjectWidget，对应的RenderObject为RenderFlex，RenderFlex中实现了其布局算法。 Expanded 可以按比例“扩伸”Row、Column和Flex子widget所占用的空间。 const Expanded({ int flex = 1, @required Widget child, }) flex为弹性系数，如果为0或null，则child是没有弹性的，即不会被扩伸占用的空间。如果大于0，所有的Expanded按照其flex的比例来分割主轴的全部空闲空间。下面我们看一个例子： class FlexLayoutTestRoute extends StatelessWidget { @override Widget build(BuildContext context) { return Column( children: [ //Flex的两个子widget按1：2来占据水平空间 Flex( direction: Axis.horizontal, children: [ Expanded( flex: 1, child: Container( height: 30.0, color: Colors.red, ), ), Expanded( flex: 2, child: Container( height: 30.0, color: Colors.green, ), ), ], ), Padding( padding: const EdgeInsets.only(top: 20.0), child: SizedBox( height: 100.0, //Flex的三个子widget，在垂直方向按2：1：1来占用100像素的空间 child: Flex( direction: Axis.vertical, children: [ Expanded( flex: 2, child: Container( height: 30.0, color: Colors.red, ), ), Spacer( flex: 1, ), Expanded( flex: 1, child: Container( height: 30.0, color: Colors.green, ), ), ], ), ), ), ], ); } } 运行效果如下： 示例中的Spacer的功能是占用指定比例的空间，实际上它只是Expanded的一个包装： new Expanded( flex: flex, child: const SizedBox( height: 0.0, width: 0.0, ), ); "},"chapter4/wrap_and_flow.html":{"url":"chapter4/wrap_and_flow.html","title":"流式布局Wrap、Flow","keywords":"","body":"流式布局 Wrap 在介绍Row和Colum时，如果子widget超出屏幕范围，则会报溢出错误，如： Row( children: [ Text(\"xxx\"*100) ], ); 运行： 可以看到，右边溢出部分报错。这是因为Row默认只有一行，如果超出屏幕不会折行。我们把超出屏幕显示范围会自动折行的布局称为流式布局。Flutter中通过Wrap和Flow来支持流式布局，将上例中的Row换成Wrap后溢出部分则会自动折行。下面是Wrap的定义: Wrap({ ... this.direction = Axis.horizontal, this.alignment = WrapAlignment.start, this.spacing = 0.0, this.runAlignment = WrapAlignment.start, this.runSpacing = 0.0, this.crossAxisAlignment = WrapCrossAlignment.start, this.textDirection, this.verticalDirection = VerticalDirection.down, List children = const [], }) 我们可以看到Wrap的很多属性在Row（包括Flex和Column）中也有，如direction、crossAxisAlignment、textDirection、verticalDirection等，这些参数意义是相同的，我们不再重复介绍，读者可以查阅前面介绍Row的部分。读者可以认为Wrap和Flex（包括Row和Column）除了超出显示范围后Wrap会折行外，其它行为基本相同。下面我们看一下Wrap特有的几个属性： spacing：主轴方向子widget的间距 runSpacing：纵轴方向的间距 runAlignment：纵轴方向的对齐方式 下面看一个示例子： Wrap( spacing: 8.0, // 主轴(水平)方向间距 runSpacing: 4.0, // 纵轴（垂直）方向间距 alignment: WrapAlignment.center, //沿主轴方向居中 children: [ new Chip( avatar: new CircleAvatar(backgroundColor: Colors.blue, child: Text('A')), label: new Text('Hamilton'), ), new Chip( avatar: new CircleAvatar(backgroundColor: Colors.blue, child: Text('M')), label: new Text('Lafayette'), ), new Chip( avatar: new CircleAvatar(backgroundColor: Colors.blue, child: Text('H')), label: new Text('Mulligan'), ), new Chip( avatar: new CircleAvatar(backgroundColor: Colors.blue, child: Text('J')), label: new Text('Laurens'), ), ], ) 运行效果： Flow 我们一般很少会使用Flow，因为其过于复杂，需要自己实现子widget的位置转换，在很多场景下首先要考虑的是Wrap是否满足需求。Flow主要用于一些需要自定义布局策略或性能要求较高(如动画中)的场景。Flow有如下优点： 性能好；Flow是一个对child尺寸以及位置调整非常高效的控件，Flow用转换矩阵（transformation matrices）在对child进行位置调整的时候进行了优化：在Flow定位过后，如果child的尺寸或者位置发生了变化，在FlowDelegate中的paintChildren()方法中调用context.paintChild 进行重绘，而context.paintChild在重绘时使用了转换矩阵（transformation matrices），并没有实际调整Widget位置。 灵活；由于我们需要自己实现FlowDelegate的paintChildren()方法，所以我们需要自己计算每一个widget的位置，因此，可以自定义布局策略。 缺点： 使用复杂. 不能自适应子widget大小，必须通过指定父容器大小或实现TestFlowDelegate的getSize返回固定大小。 示例： 我们对六个色块进行自定义流式布局： Flow( delegate: TestFlowDelegate(margin: EdgeInsets.all(10.0)), children: [ new Container(width: 80.0, height:80.0, color: Colors.red,), new Container(width: 80.0, height:80.0, color: Colors.green,), new Container(width: 80.0, height:80.0, color: Colors.blue,), new Container(width: 80.0, height:80.0, color: Colors.yellow,), new Container(width: 80.0, height:80.0, color: Colors.brown,), new Container(width: 80.0, height:80.0, color: Colors.purple,), ], ) 实现TestFlowDelegate: class TestFlowDelegate extends FlowDelegate { EdgeInsets margin = EdgeInsets.zero; TestFlowDelegate({this.margin}); @override void paintChildren(FlowPaintingContext context) { var x = margin.left; var y = margin.top; //计算每一个子widget的位置 for (int i = 0; i 效果： 可以看到我们主要的任务就是实现paintChildren，它的主要任务是确定每个子widget位置。由于Flow不能自适应子widget的大小，我们通过在getSize返回一个固定大小来指定Flow的大小。 "},"chapter4/stack.html":{"url":"chapter4/stack.html","title":"层叠布局Stack、Positioned","keywords":"","body":"层叠布局 层叠布局和Web中的绝对定位、Android中的Frame布局是相似的，子widget可以根据到父容器四个角的位置来确定本身的位置。绝对定位允许子widget堆叠（按照代码中声明的顺序）。Flutter中使用Stack和Positioned来实现绝对定位，Stack允许子widget堆叠，而Positioned可以给子widget定位（根据Stack的四个角）。 Stack Stack({ this.alignment = AlignmentDirectional.topStart, this.textDirection, this.fit = StackFit.loose, this.overflow = Overflow.clip, List children = const [], }) alignment：此参数决定如何去对齐没有定位（没有使用Positioned）或部分定位的子widget。所谓部分定位，在这里特指没有在某一个轴上定位：left、right为横轴，top、bottom为纵轴，只要包含某个轴上的一个定位属性就算在该轴上有定位。 textDirection：和Row、Wrap的textDirection功能一样，都用于决定alignment对齐的参考系即：textDirection的值为TextDirection.ltr，则alignment的start代表左，end代表右；textDirection的值为TextDirection.rtl，则alignment的start代表右，end代表左。 fit：此参数用于决定没有定位的子widget如何去适应Stack的大小。StackFit.loose表示使用子widget的大小，StackFit.expand表示扩伸到Stack的大小。 overflow：此属性决定如何显示超出Stack显示空间的子widget，值为Overflow.clip时，超出部分会被剪裁（隐藏），值为Overflow.visible 时则不会。 Positioned const Positioned({ Key key, this.left, this.top, this.right, this.bottom, this.width, this.height, @required Widget child, }) left、top 、right、 bottom分别代表离Stack左、上、右、底四边的距离。width和height用于指定定位元素的宽度和高度，注意，此处的width、height 和其它地方的意义稍微有点区别，此处用于配合left、top 、right、 bottom来定位widget，举个例子，在水平方向时，你只能指定left、right、width三个属性中的两个，如指定left和width后，right会自动算出(left+width)，如果同时指定三个属性则会报错，垂直方向同理。 示例 //通过ConstrainedBox来确保Stack占满屏幕 ConstrainedBox( constraints: BoxConstraints.expand(), child: Stack( alignment:Alignment.center , //指定未定位或部分定位widget的对齐方式 children: [ Container(child: Text(\"Hello world\",style: TextStyle(color: Colors.white)), color: Colors.red, ), Positioned( left: 18.0, child: Text(\"I am Jack\"), ), Positioned( top: 18.0, child: Text(\"Your friend\"), ) ], ), ); 运行效果如下： 由于第一个子widget Text(\"Hello world\")没有指定定位，并且alignment值为Alignment.center，所以，它会居中显示。第二个子widget Text(\"I am Jack\")只指定了水平方向的定位(left)，所以属于部分定位，即垂直方向上没有定位，那么它在垂直方向对齐方式则会按照alignment指定的对齐方式对齐，即垂直方向居中。对于第三个子widget Text(\"Your friend\")，和第二个Text原理一样，只不过是水平方向没有定位，则水平方向居中。 我们给上例中的Stack指定一个fit属性，然后将三个子widget的顺序调整一下： Stack( alignment:Alignment.center , fit: StackFit.expand, //未定位widget占满Stack整个空间 children: [ Positioned( left: 18.0, child: Text(\"I am Jack\"), ), Container(child: Text(\"Hello world\",style: TextStyle(color: Colors.white)), color: Colors.red, ), Positioned( top: 18.0, child: Text(\"Your friend\"), ) ], ), 显示效果如下： 可以看到，由于第二个子widget没有定位，所以fit属性会对它起作用，就会占满Stack。有Stack子元素是堆叠的，所以第一个子Widget被第二个遮住了，而第三个在最上层，所以可以正常显示。 "},"chapter5/":{"url":"chapter5/","title":"容器类Widgets","keywords":"","body":"容器类Widget 容器类Widget和布局类Widget都作用于其子Widget，不同的是： 布局类Widget一般都需要接收一个widget数组（children），他们直接或间接继承自（或包含）MultiChildRenderObjectWidget ；而容器类Widget一般只需要接受一个子Widget（child），他们直接或间接继承自（或包含）SingleChildRenderObjectWidget。 布局类Widget是按照一定的排列方式来对其子Widget进行排列；而容器类Widget一般只是包装其子Widget，对其添加一些修饰（补白或背景色等）、变换(旋转或剪裁等)、或限制(大小等)。 注意，Flutter官方并没有对Widget进行官方分类，我们对其分类主要是为了方便讨论和对Widget功能的区分记忆。 本章目录 Padding 布局限制类容器ConstrainedBox、SizeBox 装饰容器DecoratedBox 变换Transform Container容器 Scaffold、TabBar、底部导航 "},"chapter5/padding.html":{"url":"chapter5/padding.html","title":"Padding","keywords":"","body":"Padding Padding可以给其子节点添加补白（填充），我们在前面很多示例中都已经使用过它了，现在来看看它的定义： Padding({ ... EdgeInsetsGeometry padding, Widget child, }) EdgeInsetsGeometry是一个抽象类，开发中，我们一般都使用EdgeInsets，它是EdgeInsetsGeometry的一个子类，定义了一些设置补白的便捷方法。 EdgeInsets 我们看看EdgeInsets提供的便捷方法： fromLTRB(double left, double top, double right, double bottom)：分别指定四个方向的补白。 all(double value) : 所有方向均使用相同数值的补白。 only({left, top, right ,bottom })：可以设置具体某个方向的补白(可以同时指定多个方向)。 symmetric({ vertical, horizontal })：用于设置对称方向的补白，vertical指top和bottom，horizontal指left和right。 示例 class PaddingTestRoute extends StatelessWidget { @override Widget build(BuildContext context) { return Padding( //上下左右各添加16像素补白 padding: EdgeInsets.all(16.0), child: Column( //显式指定对齐方式为左对齐，排除对齐干扰 crossAxisAlignment: CrossAxisAlignment.start, children: [ Padding( //左边添加8像素补白 padding: const EdgeInsets.only(left: 8.0), child: Text(\"Hello world\"), ), Padding( //上下各添加8像素补白 padding: const EdgeInsets.symmetric(vertical: 8.0), child: Text(\"I am Jack\"), ), Padding( // 分别指定四个方向的补白 padding: const EdgeInsets.fromLTRB(20.0,.0,20.0,20.0), child: Text(\"Your friend\"), ) ], ), ); } } "},"chapter5/constrainedbox_and_sizebox.html":{"url":"chapter5/constrainedbox_and_sizebox.html","title":"布局限制类容器ConstrainedBox、SizeBox","keywords":"","body":"ConstrainedBox和SizedBox ConstrainedBox和SizedBox都是通过RenderConstrainedBox来渲染的。SizedBox只是ConstrainedBox一个定制，本节把他们放在一起讨论。 ConstrainedBox ConstrainedBox用于对齐子widget添加额外的约束。例如，如果你想让子widget的最小高度是80像素，你可以使用const BoxConstraints(minHeight: 80.0)作为子widget的约束。 示例 我们先定义一个redBox，它是一个背景颜色为红色的盒子，不指定它的宽度和高度： Widget redBox=DecoratedBox( decoration: BoxDecoration(color: Colors.red), ); 我们实现一个最小高度为50，宽度尽可能大的红色容器。 ConstrainedBox( constraints: BoxConstraints( minWidth: double.infinity, //宽度尽可能大 minHeight: 50.0 //最小高度为50像素 ), child: Container( height: 5.0, child: redBox ), ) 显示效果： 可以看到，我们虽然将Container的高度设置为5像素，但是最终却是50像素，这正是ConstrainedBox的最小高度限制生效了。如果将Container的高度设置为80像素，那么最终红色区域的高度也会是80像素，因为在此示例中，ConstrainedBox只限制了最小高度，并未限制最大高度。 BoxConstraints BoxConstraints用于设置限制条件，它的定义如下： const BoxConstraints({ this.minWidth = 0.0, //最小宽度 this.maxWidth = double.infinity, //最大宽度 this.minHeight = 0.0, //最小高度 this.maxHeight = double.infinity //最大高度 }) BoxConstraints还定义了一些便捷的构造函数，用于快速生成特定限制规则的BoxConstraints，如BoxConstraints.tight(Size size)，它可以生成给定大小的限制；const BoxConstraints.expand()可以生成一个尽可能大的用以填充另一个容器的BoxConstraints。除此之外还有一些其它的便捷函数，读者可以查看API文档。 SizedBox SizedBox用于给子widget指定固定的宽高，如： SizedBox( width: 80.0, height: 80.0, child: redBox ) 运行效果如下： 实际上SizedBox和只是ConstrainedBox一个定制，上面代码等价于： ConstrainedBox( constraints: BoxConstraints.tightFor(width: 80.0,height: 80.0), child: redBox, ) 而BoxConstraints.tightFor(width: 80.0,height: 80.0)等价于： BoxConstraints(minHeight: 80.0,maxHeight: 80.0,minWidth: 80.0,maxWidth: 80.0) 而实际上ConstrainedBox和SizedBox都是通过RenderConstrainedBox来渲染的，我们可以看到ConstrainedBox和SizedBox的createRenderObject()方法都返回的是一个RenderConstrainedBox对象： @override RenderConstrainedBox createRenderObject(BuildContext context) { return new RenderConstrainedBox( additionalConstraints: ..., ); } 多重限制 如果某一个widget有多个父ConstrainedBox限制，那么最终会是哪个生效？我们看一个例子： ConstrainedBox( constraints: BoxConstraints(minWidth: 60.0, minHeight: 60.0), //父 child: ConstrainedBox( constraints: BoxConstraints(minWidth: 90.0, minHeight: 20.0),//子 child: redBox, ) ) 上面我们有父子两个ConstrainedBox，他们的限制条件不同，运行后效果如下： 最终显示效果是宽90，高60，也就是说是子ConstrainedBox的minWidth生效，而minHeight是父ConstrainedBox生效。单凭这个例子，我们还总结不出什么规律，我们将上例中父子限制条件换一下： ConstrainedBox( constraints: BoxConstraints(minWidth: 90.0, minHeight: 20.0), child: ConstrainedBox( constraints: BoxConstraints(minWidth: 60.0, minHeight: 60.0), child: redBox, ) ) 最终的显示效果仍然是90，高60，效果相同，但意义不同，因为此时minWidth生效的是父ConstrainedBox，而minHeight是子ConstrainedBox生效。 通过上面示例，我们发现有多重限制时，对于minWidth和minHeight来说，是取父子中相应数值较大的。实际上，只有这样才能保证父限制与子限制不冲突。 思考题：对于maxWidth和maxHeight，多重限制的策略是什么样的呢？ UnconstrainedBox UnconstrainedBox不会对子Widget产生任何限制，它允许其子Widget按照其本身大小绘制。一般情况下，我们会很少直接使用此widget，但在\"去除\"多重限制的时候也许会有帮助，我们看一下面的代码： ConstrainedBox( constraints: BoxConstraints(minWidth: 60.0, minHeight: 100.0), //父 child: UnconstrainedBox( //“去除”父级限制 child: ConstrainedBox( constraints: BoxConstraints(minWidth: 90.0, minHeight: 20.0),//子 child: redBox, ), ) ) 上面代码中，如果没有中间的UnconstrainedBox，那么根据上面所述的多重限制规则，那么最终将显示一个90×100的红色框。但是由于 UnconstrainedBox “去除”了父ConstrainedBox的限制，则最终会按照子ConstrainedBox的限制来绘制redBox，即90×20： 但是，读者请注意，UnconstrainedBox对父限制的“去除”并非是真正的去除，上面例子中虽然红色区域大小是90×20，但上方仍然有80的空白空间。也就是说父限制的minHeight(100.0)仍然是生效的，只不过它不影响最终子元素的大小，但仍然还是占有相应的空间，可以认为此时的父ConstrainedBox是作用于子ConstrainedBox上，而redBox只受子ConstrainedBox限制，这一点请读者务必注意。 那么有什么方法可以彻底去除父BoxConstraints的限制吗？答案是否定的！所以在此提示读者，在定义一个通用的widget时，如果对子widget指定限制时一定要注意，因为一旦指定限制条件，子widget如果要进行相关自定义大小时将可能非常困难，因为子widget在不更改父widget的代码的情况下无法彻底去除其限制条件。 "},"chapter5/decoratedbox.html":{"url":"chapter5/decoratedbox.html","title":"装饰容器DecoratedBox","keywords":"","body":"DecoratedBox DecoratedBox可以在其子widget绘制前(或后)绘制一个装饰Decoration（如背景、边框、渐变等）。DecoratedBox定义如下： const DecoratedBox({ Decoration decoration, DecorationPosition position = DecorationPosition.background, Widget child }) decoration：代表将要绘制的装饰，它类型为Decoration，Decoration是一个抽象类，它定义了一个接口 createBoxPainter()，子类的主要职责是需要通过实现它来创建一个画笔，该画笔用于绘制装饰。 position：此属性决定在哪里绘制Decoration，它接收DecorationPosition的枚举类型，该枚举类两个值： background：在子widget之后绘制，即背景装饰。 foreground：在子widget之上绘制，即前景。 BoxDecoration 我们通常会直接使用BoxDecoration，它是一个Decoration的子类，实现了常用的装饰元素的绘制。 BoxDecoration({ Color color, //颜色 DecorationImage image,//图片 BoxBorder border, //边框 BorderRadiusGeometry borderRadius, //圆角 List boxShadow, //阴影,可以指定多个 Gradient gradient, //渐变 BlendMode backgroundBlendMode, //背景混合模式 BoxShape shape = BoxShape.rectangle, //形状 }) 各个属性名都是自解释的，详情读者可以查看API文档，我们看一个示例： DecoratedBox( decoration: BoxDecoration( gradient: LinearGradient(colors:[Colors.red,Colors.orange[700]]), //背景渐变 borderRadius: BorderRadius.circular(3.0), //3像素圆角 boxShadow: [ //阴影 BoxShadow( color:Colors.black54, offset: Offset(2.0,2.0), blurRadius: 4.0 ) ] ), child: Padding(padding: EdgeInsets.symmetric(horizontal: 80.0, vertical: 18.0), child: Text(\"Login\", style: TextStyle(color: Colors.white),), ) ) 效果如下： 怎么样，通过BoxDecoration，我们实现了一个渐变按钮的外观，但此示例还不是一个标准的按钮，因为它还不能响应点击事件，我们将在本章末尾来实现一个完整的GradientButton。 "},"chapter5/transform.html":{"url":"chapter5/transform.html","title":"变换Transform","keywords":"","body":"Transform变换 Transform可以在其子Widget绘制时对其应用一个矩阵变换（transformation），Matrix4是一个4D矩阵，通过它我们可以实现各种矩阵操作。下面是一个例子： Container( color: Colors.black, child: new Transform( alignment: Alignment.topRight, //相对于坐标系原点的对齐方式 transform: new Matrix4.skewY(0.3), //沿Y轴倾斜0.3弧度 child: new Container( padding: const EdgeInsets.all(8.0), color: Colors.deepOrange, child: const Text('Apartment for rent!'), ), ), ); 关于矩阵变换的相关内容属于线性代数范畴，本书不做讨论，读者有兴趣可以自行了解。本书中，我们把焦点放在Flutter中一些常见的变换效果上。 平移 Transform.translate接收一个offset参数，可以在绘制时沿x、y轴对子widget平移指定的距离。 DecoratedBox( decoration:BoxDecoration(color: Colors.red), //默认原点为左上角，左移20像素，向上平移5像素 child: Transform.translate(offset: Offset(-20.0, -5.0), child: Text(\"Hello world\"), ), ) 效果： 旋转 Transform.rotate可以对子widget进行旋转变换，如： DecoratedBox( decoration:BoxDecoration(color: Colors.red), child: Transform.rotate( //旋转90度 angle:math.pi/2 , child: Text(\"Hello world\"), ), )； 注意：要使用math.pi需先进行如下导包。 import 'dart:math' as math; 效果： 缩放 Transform.scale可以对子Widget进行缩小或放大，如： DecoratedBox( decoration:BoxDecoration(color: Colors.red), child: Transform.scale( scale: 1.5, //放大到1.5倍 child: Text(\"Hello world\") ) ); 效果： 注意 Transform的变换是应用在绘制阶段，而并不是应用在布局(layout)阶段，所以无论对子widget应用何种变化，其占用空间的大小和在屏幕上的位置都是固定不变的，因为这些是在布局阶段就确定的。下面我们具体说明： Row( mainAxisAlignment: MainAxisAlignment.center, children: [ DecoratedBox( decoration:BoxDecoration(color: Colors.red), child: Transform.scale(scale: 1.5, child: Text(\"Hello world\") ) ), Text(\"你好\", style: TextStyle(color: Colors.green, fontSize: 18.0),) ], ) 显示效果： 由于第一个Text应用变换(放大)后，其在绘制时会放大，但其占用的空间依然为红色部分，所以第二个text会紧挨着红色部分，最终就会出现文字有重合部分。 由于矩阵变化只会作用在绘制阶段，所以在某些场景下，在UI需要变化时，可以直接通过矩阵变化来达到视觉上的UI改变，而不需要去重新触发build流程，这样会节省layout的开销，所以性能会比较好。如之前介绍的Flow widget，它内部就是用矩阵变换来更新UI，除此之外，Flutter的动画widget中也大量使用了Transform以提高性能。 RotatedBox RotatedBox和Transform.rotate功能相似，它们都可以对子widget进行旋转变换，但是有一点不同：RotatedBox的变换是在layout阶段，会影响在子widget的位置和大小。我们将上面介绍Transform.rotate时的示例改一下： Row( mainAxisAlignment: MainAxisAlignment.center, children: [ DecoratedBox( decoration: BoxDecoration(color: Colors.red), //将Transform.rotate换成RotatedBox child: RotatedBox( quarterTurns: 1, //旋转90度(1/4圈) child: Text(\"Hello world\"), ), ), Text(\"你好\", style: TextStyle(color: Colors.green, fontSize: 18.0),) ], ), 效果： 由于RotatedBox是作用于layout阶段，所以widget会旋转90度（而不只是绘制的内容），decoration会作用到widget所占用的实际空间上，所以就是上图的效果。读者可以和前面Transform.rotate示例对比理解。 "},"chapter5/container.html":{"url":"chapter5/container.html","title":"Container容器","keywords":"","body":"Container Container是我们要介绍的最后一个容器类widget，它本身不对应具体的RenderObject，它是DecoratedBox、ConstrainedBox、Transform、Padding、Align等widget的一个组合widget。所以我们只需通过一个Container可以实现同时需要装饰、变换、限制的场景。下面是Container的定义： Container({ this.alignment, this.padding, //容器内补白，属于decoration的装饰范围 Color color, // 背景色 Decoration decoration, // 背景装饰 Decoration foregroundDecoration, //前景装饰 double width,//容器的宽度 double height, //容器的高度 BoxConstraints constraints, //容器大小的限制条件 this.margin,//容器外补白，不属于decoration的装饰范围 this.transform, //变换 this.child, }) 大多数属性在介绍其它容器时都已经介绍过了，不再赘述，但有两点需要说明： 容器的大小可以通过width、height属性来指定，也可以通过constraints来指定，如果同时存在时，width、height优先。实际上Container内部会根据width、height来生成一个constraints。 color和decoration是互斥的，实际上，当指定color时，Container内会自动创建一个decoration。 实例 我们通过Container来实现如下的卡片： 代码： Container( margin: EdgeInsets.only(top: 50.0, left: 120.0), //容器外补白 constraints: BoxConstraints.tightFor(width: 200.0, height: 150.0), //卡片大小 decoration: BoxDecoration(//背景装饰 gradient: RadialGradient( //背景径向渐变 colors: [Colors.red, Colors.orange], center: Alignment.topLeft, radius: .98 ), boxShadow: [ //卡片阴影 BoxShadow( color: Colors.black54, offset: Offset(2.0, 2.0), blurRadius: 4.0 ) ] ), transform: Matrix4.rotationZ(.2), //卡片倾斜变换 alignment: Alignment.center, //卡片内文字居中 child: Text( //卡片文字 \"5.20\", style: TextStyle(color: Colors.white, fontSize: 40.0), ), ); 可以看到Container通过组合多种widget来实现复杂强大的功能，在Flutter中，这也正是组合优先于继承的实例。 Padding和Margin 接下来我们看看Container的margin和padding属性的区别: ... Container( margin: EdgeInsets.all(20.0), //容器外补白 color: Colors.orange, child: Text(\"Hello world!\"), ), Container( padding: EdgeInsets.all(20.0), //容器内补白 color: Colors.orange, child: Text(\"Hello world!\"), ), ... 可以发现，直观的感觉就是margin的补白是在容器外部，而padding的补白是在容器内部，读者需要记住这个差异。事实上，Container内margin和padding都是通过Padding widget来实现的，上面的示例代码实际上等价于： ... Padding( padding: EdgeInsets.all(20.0), child: DecoratedBox( decoration: BoxDecoration(color: Colors.orange), child: Text(\"Hello world!\"), ), ), DecoratedBox( decoration: BoxDecoration(color: Colors.orange), child: Padding( padding: const EdgeInsets.all(20.0), child: Text(\"Hello world!\"), ), ), ... "},"chapter5/material_scaffold.html":{"url":"chapter5/material_scaffold.html","title":"Scaffold、TabBar、底部导航","keywords":"","body":"Scaffold、TabBar、底部导航 Material库提供了很多Widget，本节介绍一些常用的Widget，其余的读者可以查看文档或Flutter Gallery中Material组件部分的示例。注意，笔者强烈建议用户将Flutter Gallery示例跑起来，它是一个很全面的Flutter示例，是非常好的参考Demo。 Scaffold 大多数路由页都会包含一个导航栏，有些路由页可能会有抽屉菜单(Drawer)以及底部Tab导航菜单等。如果每个页面都需要开发者自己手动去实现，这会是一件非常无聊的事。幸运的是，我们前面提到过，Flutter Material库提供了一个Scaffold Widget，它是一个路由页的骨架，可以非常容易的拼装出一个完整的页面。 示例 我们实现一个页面，它包含： 一个导航栏 导航栏右边有一个分享按钮 有一个抽屉菜单 有一个底部导航 右下角有一个悬浮的动作按钮 最终效果如下： 实现代码如下： class ScaffoldRoute extends StatefulWidget { @override _ScaffoldRouteState createState() => _ScaffoldRouteState(); } class _ScaffoldRouteState extends State { int _selectedIndex = 1; @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( //导航栏 title: Text(\"App Name\"), actions: [ //导航栏右侧菜单 IconButton(icon: Icon(Icons.share), onPressed: () {}), ], ), drawer: new MyDrawer(), //抽屉 bottomNavigationBar: BottomNavigationBar( // 底部导航 items: [ BottomNavigationBarItem(icon: Icon(Icons.home), title: Text('Home')), BottomNavigationBarItem(icon: Icon(Icons.business), title: Text('Business')), BottomNavigationBarItem(icon: Icon(Icons.school), title: Text('School')), ], currentIndex: _selectedIndex, fixedColor: Colors.blue, onTap: _onItemTapped, ), floatingActionButton: FloatingActionButton( //悬浮按钮 child: Icon(Icons.add), onPressed:_onAdd ), ); } void _onItemTapped(int index) { setState(() { _selectedIndex = index; }); } void _onAdd(){ } } 上面代码中我们用到了另外几个Widget，下面我们来分别介绍一下： AppBar AppBar是一个Material风格的导航栏，它可以设置标题、导航栏菜单、底部Tab等。下面我们看看AppBar的定义： AppBar({ Key key, this.leading, //导航栏最左侧Widget，常见为抽屉菜单按钮或返回按钮。 this.automaticallyImplyLeading = true, //如果leading为null，是否自动实现默认的leading按钮 this.title,// 页面标题 this.actions, // 导航栏右侧菜单 this.bottom, // 导航栏底部菜单，通常为Tab按钮组 this.elevation = 4.0, // 导航栏阴影 this.centerTitle, //标题是否居中 this.backgroundColor, ... //其它属性见源码注释 }) 如果给Scaffold添加了抽屉菜单，默认情况下Scaffold会自动将AppBar的leading设置为菜单按钮（如上面截图所示）。如果我们想自定义菜单图标，可以手动来设置leading，如： Scaffold( appBar: AppBar( title: Text(\"App Name\"), leading: Builder(builder: (context) { return IconButton( icon: Icon(Icons.dashboard, color: Colors.white), //自定义图标 onPressed: () { // 打开抽屉菜单 Scaffold.of(context).openDrawer(); }, ); }), ... ) 代码运行效果： 可以看到左侧菜单已经替换成功。 代码中打开抽屉菜单的方法在ScaffoldState中，通过Scaffold.of(context)可以获取父级最近的Scaffold Widget的State对象，原理可以参考本书后面“Element与BuildContext” 一章。Flutter还有一种通用的获取StatefulWidget对象State的方法：通过GlobalKey来获取！ 步骤有两步： 给目标StatefulWidget添加GlobalKey //定义一个globalKey, 由于GlobalKey要保持全局唯一性，我们使用静态变量存储 static GlobalKey _globalKey= new GlobalKey(); ... Scaffold( key: _globalKey , //设置key ... ) 通过GlobalKey来获取State对象 _globalKey.currentState.openDrawer() TabBar 下面我们通过“bottom”属性来添加一个导航栏底部tab按钮组，将要实现的效果如下： Material组件库中提供了一个TabBar组件，它可以快速生成Tab菜单，下面是上图对应的源码： class _ScaffoldRouteState extends State with SingleTickerProviderStateMixin { TabController _tabController; //需要定义一个Controller List tabs = [\"新闻\", \"历史\", \"图片\"]; @override void initState() { super.initState(); // 创建Controller _tabController = TabController(length: tabs.length, vsync: this); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( ... //省略无关代码 bottom: TabBar( //生成Tab菜单 controller: _tabController, tabs: tabs.map((e) => Tab(text: e)).toList()), ), ... //省略无关代码 } 上面代码首先创建了一个TabController ，它是用于控制/监听Tab菜单切换。然后通过TabBar生成了一个底部菜单栏，TabBar的tabs属性接受一个Widget数组，表示每一个Tab子菜单，我们可以自定义，也可以像示例中一样直接使用Tab Widget，它也是Material组件库提供的Material风格的Tab菜单。 Tab Widget有三个可选参数，除了可以指定文字外，还可以指定Tab菜单图标，或者直接自定义Widget，定义如下： Tab({ Key key, this.text, // 菜单文本 this.icon, // 菜单图标 this.child, // 自定义Widget }) 开发者可以根据实际需求来定制。 TabBarView 通过TabBar我们只能生成一个静态的菜单，如果要实现Tab页，我们可以通过TabController去监听Tab菜单的切换去切换Tab页，代码如： _tabController.addListener((){ switch(_tabController.index){ case 1: ...; case 2: ... ; } }); 如果我们Tab页可以滑动切换的话，还需要在滑动过程中更新TabBar指示器的偏移。显然，要手动处理这些是很麻烦的，为此，Material库提供了一个TabBarView组件，它可以很轻松的配合TabBar来实现同步切换和滑动状态同步，示例如下： Scaffold( appBar: AppBar( ... //省略无关代码 bottom: TabBar( controller: _tabController, tabs: tabs.map((e) => Tab(text: e)).toList()), ), drawer: new MyDrawer(), body: TabBarView( controller: _tabController, children: tabs.map((e) { //创建3个Tab页 return Container( alignment: Alignment.center, child: Text(e, textScaleFactor: 5), ); }).toList(), ), ... // 省略无关代码 ) 运行后效果如下： 现在，无论是点击导航栏Tab菜单还是在页面上左右滑动，Tab页面都会切换，并且Tab菜单的状态和Tab页面始终保持同步。下面我们来看看代码，细心的读者可以发现，TabBar和TabBarView的controller是同一个！正是如此，TabBar和TabBarView正是通过同一个controller来实现菜单切换和滑动状态同步的。 另外，Material组件库也提供了一个PageView Widget，它和TabBarView功能相似，读者可以自行了解一下。 抽屉菜单Drawer Scaffold的drawer和endDrawer属性可以分别接受一个Widget作为页面的左、右抽屉菜单，如果开发者提供了抽屉菜单，那么当用户手指重屏幕左/右向里滑动时便可打开抽屉菜单。本节开始部分的示例中实现了一个左抽屉菜单MyDrawer，源码如下： class MyDrawer extends StatelessWidget { const MyDrawer({ Key key, }) : super(key: key); @override Widget build(BuildContext context) { return Drawer( child: MediaQuery.removePadding( context: context, // DrawerHeader consumes top MediaQuery padding. removeTop: true, child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Padding( padding: const EdgeInsets.only(top: 38.0), child: Row( children: [ Padding( padding: const EdgeInsets.symmetric(horizontal: 16.0), child: ClipOval( child: Image.asset( \"imgs/avatar.png\", width: 80, ), ), ), Text( \"Wendux\", style: TextStyle(fontWeight: FontWeight.bold), ) ], ), ), Expanded( child: ListView( children: [ ListTile( leading: const Icon(Icons.add), title: const Text('Add account'), ), ListTile( leading: const Icon(Icons.settings), title: const Text('Manage accounts'), ), ], ), ), ], ), ), ); } } 抽屉菜单通常将Drawer作为根节点，它实现了Material风格的菜单面板，MediaQuery.removePadding可以移除抽Drawer内的一些指定空白，读者可以尝试传递不同的参数来看看实际效果。抽屉菜单页顶部由用户头像和昵称组成，底部是一个菜单列表，用ListView实现，关于ListView我们将在后面“可滚动Widget”一节详细介绍。 FloatingActionButton FloatingActionButton是Material设计规范中的一种特殊Button，通常悬浮在页面的某一个位置作为某种常用动作的快捷入口，如本节示例中页面右下角的\"➕\"号按钮。我们可以通过Scaffold的floatingActionButton属性来设置一个FloatingActionButton，同时通过floatingActionButtonLocation属性来指定其在页面中悬浮的位置，这个比较简单，不在赘述。 底部Tab导航栏 我们可以通过Scaffold的bottomNavigationBar属性来设置底部导航，如本节开始示例所示，我们通过Material组件库提供的BottomNavigationBar和BottomNavigationBarItem两个Widget来实现Material风格的底部导航栏，可以看到代码非常简单，不在赘述。但是如果我们想实现如下效果的底部导航应该怎么做呢？ Material组件库中提供了一个BottomAppBar Widget，可以和FloatingActionButton配合实现这种\"打洞\"效果。源码如下： bottomNavigationBar: BottomAppBar( color: Colors.white, shape: CircularNotchedRectangle(), // 底部导航栏打一个圆形的洞 child: Row( children: [ IconButton(icon: Icon(Icons.home)), SizedBox(), //中间位置空出 IconButton(icon: Icon(Icons.business)), ], mainAxisAlignment: MainAxisAlignment.spaceAround, //均分底部导航栏横向空间 ), ) 可以看到，上面代码中没有控制打洞位置的属性，实际上，打洞的位置取决于FloatingActionButton的位置，上面FloatingActionButton的位置为： floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked, BottomAppBar的shape属性决定洞的外形，CircularNotchedRectangle实现了一个圆形的外形，我们也可以自定义外形，比如，Flutter Gallery示例中就有一个”钻石“形状的实现，读者感兴趣可以自行查看。 "},"chapter6/":{"url":"chapter6/","title":"可滚动Widgets","keywords":"","body":"本章目录 可滚动Widgets简介 SingleChildScrollView ListView GridView CustomScrollView 滚动监听及控制ScrollController "},"chapter6/intro.html":{"url":"chapter6/intro.html","title":"可滚动Widgets简介","keywords":"","body":"可滚动Widget简介 当内容超过显示视口(ViewPort)时，如果没有特殊处理，Flutter则会提示Overflow错误。为此，Flutter提供了多种可滚动widget（Scrollable Widget）用于显示列表和长布局。在本章中，我们先介绍一下常用的可滚动widget（如ListView、GridView等），然后介绍一下Scrollable与可滚动widget的原理。可滚动Widget都直接或间接包含一个Scrollable widget，因此它们包括一些共同的属性，为了避免重复介绍，我们在此统一介绍一下： Scrollable({ ... this.axisDirection = AxisDirection.down, this.controller, this.physics, @required this.viewportBuilder, //后面介绍 }) axisDirection：滚动方向。 physics：此属性接受一个ScrollPhysics对象，它决定可滚动Widget如何响应用户操作，比如用户滑动完抬起手指后，继续执行动画；或者滑动到边界时，如何显示。默认情况下，Flutter会根据具体平台分别使用不同的ScrollPhysics对象，应用不同的显示效果，如当滑动到边界时，继续拖动的话，在iOS上会出现弹性效果，而在Android上会出现微光效果。如果你想在所有平台下使用同一种效果，可以显式指定，Flutter SDK中包含了两个ScrollPhysics的子类可以直接使用： ClampingScrollPhysics：Android下微光效果。 BouncingScrollPhysics：iOS下弹性效果。 controller：此属性接受一个ScrollController对象。ScrollController的主要作用是控制滚动位置和监听滚动事件。默认情况下，widget树中会有一个默认的PrimaryScrollController，如果子树中的可滚动widget没有显式的指定controller并且primary属性值为true时（默认就为true），可滚动widget会使用这个默认的PrimaryScrollController，这种机制带来的好处是父widget可以控制子树中可滚动widget的滚动，例如，Scaffold使用这种机制在iOS中实现了\"回到顶部\"的手势。我们将在本章后面“滚动控制”一节详细介绍ScrollController。 Scrollbar Scrollbar是一个Material风格的滚动指示器（滚动条），如果要给可滚动widget添加滚动条，只需将Scrollbar作为可滚动widget的父widget即可，如： Scrollbar( child: SingleChildScrollView( ... ), ); Scrollbar和CupertinoScrollbar都是通过ScrollController来监听滚动事件来确定滚动条位置，关于ScrollController详细的内容我们将在后面专门一节介绍。 CupertinoScrollbar CupertinoScrollbar是iOS风格的滚动条，如果你使用的是Scrollbar，那么在iOS平台它会自动切换为CupertinoScrollbar。 ViewPort视口 在很多布局系统中都有ViewPort的概念，在Flutter中，术语ViewPort（视口），如无特别说明，则是指一个Widget的实际显示区域。例如，一个ListView的显示区域高度是800像素，虽然其列表项总高度可能远远超过800像素，但是其ViewPort仍然是800像素。 主轴和纵轴 在可滚动widget的坐标描述中，通常将滚动方向称为主轴，非滚动方向称为纵轴。由于可滚动widget的默认方向一般都是沿垂直方向，所以默认情况下主轴就是指垂直方向，水平方向同理。 "},"chapter6/single_child_scrollview.html":{"url":"chapter6/single_child_scrollview.html","title":"SingleChildScrollView","keywords":"","body":"SingleChildScrollView SingleChildScrollView类似于Android中的ScrollView，它只能接收一个子Widget。定义如下： SingleChildScrollView({ this.scrollDirection = Axis.vertical, //滚动方向，默认是垂直方向 this.reverse = false, this.padding, bool primary, this.physics, this.controller, this.child, }) 除了通用属性，我们重点看一下reverse和primary两个属性： reverse：该属性API文档解释是：是否按照阅读方向相反的方向滑动，如：scrollDirection值为Axis.horizontal，如果阅读方向是从左到右(取决于语言环境，阿拉伯语就是从右到左)，reverse为true时，那么滑动方向就是从右往左。其实此属性本质上是决定可滚动widget的初始滚动位置是在“头”还是“尾”，取false时，初始滚动位置在“头”，反之则在“尾”，读者可以自己试验。 primary：指是否使用widget树中默认的PrimaryScrollController；当滑动方向为垂直方向（scrollDirection值为Axis.vertical）并且controller没有指定时，primary默认为true. 示例 下面是一个将大写字母A-Z沿垂直方向显示的例子，由于垂直方向空间不够，所以使用SingleChildScrollView。： class SingleChildScrollViewTestRoute extends StatelessWidget { @override Widget build(BuildContext context) { String str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; return Scrollbar( child: SingleChildScrollView( padding: EdgeInsets.all(16.0), child: Center( child: Column( //动态创建一个List children: str.split(\"\") //每一个字母都用一个Text显示,字体为原来的两倍 .map((c) => Text(c, textScaleFactor: 2.0,)) .toList(), ), ), ), ); } } 效果： "},"chapter6/listview.html":{"url":"chapter6/listview.html","title":"ListView","keywords":"","body":"ListView ListView是最常用的可滚动widget，它可以沿一个方向线性排布所有子widget。我们看看ListView的默认构造函数定义： ListView({ ... //可滚动widget公共参数 Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController controller, bool primary, ScrollPhysics physics, EdgeInsetsGeometry padding, //ListView各个构造函数的共同参数 double itemExtent, bool shrinkWrap = false, bool addAutomaticKeepAlives = true, bool addRepaintBoundaries = true, double cacheExtent, //子widget列表 List children = const [], }) 上面参数分为两组：第一组是可滚动widget公共参数，前面已经介绍过，不再赘述；第二组是ListView各个构造函数（ListView有多个构造函数）的共同参数，我们重点来看看这些参数，： itemExtent：该参数如果不为null，则会强制children的\"长度\"为itemExtent的值；这里的\"长度\"是指滚动方向上子widget的长度，即如果滚动方向是垂直方向，则itemExtent代表子widget的高度，如果滚动方向为水平方向，则itemExtent代表子widget的长度。在ListView中，指定itemExtent比让子widget自己决定自身长度会更高效，这是因为指定itemExtent后，滚动系统可以提前知道列表的长度，而不是总是动态去计算，尤其是在滚动位置频繁变化时（滚动系统需要频繁去计算列表高度）。 shrinkWrap：该属性表示是否根据子widget的总长度来设置ListView的长度，默认值为false 。默认情况下，ListView的会在滚动方向尽可能多的占用空间。当ListView在一个无边界(滚动方向上)的容器中时，shrinkWrap必须为true。 addAutomaticKeepAlives：该属性表示是否将列表项（子widget）包裹在AutomaticKeepAlive widget中；典型地，在一个懒加载列表中，如果将列表项包裹在AutomaticKeepAlive中，在该列表项滑出视口时该列表项不会被GC，它会使用KeepAliveNotification来保存其状态。如果列表项自己维护其KeepAlive状态，那么此参数必须置为false。 addRepaintBoundaries：该属性表示是否将列表项（子widget）包裹在RepaintBoundary中。当可滚动widget滚动时，将列表项包裹在RepaintBoundary中可以避免列表项重绘，但是当列表项重绘的开销非常小（如一个颜色块，或者一个较短的文本）时，不添加RepaintBoundary反而会更高效。和addAutomaticKeepAlive一样，如果列表项自己维护其KeepAlive状态，那么此参数必须置为false。 注意：上面这些参数并非ListView特有，在本章后面介绍的其它可滚动widget也可能会拥有这些参数，它们的含义是相同的。 默认构造函数 默认构造函数有一个children参数，它接受一个Widget列表（List）。这种方式适合只有少量的子widget的情况，因为这种方式需要将所有children都提前创建好（这需要做大量工作），而不是等到子widget真正显示的时候再创建。实际上通过此方式创建的ListView和使用SingleChildScrollView+Column的方式没有本质的区别。下面是一个例子： ListView( shrinkWrap: true, padding: const EdgeInsets.all(20.0), children: [ const Text('I\\'m dedicating every day to you'), const Text('Domestic life was never quite my style'), const Text('When you smile, you knock me out, I fall apart'), const Text('And I thought I was so smart'), ], ); 注意：可滚动widget通过一个List来作为其children属性时，只适用于子widget较少的情况，这是一个通用规律，并非ListView自己的特性，像GridView也是如此。 ListView.builder ListView.builder适合列表项比较多（或者无限）的情况，因为只有当子Widget真正显示的时候才会被创建。下面看一下ListView.builder的核心参数列表： ListView.builder({ // ListView公共参数已省略 ... @required IndexedWidgetBuilder itemBuilder, int itemCount, ... }) itemBuilder：它是列表项的构建器，类型为IndexedWidgetBuilder，返回值为一个widget。当列表滚动到具体的index位置时，会调用该构建器构建列表项。 itemCount：列表项的数量，如果为null，则为无限列表。 看一个例子： ListView.builder( itemCount: 100, itemExtent: 50.0, //强制高度为50.0 itemBuilder: (BuildContext context, int index) { return ListTile(title: Text(\"$index\")); } ); ListView.separated ListView.separated可以生成列表项之间的分割器，它除了比ListView.builder多了一个separatorBuilder参数，该参数是一个分割器生成器。下面我们看一个例子：奇数行添加一条蓝色下划线，偶数行添加一条绿色下划线。 class ListView3 extends StatelessWidget { @override Widget build(BuildContext context) { //下划线widget预定义以供复用。 Widget divider1=Divider(color: Colors.blue,); Widget divider2=Divider(color: Colors.green); return ListView.separated( itemCount: 100, //列表项构造器 itemBuilder: (BuildContext context, int index) { return ListTile(title: Text(\"$index\")); }, //分割器构造器 separatorBuilder: (BuildContext context, int index) { return index%2==0?divider1:divider2; }, ); } } 实例：无限加载列表 假设我们要从数据源异步分批拉取一些数据，然后用ListView显示，当我们滑动到列表末尾时，判断是否需要再去拉取数据，如果是，则去拉取，拉取过程中在表尾显示一个loading，拉取成功后将数据插入列表；如果不需要再去拉取，则在表尾提示\"没有更多\"。代码如下： class InfiniteListView extends StatefulWidget { @override _InfiniteListViewState createState() => new _InfiniteListViewState(); } class _InfiniteListViewState extends State { static const loadingTag = \"##loading##\"; //表尾标记 var _words = [loadingTag]; @override void initState() { _retrieveData(); } @override Widget build(BuildContext context) { return ListView.separated( itemCount: _words.length, itemBuilder: (context, index) { //如果到了表尾 if (_words[index] == loadingTag) { //不足100条，继续获取数据 if (_words.length - 1 Divider(height: .0), ); } void _retrieveData() { Future.delayed(Duration(seconds: 2)).then((e) { _words.insertAll(_words.length - 1, //每次生成20个单词 generateWordPairs().take(20).map((e) => e.asPascalCase).toList() ); setState(() { //重新构建列表 }); }); } } 代码比较简单，读者可以参照代码中的注释理解，故不再赘述。需要说明的是，_retrieveData()的功能是模拟从数据源异步获取数据，我们使用english_words包的generateWordPairs()方法每次生成20个单词。 添加固定表头 很多时候我们需要给列表添加一个固定表头，比如我们想实现一个商品列表，需要在列表顶部添加一个“商品列表”标题，效果如下： 我们按照之前经验，写出如下代码： @override Widget build(BuildContext context) { return Column(children: [ ListTile(title:Text(\"商品列表\")), ListView.builder(itemBuilder: (BuildContext context, int index) { return ListTile(title: Text(\"$index\")); }), ]); } 然后运行，发现并没有出现我们期望的效果，相反触发了一个异常； Error caught by rendering library, thrown during performResize()。 Vertical viewport was given unbounded height ... 从异常信息中我们可到是因为ListView高度边界无法确定引起，所以解决的办法也很明显，我们需要给ListView指定边界，我们通过SizedBox指定一个列表高度看看是否生效： ... //省略无关代码 SizedBox( height: 400, //指定列表高度为400 child: ListView.builder(itemBuilder: (BuildContext context, int index) { return ListTile(title: Text(\"$index\")); }), ), ... 运行效果如下： 可以看到，现在没有触发异常并且列表已经显示出来了，但是我们的手机屏幕高度要大于400，所以底部会有一些空白，那如果我们要实现列表铺满除过表头以外的屏幕空间呢？直观的方法是我们动态计算，用屏幕高度减去状态栏、导航栏、表头的高度即为剩余屏幕高度，代码如下： ... //省略无关代码 SizedBox( //Material设计规范中状态栏、导航栏、ListTile高度分别为24、56、56 height: MediaQuery.of(context).size.height-24-56-56, child: ListView.builder(itemBuilder: (BuildContext context, int index) { return ListTile(title: Text(\"$index\")); }), ) ... 运行效果如下： 可以看到，我们期望的效果实现了，但是这种方法并不优雅，如果页面布局发生变化，如表头布局调整导致表头高度改变，那么剩余空间的高度就得重新计算，那么有什么方法可以自动拉升ListView以填充屏幕剩余空间的方法吗？当然有！答案就是Flex。前面已经介绍过在Flex布局中，可以使用Expanded自动拉伸组件大小的Widget，我们也说过Column是继承自Flex的，所以我们可以直接使用Column+Expanded来实现，代码如下： @override Widget build(BuildContext context) { return Column(children: [ ListTile(title:Text(\"商品列表\")), Expanded( child: ListView.builder(itemBuilder: (BuildContext context, int index) { return ListTile(title: Text(\"$index\")); }), ), ]); } 总结 本节主要介绍了ListView的一些公共参数以及常用的构造函数。不同的构造函数对应了不同的列表项生成模型，如果需要自定义列表项生成模型，可以通过ListView.custom来自定义，它需要实现一个SliverChildDelegate用来给ListView生成列表项widget，更多详情请参考API文档。 "},"chapter6/gridview.html":{"url":"chapter6/gridview.html","title":"GridView","keywords":"","body":"GridView GridView可以构建一个二维网格列表，其默认构造函数定义如下： GridView({ Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController controller, bool primary, ScrollPhysics physics, bool shrinkWrap = false, EdgeInsetsGeometry padding, @required SliverGridDelegate gridDelegate, //控制子widget layout的委托 bool addAutomaticKeepAlives = true, bool addRepaintBoundaries = true, double cacheExtent, List children = const [], }) 我们可以看到，GridView和ListView的大多数参数都是相同的，它们的含义也都相同，如有疑惑读者可以翻阅ListView一节，在此不再赘述。我们唯一需要关注的是gridDelegate参数，类型是SliverGridDelegate，它的作用是控制GridView子widget如何排列(layout)，SliverGridDelegate是一个抽象类，定义了GridView Layout相关接口，子类需要通过实现它们来实现具体的布局算法，Flutter中提供了两个SliverGridDelegate的子类SliverGridDelegateWithFixedCrossAxisCount和SliverGridDelegateWithMaxCrossAxisExtent，下面我们分别介绍： SliverGridDelegateWithFixedCrossAxisCount 该子类实现了一个横轴为固定数量子元素的layout算法，其构造函数为： SliverGridDelegateWithFixedCrossAxisCount({ @required double crossAxisCount, double mainAxisSpacing = 0.0, double crossAxisSpacing = 0.0, double childAspectRatio = 1.0, }) crossAxisCount：横轴子元素的数量。此属性值确定后子元素在横轴的长度就确定了,即ViewPort横轴长度/crossAxisCount。 mainAxisSpacing：主轴方向的间距。 crossAxisSpacing：横轴方向子元素的间距。 childAspectRatio：子元素在横轴长度和主轴长度的比例。由于crossAxisCount指定后子元素横轴长度就确定了，然后通过此参数值就可以确定子元素在主轴的长度。 可以发现，子元素的大小是通过crossAxisCount和childAspectRatio两个参数共同决定的。注意，这里的子元素指的是子widget的最大显示空间，注意确保子widget的实际大小不要超出子元素的空间。 下面看一个例子： GridView( gridDelegate: SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 3, //横轴三个子widget childAspectRatio: 1.0 //宽高比为1时，子widget ), children:[ Icon(Icons.ac_unit), Icon(Icons.airport_shuttle), Icon(Icons.all_inclusive), Icon(Icons.beach_access), Icon(Icons.cake), Icon(Icons.free_breakfast) ] ); GridView.count GridView.count构造函数内部使用了SliverGridDelegateWithFixedCrossAxisCount，我们通过它可以快速的创建横轴固定数量子元素的GridView，上面的示例代码等价于： GridView.count( crossAxisCount: 3, childAspectRatio: 1.0, children: [ Icon(Icons.ac_unit), Icon(Icons.airport_shuttle), Icon(Icons.all_inclusive), Icon(Icons.beach_access), Icon(Icons.cake), Icon(Icons.free_breakfast), ], ); SliverGridDelegateWithMaxCrossAxisExtent 该子类实现了一个横轴子元素为固定最大长度的layout算法，其构造函数为： SliverGridDelegateWithMaxCrossAxisExtent({ double maxCrossAxisExtent, double mainAxisSpacing = 0.0, double crossAxisSpacing = 0.0, double childAspectRatio = 1.0, }) maxCrossAxisExtent为子元素在横轴上的最大长度，之所以是“最大”长度，是因为横轴方向每个子元素的长度仍然是等分的，举个例子，如果ViewPort的横轴长度是450，那么当maxCrossAxisExtent的值在区间(450/4，450/3]内的话，子元素最终实际长度都为150，而childAspectRatio所指的子元素横轴和主轴的长度比为最终的长度比。其它参数和SliverGridDelegateWithFixedCrossAxisCount相同。 下面我们看一个例子： GridView( padding: EdgeInsets.zero, gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent( maxCrossAxisExtent: 120.0, childAspectRatio: 2.0 //宽高比为2 ), children: [ Icon(Icons.ac_unit), Icon(Icons.airport_shuttle), Icon(Icons.all_inclusive), Icon(Icons.beach_access), Icon(Icons.cake), Icon(Icons.free_breakfast), ], ); GridView.extent GridView.extent构造函数内部使用了SliverGridDelegateWithMaxCrossAxisExtent，我们通过它可以快速的创建纵轴子元素为固定最大长度的的GridView，上面的示例代码等价于： GridView.extent( maxCrossAxisExtent: 120.0, childAspectRatio: 2.0, children: [ Icon(Icons.ac_unit), Icon(Icons.airport_shuttle), Icon(Icons.all_inclusive), Icon(Icons.beach_access), Icon(Icons.cake), Icon(Icons.free_breakfast), ], ); GridView.builder 上面我们介绍的GridView都需要一个Widget数组作为其子元素，这些方式都会提前将所有子widget都构建好，所以只适用于子Widget数量比较少时，当子widget比较多时，我们可以通过GridView.builder来动态创建子Widget。GridView.builder 必须指定的参数有两个： GridView.builder( ... @required SliverGridDelegate gridDelegate, @required IndexedWidgetBuilder itemBuilder, ) 其中itemBuilder为子widget构建器。 示例 假设我们需要从一个异步数据源（如网络）分批获取一些Icon，然后用GridView来展示： class InfiniteGridView extends StatefulWidget { @override _InfiniteGridViewState createState() => new _InfiniteGridViewState(); } class _InfiniteGridViewState extends State { List _icons = []; //保存Icon数据 @override void initState() { // 初始化数据 _retrieveIcons(); } @override Widget build(BuildContext context) { return GridView.builder( gridDelegate: SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 3, //每行三列 childAspectRatio: 1.0 //显示区域宽高相等 ), itemCount: _icons.length, itemBuilder: (context, index) { //如果显示到最后一个并且Icon总数小于200时继续获取数据 if (index == _icons.length - 1 && _icons.length _retrieveIcons()：在此方法中我们通过Future.delayed来模拟从异步数据源获取数据，每次获取数据需要200毫秒，获取成功后将新数据添加到_icons，然后调用setState重新构建。 在itemBuilder中，如果显示到最后一个时，判断是否需要继续获取数据，然后返回一个Icon。 更多 Flutter的GridView默认子元素显示空间是相等的，但在实际开发中，你可能会遇到子元素大小不等的情况，如下面这样的布局： Pub上有一个包“flutter_staggered_grid_view” ，它实现了一个交错GridView的布局模型，可以很轻松的实现这种布局，详情读者可以自行了解。 "},"chapter6/custom_scrollview.html":{"url":"chapter6/custom_scrollview.html","title":"CustomScrollView","keywords":"","body":"CustomScrollView CustomScrollView是可以使用sliver来自定义滚动模型（效果）的widget。它可以包含多种滚动模型，举个例子，假设有一个页面，顶部需要一个GridView，底部需要一个ListView，而要求整个页面的滑动效果是统一的，即它们看起来是一个整体，如果使用GridView+ListView来实现的话，就不能保证一致的滑动效果，因为它们的滚动效果是分离的，所以这时就需要一个\"胶水\"，把这些彼此独立的可滚动widget（Sliver）\"粘\"起来，而CustomScrollView的功能就相当于“胶水”。 Sliver Sliver有细片、小片之意，在Flutter中，Sliver通常指具有特定滚动效果的可滚动块。可滚动widget，如ListView、GridView等都有对应的Sliver实现如SliverList、SliverGrid等。对于大多数Sliver来说，它们和可滚动Widget最主要的区别是Sliver不会包含Scrollable Widget，也就是说Sliver本身不包含滚动交互模型 ，正因如此，CustomScrollView才可以将多个Sliver\"粘\"在一起，这些Sliver共用CustomScrollView的Scrollable，最终实现统一的滑动效果。 Sliver系列Widget比较多，我们不会一一介绍，读者只需记住它的特点，需要时再去查看文档即可。上面之所以说“大多数“Sliver都和可滚动Widget对应，是由于还有一些如SliverPadding、SliverAppBar等是和可滚动Widget无关的，它们主要是为了结合CustomScrollView一起使用，这是因为CustomScrollView的子widget必须都是Sliver。 示例 import 'package:flutter/material.dart'; class CustomScrollViewTestRoute extends StatelessWidget { @override Widget build(BuildContext context) { //因为本路由没有使用Scaffold，为了让子级Widget(如Text)使用 //Material Design 默认的样式风格,我们使用Material作为本路由的根。 return Material( child: CustomScrollView( slivers: [ //AppBar，包含一个导航栏 SliverAppBar( pinned: true, expandedHeight: 250.0, flexibleSpace: FlexibleSpaceBar( title: const Text('Demo'), background: Image.asset( \"./images/avatar.png\", fit: BoxFit.cover,), ), ), SliverPadding( padding: const EdgeInsets.all(8.0), sliver: new SliverGrid( //Grid gridDelegate: new SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 2, //Grid按两列显示 mainAxisSpacing: 10.0, crossAxisSpacing: 10.0, childAspectRatio: 4.0, ), delegate: new SliverChildBuilderDelegate( (BuildContext context, int index) { //创建子widget return new Container( alignment: Alignment.center, color: Colors.cyan[100 * (index % 9)], child: new Text('grid item $index'), ); }, childCount: 20, ), ), ), //List new SliverFixedExtentList( itemExtent: 50.0, delegate: new SliverChildBuilderDelegate( (BuildContext context, int index) { //创建列表项 return new Container( alignment: Alignment.center, color: Colors.lightBlue[100 * (index % 9)], child: new Text('list item $index'), ); }, childCount: 50 //50个列表项 ), ), ], ), ); } } 代码分为三部分： 头部SliverAppBar：SliverAppBar对应AppBar，两者不同之处在于SliverAppBar可以集成到CustomScrollView。SliverAppBar可以结合FlexibleSpaceBar实现Material Design中头部伸缩的模型，具体效果，读者可以运行该示例查看。 中间的SliverGrid：它用SliverPadding包裹以给SliverGrid添加补白。SliverGrid是一个两列，宽高比为4的网格，它有20个子widget。 底部SliverFixedExtentList：它是一个所有子元素高度都为50像素的列表。 运行效果： "},"chapter6/scroll_controller.html":{"url":"chapter6/scroll_controller.html","title":"滚动监听及控制ScrollController","keywords":"","body":"滚动监听及控制 在前几节中，我们介绍了Flutter中常用的可滚动Widget，也说过可以用ScrollController来控制可滚动widget的滚动位置，本节先介绍一下ScrollController，然后以ListView为例，展示一下ScrollController的具体用法。最后，再介绍一下路由切换时如何来保存滚动位置。 ScrollController 构造函数： ScrollController({ double initialScrollOffset = 0.0, //初始滚动位置 this.keepScrollOffset = true,//是否保存滚动位置 ... }) 我们介绍一下ScrollController常用的属性和方法： offset：可滚动Widget当前滚动的位置。 jumpTo(double offset)、animateTo(double offset,...)：这两个方法用于跳转到指定的位置，它们不同之处在于，后者在跳转时会执行一个动画，而前者不会。 ScrollController还有一些属性和方法，我们将在后面原理部分解释。 滚动监听 ScrollController间接继承自Listenable，我们可以根据ScrollController来监听滚动事件。如： controller.addListener(()=>print(controller.offset)) 示例 我们创建一个ListView，当滚动位置发生变化时，我们先打印出当前滚动位置，然后判断当前位置是否超过1000像素，如果超过则在屏幕右下角显示一个“返回顶部”的按钮，该按钮点击后可以使ListView恢复到初始位置；如果没有超过1000像素，则隐藏“返回顶部”按钮。代码如下： class ScrollControllerTestRoute extends StatefulWidget { @override ScrollControllerTestRouteState createState() { return new ScrollControllerTestRouteState(); } } class ScrollControllerTestRouteState extends State { ScrollController _controller = new ScrollController(); bool showToTopBtn = false; //是否显示“返回到顶部”按钮 @override void initState() { //监听滚动事件，打印滚动位置 _controller.addListener(() { print(_controller.offset); //打印滚动位置 if (_controller.offset = 1000 && showToTopBtn == false) { setState(() { showToTopBtn = true; }); } }); } @override void dispose() { //为了避免内存泄露，需要调用_controller.dispose _controller.dispose(); super.dispose(); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: Text(\"滚动控制\")), body: Scrollbar( child: ListView.builder( itemCount: 100, itemExtent: 50.0, //列表项高度固定时，显式指定高度是一个好习惯(性能消耗小) controller: _controller, itemBuilder: (context, index) { return ListTile(title: Text(\"$index\"),); } ), ), floatingActionButton: !showToTopBtn ? null : FloatingActionButton( child: Icon(Icons.arrow_upward), onPressed: () { //返回到顶部时执行动画 _controller.animateTo(.0, duration: Duration(milliseconds: 200), curve: Curves.ease ); } ), ); } } 代码说明已经包含在注释里，下面我们看看运行效果： 由于列表项高度为50像素，当滑动到第20个列表项后，右下角“返回顶部”按钮会显示，点击该按钮，ListView会在返回顶部的过程中执行一个滚动动画，动画时间是200毫秒，动画曲线是Curves.ease，关于动画的详细内容我们将在后面“动画”一章中详细介绍。 滚动位置恢复 PageStorage是一个用于保存页面(路由)相关数据的Widget，它并不会影响子树的UI外观，其实，PageStorage是一个功能型Widget，它拥有一个存储桶（bucket），子树中的Widget可以通过指定不同的PageStorageKey来存储各自的数据或状态。 每次滚动结束，Scrollable Widget都会将滚动位置offset存储到PageStorage中，当Scrollable Widget 重新创建时再恢复。如果ScrollController.keepScrollOffset为false，则滚动位置将不会被存储，Scrollable Widget重新创建时会使用ScrollController.initialScrollOffset；ScrollController.keepScrollOffset为true时，Scrollable Widget在第一次创建时，会滚动到initialScrollOffset处，因为这时还没有存储过滚动位置。在接下来的滚动中就会存储、恢复滚动位置，而initialScrollOffset会被忽略。 当一个路由中包含多个Scrollable Widget时，如果你发现在进行一些跳转或切换操作后，滚动位置不能正确恢复，这时你可以通过显式指定PageStorageKey来分别跟踪不同Scrollable Widget的位置，如： ListView(key: PageStorageKey(1), ... ); ... ListView(key: PageStorageKey(2), ... ); 不同的PageStorageKey，需要不同的值，这样才可以区分为不同Scrollable Widget保存的滚动位置。 注意：一个路由中包含多个Scrollable Widget时，如果要分别跟踪它们的滚动位置，并非一定就得给他们分别提供PageStorageKey。这是因为Scrollable本身是一个StatefulWidget，它的状态中也会保存当前滚动位置，所以，只要Scrollable Widget本身没有被从树上detach掉，那么其State就不会销毁(dispose)，滚动位置就不会丢失。只有当Widget发生结构变化，导致Scrollable Widget的State销毁或重新构建时才会丢失状态，这种情况就需要显式指定PageStorageKey，通过PageStorage来存储滚动位置，一个典型的场景是在使用TabBarView时，在Tab发生切换时，Tab页中的Scrollable Widget的State就会销毁，这时如果想恢复滚动位置就需要指定PageStorageKey。 ScrollPosition 一个ScrollController可以同时被多个Scrollable Widget使用，ScrollController会为每一个Scrollable Widget创建一个ScrollPosition对象，这些ScrollPosition保存在ScrollController的positions属性中（List）。ScrollPosition是真正保存滑动位置信息的对象，offset只是一个便捷属性： double get offset => position.pixels; 一个ScrollController虽然可以对应多个Scrollable Widget，但是有一些操作，如读取滚动位置offset，则需要一对一，但是我们仍然可以在一对多的情况下，通过其它方法读取滚动位置，举个例子，假设一个ScrollController同时被两个Scrollable Widget使用，那么我们可以通过如下方式分别读取他们的滚动位置： ... controller.positions.elementAt(0).pixels controller.positions.elementAt(1).pixels ... 我们可以通过controller.positions.length来确定controller被几个Scrollable Widget使用。 方法 ScrollPosition有两个常用方法：animateTo() 和 jumpTo()，它们是真正来控制跳转滚动位置的方法，ScrollController的这两个同名方法，内部最终都会调用ScrollPosition的。 ScrollController控制原理 我们来介绍一下ScrollController的另外三个方法： ScrollPosition createScrollPosition( ScrollPhysics physics, ScrollContext context, ScrollPosition oldPosition); void attach(ScrollPosition position) ; void detach(ScrollPosition position) ; 当ScrollController和Scrollable Widget关联时，Scrollable Widget首先会调用ScrollController的createScrollPosition()方法来创建一个ScrollPosition来存储滚动位置信息，接着，Scrollable Widget会调用attach()方法，将创建的ScrollPosition添加到ScrollController的positions属性中，这一步称为“注册位置”，只有注册后animateTo() 和 jumpTo()才可以被调用。当Scrollable Widget销毁时，会调用ScrollController的detach()方法，将其ScrollPosition对象从ScrollController的positions属性中移除，这一步称为“注销位置”，注销后animateTo() 和 jumpTo() 将不能再被调用。 需要注意的是，ScrollController的animateTo() 和 jumpTo()内部会调用所有ScrollPosition的animateTo() 和 jumpTo()，以实现所有和该ScrollController关联的Scrollable Widget都滚动到指定的位置。 滚动监听 Flutter Widget树中子Widget可以通过发送通知（Notification）与父(包括祖先)Widget通信。父Widget可以通过NotificationListener Widget来监听自己关注的通知，这种通信方式类似于Web开发中浏览器的事件冒泡，我们在Flutter中沿用“冒泡”这个术语。Scrollable Widget在滚动时会发送ScrollNotification类型的通知，ScrollBar正是通过监听滚动通知来实现的。通过NotificationListener监听滚动事件和通过ScrollController有两个主要的不同： 通过NotificationListener可以在从Scrollable Widget到Widget树根之间任意位置都能监听。而ScrollController只能和具体的Scrollable Widget关联后才可以。 收到滚动事件后获得的信息不同；NotificationListener在收到滚动事件时，通知中会携带当前滚动位置和ViewPort的一些信息，而ScrollController只能获取当前滚动位置。 NotificationListener NotificationListener是一个Widget，模板参数T是想监听的通知类型，如果省略，则所有类型通知都会被监听，如果指定特定类型，则只有该类型的通知会被监听。NotificationListener需要一个onNotification回调函数，用于实现监听处理逻辑，该回调可以返回一个布尔值，代表是否阻止该事件继续向上冒泡，如果为true时，则冒泡终止，事件停止向上传播，如果不返回或者返回值为false 时，则冒泡继续。 示例 下面，我们监听ListView的滚动通知，然后显示当前滚动进度百分比： import 'package:flutter/material.dart'; class ScrollNotificationTestRoute extends StatefulWidget { @override _ScrollNotificationTestRouteState createState() => new _ScrollNotificationTestRouteState(); } class _ScrollNotificationTestRouteState extends State { String _progress = \"0%\"; //保存进度百分比 @override Widget build(BuildContext context) { return Scrollbar( //进度条 // 监听滚动通知 child: NotificationListener( onNotification: (ScrollNotification notification) { double progress = notification.metrics.pixels / notification.metrics.maxScrollExtent; //重新构建 setState(() { _progress = \"${(progress * 100).toInt()}%\"; }); print(\"BottomEdge: ${notification.metrics.extentAfter == 0}\"); //return true; //放开此行注释后，进度条将失效 }, child: Stack( alignment: Alignment.center, children: [ ListView.builder( itemCount: 100, itemExtent: 50.0, itemBuilder: (context, index) { return ListTile(title: Text(\"$index\")); } ), CircleAvatar( //显示进度百分比 radius: 30.0, child: Text(_progress), backgroundColor: Colors.black54, ) ], ), ), ); } } 我们看一看运行结果： 在接收到滚动事件时，参数类型为ScrollNotification，它包括一个metrics属性，它的类型是ScrollMetrics，该属性包含当前ViewPort及滚动位置等信息： pixels：当前滚动位置。 maxScrollExtent：最大可滚动长度。 extentBefore：滑出ViewPort顶部的长度；此示例中相当于顶部滑出屏幕上方的列表长度。 extentInside：ViewPort内部长度；此示例中屏幕显示的列表部分的长度。 extentAfter：列表中未滑入ViewPort部分的长度；此示例中列表底部未显示到屏幕范围部分的长度。 atEdge：是否滑到了Scrollable Widget的边界（此示例中相当于列表顶或底部）。 ScrollMetrics还有一些其它属性，读者可以自行查阅API文档。 "},"chapter7/":{"url":"chapter7/","title":"功能型Widgets","keywords":"","body":"功能型Widget简介 功能型Widget指的是不会影响UI布局及外观的Widget，它们通常具有一定的功能，如事件监听、数据存储等，我们之前介绍过的FocusScope（焦点控制）、PageStorage（数据存储）、NotificationListener（事件监听）都属于功能型Widget。由于Widget是Flutter的一等公民，功能型Widget非常多，我们不会去一一介绍，本章中主要介绍几种常用的功能型Widget。 本章目录 导航返回拦截-WillPopScope 数据共享-InheritedWidget 主题-Theme "},"chapter7/willpopscope.html":{"url":"chapter7/willpopscope.html","title":"导航返回拦截-WillPopScope","keywords":"","body":"导航返回拦截WillPopScope 为了避免用户误触返回按钮而导致APP退出，在很多APP中都拦截了用户点击返回键的按钮，当用户在某一个时间段内点击两次时，才会认为用户是要退出（而非误触）。Flutter中可以通过WillPopScope来实现返回按钮拦截，我们看看WillPopScope的默认构造函数： const WillPopScope({ ... @required WillPopCallback onWillPop, @required Widget child }) onWillPop是一个回调函数，当用户点击返回按钮时调用（包括导航返回按钮及Android物理返回按钮），该回调需要返回一个Future对象，如果返回的Future最终值为false时，则当前路由不出栈(不会返回)，最终值为true时，当前路由出栈退出。我们需要提供这个回调来决定是否退出。 示例 为了防止用户误触返回键退出，我们拦截返回事件，当用户在1秒内点击两次返回按钮时，则退出，如果间隔超过1秒则不退出，并重新记时。代码如下： import 'package:flutter/material.dart'; class WillPopScopeTestRoute extends StatefulWidget { @override WillPopScopeTestRouteState createState() { return new WillPopScopeTestRouteState(); } } class WillPopScopeTestRouteState extends State { DateTime _lastPressedAt; //上次点击时间 @override Widget build(BuildContext context) { return new WillPopScope( onWillPop: () async { if (_lastPressedAt == null || DateTime.now().difference(_lastPressedAt) > Duration(seconds: 1)) { //两次点击间隔超过1秒则重新计时 _lastPressedAt = DateTime.now(); return false; } return true; }, child: Container( alignment: Alignment.center, child: Text(\"1秒内连续按两次返回键退出\"), ) ); } } 读者可以运行示例看看效果。 "},"chapter7/inherited_widget.html":{"url":"chapter7/inherited_widget.html","title":"数据共享-InheritedWidget","keywords":"","body":"InheritedWidget InheritedWidget是Flutter中非常重要的一个功能型Widget，它可以高效的将数据在Widget树中向下传递、共享，这在一些需要在Widget树中共享数据的场景中非常方便，如Flutter中，正是通过InheritedWidget来共享应用主题(Theme)和Locale(当前语言环境)信息的。 InheritedWidget和React中的context功能类似，和逐级传递数据相比，它们能实现组件跨级传递数据。InheritedWidget的在Widget树中数据传递方向是从上到下的，这和Notification的传递方向正好相反。 didChangeDependencies 在介绍StatefulWidget时，我们提到State对象有一个回调didChangeDependencies，它会在“依赖”发生变化时被Flutter Framework调用。而这个“依赖”指的就是是否使用了父widget中InheritedWidget的数据，如果使用了，则代表有依赖，如果没有使用则代表没有依赖。这种机制可以使子组件在所依赖的主题、locale等发生变化时有机会来做一些事情。 我们看一下之前“计数器”示例应用程序的InheritedWidget版本，需要说明的是，本例主要是为了演示InheritedWidget的功能特性，并不是计数器的推荐实现方式。 首先，我们通过继承InheritedWidget，将当前计数器点击次数保存在ShareDataWidget的data属性中： class ShareDataWidget extends InheritedWidget { ShareDataWidget({ @required this.data, Widget child }) :super(child: child); int data; //需要在子树中共享的数据，保存点击次数 //定义一个便捷方法，方便子树中的widget获取共享数据 static ShareDataWidget of(BuildContext context) { return context.inheritFromWidgetOfExactType(ShareDataWidget); } //该回调决定当data发生变化时，是否通知子树中依赖data的Widget @override bool updateShouldNotify(ShareDataWidget old) { //如果返回false，则子树中依赖(build函数中有调用)本widget //的子widget的`state.didChangeDependencies`会被调用 return old.data != data; } } 然后我们实现一个子widget _TestWidget，在其build方法中引用ShareDataWidget中的数据；同时，在其didChangeDependencies() 回调中打印日志： class _TestWidget extends StatefulWidget { @override __TestWidgetState createState() => new __TestWidgetState(); } class __TestWidgetState extends State { @override Widget build(BuildContext context) { //使用InheritedWidget中的共享数据 return Text(ShareDataWidget .of(context) .data .toString()); } @override void didChangeDependencies() { super.didChangeDependencies(); //父或祖先widget中的InheritedWidget改变(updateShouldNotify返回true)时会被调用。 //如果build中没有依赖InheritedWidget，则此回调不会被调用。 print(\"Dependencies change\"); } } 最后，我们创建一个按钮，每点击一次，就将ShareDataWidget的值自增： class InheritedWidgetTestRoute extends StatefulWidget { @override _InheritedWidgetTestRouteState createState() => new _InheritedWidgetTestRouteState(); } class _InheritedWidgetTestRouteState extends State { int count = 0; @override Widget build(BuildContext context) { return Center( child: ShareDataWidget( //使用ShareDataWidget data: count, child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ Padding( padding: const EdgeInsets.only(bottom: 20.0), child: _TestWidget(),//子widget中依赖ShareDataWidget ), RaisedButton( child: Text(\"Increment\"), //每点击一次，将count自增，然后重新build,ShareDataWidget的data将被更新 onPressed: () => setState(() => ++count), ) ], ), ), ); } } 运行后界面如下： 每点击一次按钮，计数器就会自增，控制台就会打印一句日志： I/flutter ( 8513): Dependencies change 可见依赖发生变化后，其didChangeDependencies()会被调用。但是读者要注意，如果_TestWidget的build方法中没有使用ShareDataWidget的数据，那么它的didChangeDependencies()将不会被调用，因为它并没有依赖ShareDataWidget。 思考题：Flutter framework是怎么知道子widget有没有依赖InheritedWidget的？ 应该在didChangeDependencies()中做什么？ 一般来说，子widget很少会重写此方法，因为在依赖改变后framework也都会调用build()方法。但是，如果你需要在依赖改变后执行一些昂贵的操作，比如网络请求，这时最好的方式就是在此方法中执行，这样可以避免每次build()都执行这些昂贵操作。 "},"chapter7/theme.html":{"url":"chapter7/theme.html","title":"主题-Theme","keywords":"","body":"主题 Theme Widget可以为Material APP定义主题数据（ThemeData），Material组件库里很多Widget都使用了主题数据，如导航栏颜色、标题字体、Icon样式等。Theme内会使用InheritedWidget来为其子树Widget共享样式数据。 ThemeData ThemeData是Material Design Widget库的主题数据，Material库的Widget需要遵守相应的设计规范，而这些规范可自定义部分都定义在ThemeData，所以我们可以通过ThemeData来自定义应用主题。我们可以通过Theme.of方法来获取当前的ThemeData。 注意，Material Design 设计规范中有些是不能自定义的，如导航栏高度，ThemeData只包含了可自定义部分。 我们看看ThemeData部分数据： ThemeData({ Brightness brightness, //深色还是浅色 MaterialColor primarySwatch, //主题颜色样本，见下面介绍 Color primaryColor, //主色，决定导航栏颜色 Color accentColor, //次级色，决定大多数Widget的颜色，如进度条、开关等。 Color cardColor, //卡片颜色 Color dividerColor, //分割线颜色 ButtonThemeData buttonTheme, //按钮主题 Color cursorColor, //输入框光标颜色 Color dialogBackgroundColor,//对话框背景颜色 String fontFamily, //文字字体 TextTheme textTheme,// 字体主题，包括标题、body等文字样式 IconThemeData iconTheme, // Icon的默认样式 TargetPlatform platform, //指定平台，应用特定平台控件风格 ... }) 上面只是ThemeData的一小部分属性，完整列表读者可以查看SDK定义。上面属性中需要说明的是primarySwatch，它是主题颜色的一个\"样本\"，通过这个样本可以在一些条件下生成一些其它的属性，例如，如果没有指定primaryColor，并且当前主题不是深色主题，那么primaryColor就会默认为primarySwatch指定的颜色，还有一些相似的属性如accentColor 、indicatorColor等也会受primarySwatch影响。 示例 我们实现一个路由换肤功能： class ThemeTestRoute extends StatefulWidget { @override _ThemeTestRouteState createState() => new _ThemeTestRouteState(); } class _ThemeTestRouteState extends State { Color _themeColor = Colors.teal; //当前路由主题色 @override Widget build(BuildContext context) { ThemeData themeData = Theme.of(context); return Theme( data: ThemeData( primarySwatch: _themeColor, //用于导航栏、FloatingActionButton的背景色等 iconTheme: IconThemeData(color: _themeColor) //用于Icon颜色 ), child: Scaffold( appBar: AppBar(title: Text(\"主题测试\")), body: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ //第一行Icon使用主题中的iconTheme Row( mainAxisAlignment: MainAxisAlignment.center, children: [ Icon(Icons.favorite), Icon(Icons.airport_shuttle), Text(\" 颜色跟随主题\") ] ), //为第二行Icon自定义颜色（固定为黑色) Theme( data: themeData.copyWith( iconTheme: themeData.iconTheme.copyWith( color: Colors.black ), ), child: Row( mainAxisAlignment: MainAxisAlignment.center, children: [ Icon(Icons.favorite), Icon(Icons.airport_shuttle), Text(\" 颜色固定黑色\") ] ), ), ], ), floatingActionButton: FloatingActionButton( onPressed: () => //切换主题 setState(() => _themeColor = _themeColor == Colors.teal ? Colors.blue : Colors.teal ), child: Icon(Icons.palette) ), ), ); } } 运行后点击右下角悬浮按钮则可以切换主题： 需要注意的有三点： 可以通过局部主题覆盖全局主题，正如代码中通过Theme为第二行图标指定固定颜色（黑色）一样，这是一种常用的技巧，Flutter中会经常使用这种方法来自定义子树主题。那么为什么局部主题可以覆盖全局主题？这主要是因为Widget中使用主题样式时是通过Theme.of(BuildContext context)来获取的，我们看看其简化后的代码： static ThemeData of(BuildContext context, { bool shadowThemeOnly = false }) { // 简化代码，并非源码 return context.inheritFromWidgetOfExactType(_InheritedTheme) } context.inheritFromWidgetOfExactType 会在widget树中从当前位置向上查找第一个类型为_InheritedTheme的Widget。所以当局部使用Theme后，其子树中Theme.of()找到的第一个_InheritedTheme便是该Theme的。 本示例是对单个路由换肤，如果相对整个应用换肤，可以去修改MaterialApp的theme属性。 "},"chapter8/":{"url":"chapter8/","title":"事件处理与通知","keywords":"","body":"事件处理与通知 Flutter中的手势系统有两个独立的层。第一层为原始指针(pointer)事件，它描述了屏幕上指针（例如，触摸、鼠标和触控笔）的位置和移动。 第二层为手势，描述由一个或多个指针移动组成的语义动作，如拖动、缩放、双击等。本章将先分别介绍如何处理这两种事件，最后再介绍一下Flutter中重要的Notification机制。 本章目录 原始指针事件处理 手势识别 全局事件总线 通知Notification "},"chapter8/listener.html":{"url":"chapter8/listener.html","title":"原始指针事件处理","keywords":"","body":"Pointer事件处理 本节先来介绍一下原始指针事件(Pointer Event，在移动设备上通常为触摸事件)，下一节再介绍手势处理。 在移动端，各个平台或UI系统的原始指针事件模型基本都是一致，即：一次完整的事件分为三个阶段：手指按下、手指移动、和手指抬起，而更高级别的手势（如点击、双击、拖动等）都是基于这些原始事件的。 当指针按下时，Flutter会对应用程序执行命中测试(Hit Test)，以确定指针与屏幕接触的位置存在哪些widget， 指针按下事件（以及该指针的后续事件）然后被分发到由命中测试发现的最内部的widget，然后从那里开始，事件会在widget树中向上冒泡，这些事件会从最内部的widget被分发到到widget根的路径上的所有Widget，这和Web开发中浏览器的事件冒泡机制相似， 但是Flutter中没有机制取消或停止冒泡过程，而浏览器的冒泡是可以停止的。注意，只有通过命中测试的Widget才能触发事件。 Flutter中可以使用Listener widget来监听原始触摸事件，它也是一个功能性widget。 Listener({ Key key, this.onPointerDown, //手指按下回调 this.onPointerMove, //手指移动回调 this.onPointerUp,//手指抬起回调 this.onPointerCancel,//触摸事件取消回调 this.behavior = HitTestBehavior.deferToChild, //在命中测试期间如何表现 Widget child }) 我们先看一个示例，后面再单独讨论一下behavior属性。 ... //定义一个状态，保存当前指针位置 PointerEvent _event; ... Listener( child: Container( alignment: Alignment.center, color: Colors.blue, width: 300.0, height: 150.0, child: Text(_event?.toString()??\"\",style: TextStyle(color: Colors.white)), ), onPointerDown: (PointerDownEvent event) => setState(()=>_event=event), onPointerMove: (PointerMoveEvent event) => setState(()=>_event=event), onPointerUp: (PointerUpEvent event) => setState(()=>_event=event), ), 手指在蓝色矩形区域内移动即可看到当前指针偏移，当触发指针事件时，参数PointerDownEvent、PointerMoveEvent、PointerUpEvent都是PointerEvent的一个子类，PointerEvent类中包括当前指针的一些信息，如： position：它是鼠标相对于当对于全局坐标的偏移。 delta：两次指针移动事件（PointerMoveEvent）的距离。 pressure：按压力度，如果手机屏幕支持压力传感器(如iPhone的3D Touch)，此属性会更有意义，如果手机不支持，则始终为1。 orientation：指针移动方向，是一个角度值。 上面只是PointerEvent一些常用属性，除了这些它还有很多属性，读者可以查看API文档。 现在，我们重点来介绍一下behavior属性，它决定子Widget如何响应命中测试，它的值类型为HitTestBehavior，这是一个枚举类，有三个枚举值： deferToChild：子widget会一个接一个的进行命中测试，如果子Widget中有测试通过的，则当前Widget通过，这就意味着，如果指针事件作用于子Widget上时，其父(祖先)Widget也肯定可以收到该事件。 opaque：在命中测试时，将当前Widget当成不透明处理(即使本身是透明的)，最终的效果相当于当前Widget的整个区域都是点击区域。举个例子： Listener( child: ConstrainedBox( constraints: BoxConstraints.tight(Size(300.0, 150.0)), child: Center(child: Text(\"Box A\")), ), //behavior: HitTestBehavior.opaque, onPointerDown: (event) => print(\"down A\") ), 上例中，只有点击文本内容区域才会触发点击事件，如果我们想让整个300×150的矩形区域都能点击我们可以将behavior设为HitTestBehavior.opaque。注意，该属性并不能用于在Widget树中拦截（忽略）事件，它只是决定命中测试时的Widget大小。 translucent：当点击Widget透明区域时，可以对自身边界内及底部可视区域都进行命中测试，这意味着点击顶部widget透明区域时，顶部widget和底部widget都可以接收到事件，例如： Stack( children: [ Listener( child: ConstrainedBox( constraints: BoxConstraints.tight(Size(300.0, 200.0)), child: DecoratedBox( decoration: BoxDecoration(color: Colors.blue)), ), onPointerDown: (event) => print(\"down0\"), ), Listener( child: ConstrainedBox( constraints: BoxConstraints.tight(Size(200.0, 100.0)), child: Center(child: Text(\"左上角200*100范围内非文本区域点击\")), ), onPointerDown: (event) => print(\"down1\"), //behavior: HitTestBehavior.translucent, //放开此行注释后可以\"点透\" ) ], ) 上例中，当注释掉最后一行代码后，在左上角200*100范围内非文本区域点击时（顶部Widget透明区域），控制台只会打印“down0”，也就是说顶部widget没有接收到事件，而只有底部接收到了。当放开注释后，再点击时顶部和底部都会接收到事件，此时会打印： I/flutter ( 3039): down1 I/flutter ( 3039): down0 如果behavior值改为HitTestBehavior.opaque，则只会打印\"down1\"。 忽略PointerEvent 假如我们不想让某个子树响应PointerEvent的话，我们可以使用IgnorePointer和AbsorbPointer，这两个Widget都能阻止子树接收指针事件，不同之处在于AbsorbPointer本身会参与命中测试，而IgnorePointer本身不会参与，这就意味着AbsorbPointer本身是可以接收指针事件的(但其子树不行)，而IgnorePointer不可以。一个简单的例子如下： Listener( child: AbsorbPointer( child: Listener( child: Container( color: Colors.red, width: 200.0, height: 100.0, ), onPointerDown: (event)=>print(\"in\"), ), ), onPointerDown: (event)=>print(\"up\"), ) 点击Container时，由于它在AbsorbPointer的子树上，所以不会响应指针事件，所以日志不会输出\"in\"，但AbsorbPointer本身是可以接收指针事件的，所以会输出\"up\"。如果将AbsorbPointer换成IgnorePointer，那么两个都不会输出。 "},"chapter8/gesture.html":{"url":"chapter8/gesture.html","title":"手势识别","keywords":"","body":"手势识别GestureDetector GestureDetector是一个用于手势识别的功能性Widget，我们通过它可以来识别各种手势，它是指针事件的语义化封装，接下来我们详细介绍一下各种手势识别： 点击、双击、长按 我们通过GestureDetector对Container进行手势识别，触发相应事件后，在Container上显示事件名，为了增大点击区域，将Container设置为200×100，代码如下： class GestureDetectorTestRoute extends StatefulWidget { @override _GestureDetectorTestRouteState createState() => new _GestureDetectorTestRouteState(); } class _GestureDetectorTestRouteState extends State { String _operation = \"No Gesture detected!\"; //保存事件名 @override Widget build(BuildContext context) { return Center( child: GestureDetector( child: Container( alignment: Alignment.center, color: Colors.blue, width: 200.0, height: 100.0, child: Text(_operation, style: TextStyle(color: Colors.white), ), ), onTap: () => updateText(\"Tap\"),//点击 onDoubleTap: () => updateText(\"DoubleTap\"), //双击 onLongPress: () => updateText(\"LongPress\"), //长按 ), ); } void updateText(String text) { //更新显示的事件名 setState(() { _operation = text; }); } } 运行效果： 注意： 当同时监听onTap和onDoubleTap事件时，当用户触发tap事件时，会有200毫秒左右的延时，这是因为当用户点击完之后很可能会再次点击以触发双击事件，所以GestureDetector会等一断时间来确定是否为双击事件。如果用户只监听了onTap（没有监听onDoubleTap）事件时，则没有延时。 拖动、滑动 一次完整的手势过程是指用户手指按下到抬起的整个过程，期间，用户按下手指后可能会移动，也可能不会移动。GestureDetector对于拖动和滑动事件是没有区分的，他们本质上是一样的。GestureDetector会将要监听的widget的原点（左上角）作为本次手势的原点，当用户在监听的widget上按下手指时，手势识别就会开始。下面我们看一个拖动圆形字母A的示例： class _Drag extends StatefulWidget { @override _DragState createState() => new _DragState(); } class _DragState extends State with SingleTickerProviderStateMixin { double _top = 0.0; //距顶部的偏移 double _left = 0.0;//距左边的偏移 @override Widget build(BuildContext context) { return Stack( children: [ Positioned( top: _top, left: _left, child: GestureDetector( child: CircleAvatar(child: Text(\"A\")), //手指按下时会触发此回调 onPanDown: (DragDownDetails e) { //打印手指按下的位置(相对于屏幕) print(\"用户手指按下：${e.globalPosition}\"); }, //手指滑动时会触发此回调 onPanUpdate: (DragUpdateDetails e) { //用户手指滑动时，更新偏移，重新构建 setState(() { _left += e.delta.dx; _top += e.delta.dy; }); }, onPanEnd: (DragEndDetails e){ //打印滑动结束时在x、y轴上的速度 print(e.velocity); }, ), ) ], ); } } 运行后，就可以在任意方向拖动了： 日志： I/flutter ( 8513): 用户手指按下：Offset(26.3, 101.8) I/flutter ( 8513): Velocity(235.5, 125.8) 代码解释： DragDownDetails.globalPosition：当用户按下时，此属性为用户按下的位置相对于屏幕(而非父widget)原点(左上角)的偏移。 DragUpdateDetails.delta：当用户在屏幕上滑动时，会触发多次Update事件，delta指一次Update事件的滑动的偏移量。 DragEndDetails.velocity：该属性代表用户抬起手指时的滑动速度(包含x、y两个轴的），示例中并没有处理手指抬起时的速度，常见的效果是根据用户抬起手指时的速度做一个减速动画。 单一方向拖动 在本示例中，是可以朝任意方向拖动的，但是在很多场景，我们只需要沿一个方向来拖动，如一个垂直方向的列表，GestureDetector可以只识别特定方向的手势事件，我们将上面的例子改为只能沿垂直方向拖动： class _DragVertical extends StatefulWidget { @override _DragVerticalState createState() => new _DragVerticalState(); } class _DragVerticalState extends State { double _top = 0.0; @override Widget build(BuildContext context) { return Stack( children: [ Positioned( top: _top, child: GestureDetector( child: CircleAvatar(child: Text(\"A\")), //垂直方向拖动事件 onVerticalDragUpdate: (DragUpdateDetails details) { setState(() { _top += details.delta.dy; }); } ), ) ], ); } } 这样就只能在垂直方向拖动了，如果只想在水平方向滑动同理。 缩放 GestureDetector可以监听缩放事件，下面示例演示了一个简单的图片缩放效果： class _ScaleTestRouteState extends State { double _width = 200.0; //通过修改图片宽度来达到缩放效果 @override Widget build(BuildContext context) { return Center( child: GestureDetector( //指定宽度，高度自适应 child: Image.asset(\"./images/sea.png\", width: _width), onScaleUpdate: (ScaleUpdateDetails details) { setState(() { //缩放倍数在0.8到10倍之间 _width=200*details.scale.clamp(.8, 10.0); }); }, ), ); } } 运行效果： 现在在图片上双指张开、收缩就可以放大、缩小图片。本示例比较简单，实际中我们通常还需要一些其它功能，如双击放大或缩小一定倍数、双指张开离开屏幕时执行一个减速放大动画等，我们将在后面“动画”一章中实现一个完整的缩放Widget。 GestureRecognizer GestureDetector内部是使用一个或多个GestureRecognizer来识别各种手势的，而GestureRecognizer的作用就是通过Listener来将原始指针事件转换为语义手势，GestureDetector直接可以接收一个子Widget。GestureRecognizer是一个抽象类，一种手势的识别器对应一个GestureRecognizer的子类，Flutter实现了丰富的手势识别器，我们可以直接使用。 示例 假设我们要给一段富文本（RichText）的不同部分分别添加点击事件处理器，但是TextSpan并不是一个Widget，这时我们不能用GestureDetector，但TextSpan有一个recognizer属性，它可以接收一个GestureRecognizer，假设我们在点击时给文本变色: import 'package:flutter/gestures.dart'; class _GestureRecognizerTestRouteState extends State { TapGestureRecognizer _tapGestureRecognizer = new TapGestureRecognizer(); bool _toggle = false; //变色开关 @override void dispose() { //用到GestureRecognizer的话一定要调用其dispose方法释放资源 _tapGestureRecognizer.dispose(); super.dispose(); } @override Widget build(BuildContext context) { return Center( child: Text.rich( TextSpan( children: [ TextSpan(text: \"你好世界\"), TextSpan( text: \"点我变色\", style: TextStyle( fontSize: 30.0, color: _toggle ? Colors.blue : Colors.red ), recognizer: _tapGestureRecognizer ..onTap = () { setState(() { _toggle = !_toggle; }); }, ), TextSpan(text: \"你好世界\"), ] ) ), ); } } 运行效果： 注意：使用GestureRecognizer后一定要调用其dispose()方法来释放资源（主要是取消内部的计时器）。 手势竞争与冲突 竞争 如果在上例中我们同时监听水平和垂直方向的拖动事件，那么我们斜着拖动时哪个方向会生效？实际上取决于第一次移动时两个轴上的位移分量，哪个轴的大，哪个轴在本次滑动事件竞争中就胜出。实际上Flutter中的手势识别引入了一个Arena的概念，Arena直译为“竞技场”的意思，每一个手势识别器（GestureRecognizer）都是一个“竞争者”（GestureArenaMember），当发生滑动事件时，他们都要在“竞技场”去竞争本次事件的处理权，而最终只有一个“竞争者”会胜出(win)。例如，假设有一个ListView，它的第一个子Widget也是ListView，如果现在滑动这个子ListView，父ListView会动吗？答案是否定的，这时只有子Widget会动，因为这时子Widget会胜出而获得滑动事件的处理权。 示例 我们以拖动手势为例，同时识别水平和垂直方向的拖动手势，当用户按下手指时就会触发竞争（水平方向和垂直方向），一旦某个方向“获胜”，则直到当次拖动手势结束都会沿着该方向移动。代码如下： import 'package:flutter/material.dart'; class BothDirectionTestRoute extends StatefulWidget { @override BothDirectionTestRouteState createState() => new BothDirectionTestRouteState(); } class BothDirectionTestRouteState extends State { double _top = 0.0; double _left = 0.0; @override Widget build(BuildContext context) { return Stack( children: [ Positioned( top: _top, left: _left, child: GestureDetector( child: CircleAvatar(child: Text(\"A\")), //垂直方向拖动事件 onVerticalDragUpdate: (DragUpdateDetails details) { setState(() { _top += details.delta.dy; }); }, onHorizontalDragUpdate: (DragUpdateDetails details) { setState(() { _left += details.delta.dx; }); }, ), ) ], ); } } 此示例运行后，每次拖动只会沿一个方向移动（水平或垂直），而竞争发生在手指按下后首次移动（move）时，此例中具体的“获胜”条件是：首次移动时的位移在水平和垂直方向上的分量大的一个获胜。 手势冲突 由于手势竞争最终只有一个胜出者，所以，当有多个手势识别器时，可能会产生冲突。假设有一个widget，它可以左右拖动，现在我们也想检测在它上面手指按下和抬起的事件，代码如下： class GestureConflictTestRouteState extends State { double _left = 0.0; @override Widget build(BuildContext context) { return Stack( children: [ Positioned( left: _left, child: GestureDetector( child: CircleAvatar(child: Text(\"A\")), //要拖动和点击的widget onHorizontalDragUpdate: (DragUpdateDetails details) { setState(() { _left += details.delta.dx; }); }, onHorizontalDragEnd: (details){ print(\"onHorizontalDragEnd\"); }, onTapDown: (details){ print(\"down\"); }, onTapUp: (details){ print(\"up\"); }, ), ) ], ); } } 现在我们按住圆形“A”拖动然后抬起手指，控制台日志如下: I/flutter (17539): down I/flutter (17539): onHorizontalDragEnd 我们发现没有打印\"up\"，这是因为在拖动时，刚开始按下手指时在没有移动时，拖动手势还没有完整的语义，此时TapDown手势胜出(win)，此时打印\"down\"，而拖动时，拖动手势会胜出，当手指抬起时，onHorizontalDragEnd 和 onTapUp发生了冲突，但是因为是在拖动的语义中，所以onHorizontalDragEnd胜出，所以就会打印 “onHorizontalDragEnd”。如果我们的代码逻辑中，对于手指按下和抬起是强依赖的，比如在一个轮播图组件中，我们希望手指按下时，暂停轮播，而抬起时恢复轮播，但是由于轮播图组件中本身可能已经处理了拖动手势（支持手动滑动切换），甚至可能也支持了缩放手势，这时我们如果在外部再用onTapDown、onTapUp来监听的话是不行的。这时我们应该怎么做？其实很简单，通过Listener监听原始指针事件就行： Positioned( top:80.0, left: _leftB, child: Listener( onPointerDown: (details) { print(\"down\"); }, onPointerUp: (details) { //会触发 print(\"up\"); }, child: GestureDetector( child: CircleAvatar(child: Text(\"B\")), onHorizontalDragUpdate: (DragUpdateDetails details) { setState(() { _leftB += details.delta.dx; }); }, onHorizontalDragEnd: (details) { print(\"onHorizontalDragEnd\"); }, ), ), ) 总结： 手势冲突只是手势级别的，而手势是对原始指针的语义化的识别，所以在遇到复杂的冲突场景时，都可以通过Listener直接识别原始指针事件来解决冲突。 "},"chapter8/eventbus.html":{"url":"chapter8/eventbus.html","title":"全局事件总线","keywords":"","body":"事件总线 在APP中，我们经常会需要一个广播机制，用以跨页面事件通知，比如一个需要登录的APP中，页面会关注用户登录或注销事件，来进行一些状态更新。这时候，一个事件总线便会非常有用，事件总线通常实现了订阅者模式，订阅者模式包含发布者和订阅者两种角色，可以通过事件总线来触发事件和监听事件，本节我们实现一个简单的全局事件总线，我们使用单例模式，代码如下： //订阅者回调签名 typedef void EventCallback(arg); class EventBus { //私有构造函数 EventBus._internal(); //保存单例 static EventBus _singleton = new EventBus._internal(); //工厂构造函数 factory EventBus()=> _singleton; //保存事件订阅者队列，key:事件名(id)，value: 对应事件的订阅者队列 var _emap = new Map>(); //添加订阅者 void on(eventName, EventCallback f) { if (eventName == null || f == null) return; _emap[eventName] ??= new List(); _emap[eventName].add(f); } //移除订阅者 void off(eventName, [EventCallback f]) { var list = _emap[eventName]; if (eventName == null || list == null) return; if (f == null) { _emap[eventName] = null; } else { list.remove(f); } } //触发事件，事件触发后该事件所有订阅者会被调用 void emit(eventName, [arg]) { var list = _emap[eventName]; if (list == null) return; int len = list.length - 1; //反向遍历，防止在订阅者在回调中移除自身带来的下标错位 for (var i = len; i > -1; --i) { list[i](arg); } } } //定义一个top-level变量，页面引入该文件后可以直接使用bus var bus = new EventBus(); 使用 //页面A中 ... //监听登录事件 bus.on(\"login\", (arg) { // do something }); //登录页B中 ... //登录成功后触发登录事件，页面A中订阅者会被调用 bus.emit(\"login\", userInfo); 注意：Dart中实现单例模式的标准做法就是使用static变量+工厂构造函数的方式，这样就可以保证new EventBus()始终返回都是同一个实例，读者应该理解并掌握这种方法。 事件总线通常用于Widget之间状态共享，但关于Widget之间状态共享也有一些专门的Package如redux，这和web框架Vue/React是一致的。通常情况下事件总线是足以满足业务需求的，如果你决定使用redux的话，一定要想清楚业务是否真的有必要用它，防止“化简为繁”、过度设计。 "},"chapter8/notification.html":{"url":"chapter8/notification.html","title":"通知Notification","keywords":"","body":"Notification Notification是Flutter中一个重要的机制，在Widget树中，每一个节点都可以分发通知，通知会沿着当前节点（context）向上传递，所有父节点都可以通过NotificationListener来监听通知，Flutter中称这种通知由子向父的传递为“通知冒泡”（Notification Bubbling），这个和用户触摸事件冒泡是相似的，但有一点不同：通知冒泡可以中止，但用户触摸事件不行。 Flutter中很多地方使用了通知，如可滚动(Scrollable) Widget中滑动时就会分发ScrollNotification，而Scrollbar正是通过监听ScrollNotification来确定滚动条位置的。除了ScrollNotification，Flutter中还有SizeChangedLayoutNotification、KeepAliveNotification 、LayoutChangedNotification等。下面是一个监听Scrollable Widget滚动通知的例子： NotificationListener( onNotification: (notification){ //print(notification); switch (notification.runtimeType){ case ScrollStartNotification: print(\"开始滚动\"); break; case ScrollUpdateNotification: print(\"正在滚动\"); break; case ScrollEndNotification: print(\"滚动停止\"); break; case OverscrollNotification: print(\"滚动到边界\"); break; } }, child: ListView.builder( itemCount: 100, itemBuilder: (context, index) { return ListTile(title: Text(\"$index\"),); } ), ); 上例中的滚动通知如ScrollStartNotification、ScrollUpdateNotification等都是继承自ScrollNotification类，不同类型的通知子类会包含不同的信息，比如ScrollUpdateNotification有一个scrollDelta属性，它记录了移动的位移，其它通知属性读者可以自己查看SDK文档。 自定义通知 除了Flutter内部通知，我们也可以自定义通知，下面我们看看如何实现自定义通知： 定义一个通知类，要继承自Notification类； class MyNotification extends Notification { MyNotification(this.msg); final String msg; } 分发通知。 Notification有一个dispatch(context)方法，它是用于分发通知的，我们说过context实际上就是操作Element的一个接口，它与Element树上的节点是对应的，通知会从context对应的Element节点向上冒泡。 下面我们看一个完整的例子： class NotificationRoute extends StatefulWidget { @override NotificationRouteState createState() { return new NotificationRouteState(); } } class NotificationRouteState extends State { String _msg=\"\"; @override Widget build(BuildContext context) { //监听通知 return NotificationListener( onNotification: (notification) { setState(() { _msg+=notification.msg+\" \"; }); }, child: Center( child: Column( mainAxisSize: MainAxisSize.min, children: [ // RaisedButton( // onPressed: () => MyNotification(\"Hi\").dispatch(context), // child: Text(\"Send Notification\"), // ), Builder( builder: (context) { return RaisedButton( //按钮点击时分发通知 onPressed: () => MyNotification(\"Hi\").dispatch(context), child: Text(\"Send Notification\"), ); }, ), Text(_msg) ], ), ), ); } } class MyNotification extends Notification { MyNotification(this.msg); final String msg; } 上面代码中，我们每点一次按钮就会分发一个MyNotification类型的通知，我们在Widget根上监听通知，收到通知后我们将通知通过Text显示在屏幕上。 注意：代码中注释的部分是不能正常工作的，因为这个context是根Context，而NotificationListener是监听的子树，所以我们通过Builder来构建RaisedButton，来获得按钮位置的context。 运行效果如下： "},"chapter9/":{"url":"chapter9/","title":"动画","keywords":"","body":"简介 精心设计的动画会让用户界面感觉更直观、流畅，能改善用户体验。 Flutter可以轻松实现各种动画类型，对于许多widget，特别是Material Design widgets，都带有在其设计规范中定义的标准动画效果(但也可以自定义这些效果)。本章将详细介绍Flutter的动画系统，并会通过几个小实例来演示，以帮助开发者迅速理解并掌握动画的开发流程与原理。 本章目录 Flutter动画简介 动画结构 自定义路由过渡动画 Hero动画 交错动画 "},"chapter9/intro.html":{"url":"chapter9/intro.html","title":"Flutter动画简介","keywords":"","body":"动画 在任何系统的UI框架中，动画实现的原理都是相同的，即：在一段时间内，快速地多次改变UI外观，由于人眼会产生视觉暂留，最终看到的就是一个“连续”的动画，这和电影的原理是一样的，而UI的一次改变称为一个动画帧，对应一次屏幕刷新，而决定动画流畅度的一个重要指标就是帧率FPS（Frame Per Second），指每秒的动画帧数。很明显，帧率越高则动画就会越流畅。一般情况下，对于人眼来说，动画帧率超过16FPS，就比较流畅了，超过32FPS就会非常的细腻平滑，而超过32FPS基本就感受不到差别了。由于动画的每一帧都是要改变UI输出，所以在一个时间段内连续的改变UI输出是比较耗资源的，对设备的软硬件系统要求都较高，所以在UI系统中，动画的平均帧率是重要的性能指标，而在Flutter中，理想情况下是可以实现60FPS的，这和原生应用动画基本是持平的。 Flutter中动画抽象 为了方便开发者创建动画，不同的UI系统对动画都进行了一些抽象，比如在Android中可以通过XML来描述一个动画然后设置给View。Flutter中也对动画进行了抽象，主要涉及Tween、Animation、Curve、Controller这些角色。 Animation Animation对象本身和UI渲染没有任何关系。Animation是一个抽象类，它用于保存动画的插值和状态；其中一个比较常用的Animation类是Animation。Animation对象是一个在一段时间内依次生成一个区间(Tween)之间值的类。Animation对象的输出值可以是线性的、曲线的、一个步进函数或者任何其他曲线函数。 根据Animation对象的控制方式，动画可以反向运行，甚至可以在中间切换方向。Animation还可以生成除double之外的其他类型值，如：Animation\\ 或 Animation\\。可以通过Animation对象的value属性获取动画的当前值。 动画通知 我们可以通过Animation来监听动画的帧和状态变化： addListener()可以给Animation添加帧监听器，在每一帧都会被调用。帧监听器中最常见的行为是改变状态后调用setState()来触发UI重建。 addStatusListener()可以给Animation添加“动画状态改变”监听器；动画开始、结束、正向或反向（见AnimationStatus定义）时会调用StatusListener。 在后面的章节中我们将会举例说明。 Curve 动画过程可以是匀速的、加速的或者先加速后减速等。Flutter中通过Curve（曲线）来描述动画过程，Curve可以是线性的(Curves.linear)，也可以是非线性的。 CurvedAnimation 将动画过程定义为一个非线性曲线. final CurvedAnimation curve = new CurvedAnimation(parent: controller, curve: Curves.easeIn); 注: Curves 类类定义了许多常用的曲线，也可以创建自己的，例如： class ShakeCurve extends Curve { @override double transform(double t) { return math.sin(t * math.PI * 2); } } CurvedAnimation和AnimationController（下面介绍）都是Animation类型。CurvedAnimation可以通过包装AnimationController和Curve生成一个新的动画对象 。 AnimationController AnimationController用于控制动画，它包含动画的启动forward()、停止stop() 、反向播放 reverse()等方法。AnimationController会在动画的每一帧，就会生成一个新的值。默认情况下，AnimationController在给定的时间段内线性的生成从0.0到1.0（默认区间）的数字。 例如，下面代码创建一个Animation对象，但不会启动它运行： final AnimationController controller = new AnimationController( duration: const Duration(milliseconds: 2000), vsync: this); AnimationController生成数字的区间可以通过lowerBound和upperBound来指定，如： final AnimationController controller = new AnimationController( duration: const Duration(milliseconds: 2000), lowerBound: 10.0, upperBound: 20.0, vsync: this ); AnimationController派生自Animation，因此可以在需要Animation对象的任何地方使用。 但是，AnimationController具有控制动画的其他方法，例如forward()方法可以启动动画。数字的产生与屏幕刷新有关，因此每秒钟通常会产生60个数字(即60fps)，在动画的每一帧，生成新的数字后，每个Animation对象会调用其Listener对象回调，等动画状态发生改变时（如动画结束）会调用StatusListeners监听器。 duration表示动画执行的时长，通过它我们可以控制动画的速度。 注意： 在某些情况下，动画值可能会超出AnimationController的0.0-1.0的范围。例如，fling()函数允许您提供速度(velocity)、力量(force)等，因此可以在0.0到1.0范围之外。 CurvedAnimation生成的值也可以超出0.0到1.0的范围。根据选择的曲线，CurvedAnimation的输出可以具有比输入更大的范围。例如，Curves.elasticIn等弹性曲线会生成大于或小于默认范围的值。 Ticker 当创建一个AnimationController时，需要传递一个vsync参数，它接收一个TickerProvider类型的对象，它的主要职责是创建Ticker，定义如下： abstract class TickerProvider { //通过一个回调创建一个Ticker Ticker createTicker(TickerCallback onTick); } Flutter应用在启动时都会绑定一个SchedulerBinding，通过SchedulerBinding可以给每一次屏幕刷新添加回调，而Ticker就是通过SchedulerBinding来添加屏幕刷新回调，这样一来，每次屏幕刷新都会调用TickerCallback。使用Ticker(而不是Timer)来驱动动画会防止屏幕外动画（动画的UI不在当前屏幕时，如锁屏时）消耗不必要的资源，因为Flutter中屏幕刷新时会通知到绑定的SchedulerBinding，而Ticker是受SchedulerBinding驱动的，由于锁屏后屏幕会停止刷新，所以Ticker就不会再触发。 通过将SingleTickerProviderStateMixin添加到State的定义中，然后将State对象作为vsync的值，这在后面的例子中可以见到。 Tween 默认情况下，AnimationController对象值的范围是0.0到1.0。如果我们需要不同的范围或不同的数据类型，则可以使用Tween来配置动画以生成不同的范围或数据类型的值。例如，像下面示例，Tween生成从-200.0到0.0的值： final Tween doubleTween = new Tween(begin: -200.0, end: 0.0); Tween构造函数需要begin和end两个参数。Tween的唯一职责就是定义从输入范围到输出范围的映射。输入范围通常为0.0到1.0，但这不是必须的，我们可以自定义需要的范围。 Tween继承自Animatable，而不是继承自Animation。Animatable与Animation相似，不是必须输出double值。例如，ColorTween指定两种颜色之间的过渡。 final Tween colorTween = new ColorTween(begin: Colors.transparent, end: Colors.black54); Tween对象不存储任何状态，相反，它提供了evaluate(Animation animation)方法，它可以获取动画当前值。 Animation对象的当前值可以通过value()方法取到。evaluate函数还执行一些其它处理，例如分别确保在动画值为0.0和1.0时返回开始和结束状态。 Tween.animate 要使用Tween对象，需要调用其animate()方法，然后传入一个控制器对象。例如，以下代码在500毫秒内生成从0到255的整数值。 final AnimationController controller = new AnimationController( duration: const Duration(milliseconds: 500), vsync: this); Animation alpha = new IntTween(begin: 0, end: 255).animate(controller); 注意animate()返回的是一个Animation，而不是一个Animatable。 以下示例构建了一个控制器、一条曲线和一个Tween： final AnimationController controller = new AnimationController( duration: const Duration(milliseconds: 500), vsync: this); final Animation curve = new CurvedAnimation(parent: controller, curve: Curves.easeOut); Animation alpha = new IntTween(begin: 0, end: 255).animate(curve); "},"chapter9/animation_structure.html":{"url":"chapter9/animation_structure.html","title":"动画结构","keywords":"","body":"动画基本结构 我们通过实现一个图片逐渐放大的示例来演示一下Flutter中动画的基本结构： class ScaleAnimationRoute extends StatefulWidget { @override _ScaleAnimationRouteState createState() => new _ScaleAnimationRouteState(); } //需要继承TickerProvider，如果有多个AnimationController，则应该使用TickerProviderStateMixin。 class _ScaleAnimationRouteState extends State with SingleTickerProviderStateMixin{ Animation animation; AnimationController controller; initState() { super.initState(); controller = new AnimationController( duration: const Duration(seconds: 3), vsync: this); //图片宽高从0变到300 animation = new Tween(begin: 0.0, end: 300.0).animate(controller) ..addListener(() { setState(()=>{}); }); //启动动画(正向执行) controller.forward(); } @override Widget build(BuildContext context) { return new Center( child: Image.asset(\"images/avatar.png\", width: animation.value, height: animation.value ), ); } dispose() { //路由销毁时需要释放动画资源 controller.dispose(); super.dispose(); } } 上面代码中addListener()函数调用了setState()，所以每次动画生成一个新的数字时，当前帧被标记为脏(dirty)，这会导致widget的build()方法再次被调用，而在build()中，改变Image的宽高，因为它的高度和宽度现在使用的是animation.value ，所以就会逐渐放大。值得注意的是动画完成时要释放控制器(调用dispose()方法)以防止内存泄漏。 上面的例子中并没有指定Curve，所以放大的过程是线性的（匀速），下面我们指定一个Curve，来实现一个类似于弹簧效果的动画过程，我们只需要将initState中的代码改为下面这样即可： initState() { super.initState(); controller = new AnimationController( duration: const Duration(seconds: 3), vsync: this); //使用弹性曲线 animation=CurvedAnimation(parent: controller, curve: Curves.bounceIn); //图片宽高从0变到300 animation = new Tween(begin: 0.0, end: 300.0).animate(animation) ..addListener(() { setState(() { }); }); //启动动画 controller.forward(); } 使用AnimatedWidget简化 细心的读者可能已经发现上面示例中通过addListener()和setState() 来更新UI这一步其实是通用的，如果每个动画中都加这么一句是比较繁琐的。AnimatedWidget类封装了调用setState()的细节，并允许我们将Widget分离出来，重构后的代码如下： class AnimatedImage extends AnimatedWidget { AnimatedImage({Key key, Animation animation}) : super(key: key, listenable: animation); Widget build(BuildContext context) { final Animation animation = listenable; return new Center( child: Image.asset(\"images/avatar.png\", width: animation.value, height: animation.value ), ); } } class ScaleAnimationRoute extends StatefulWidget { @override _ScaleAnimationRouteState createState() => new _ScaleAnimationRouteState(); } class _ScaleAnimationRouteState extends State with SingleTickerProviderStateMixin { Animation animation; AnimationController controller; initState() { super.initState(); controller = new AnimationController( duration: const Duration(seconds: 3), vsync: this); //图片宽高从0变到300 animation = new Tween(begin: 0.0, end: 300.0).animate(controller); //启动动画 controller.forward(); } @override Widget build(BuildContext context) { return AnimatedImage(animation: animation,); } dispose() { //路由销毁时需要释放动画资源 controller.dispose(); super.dispose(); } } 用AnimatedBuilder重构 用AnimatedWidget可以从动画中分离出widget，而动画的渲染过程（即设置宽高）仍然在AnimatedWidget中，假设如果我们再添加一个widget透明度变化的动画，那么我们需要再实现一个AnimatedWidget，这样不是很优雅，如果我们能把渲染过程也抽象出来，那就会好很多，而AnimatedBuilder正是将渲染逻辑分离出来, 上面的build方法中的代码可以改为： @override Widget build(BuildContext context) { //return AnimatedImage(animation: animation,); return AnimatedBuilder( animation: animation, child: Image.asset(\"images/avatar.png\"), builder: (BuildContext ctx, Widget child) { return new Center( child: Container( height: animation.value, width: animation.value, child: child, ), ); }, ); } 上面的代码中有一个迷惑的问题是，child看起来像被指定了两次。但实际发生的事情是：将外部引用child传递给AnimatedBuilder后AnimatedBuilder再将其传递给匿名构造器， 然后将该对象用作其子对象。最终的结果是AnimatedBuilder返回的对象插入到Widget树中。 也许你会说这和我们刚开始的示例差不了多少，其实它会带来三个好处： 不用显式的去添加帧监听器，然后再调用setState() 了，这个好处和AnimatedWidget是一样的。 动画构建的范围缩小了，如果没有builder，setState()将会在父widget上下文调用，这将会导致父widget的build方法重新调用，而有了builder之后，只会导致动画widget的build重新调用，这在复杂布局下性能会提高。 通过AnimatedBuilder可以封装常见的过渡效果来复用动画。下面我们通过封装一个GrowTransition来说明，它可以对子widget实现放大动画： class GrowTransition extends StatelessWidget { GrowTransition({this.child, this.animation}); final Widget child; final Animation animation; Widget build(BuildContext context) { return new Center( child: new AnimatedBuilder( animation: animation, builder: (BuildContext context, Widget child) { return new Container( height: animation.value, width: animation.value, child: child ); }, child: child ), ); } } 这样，最初的示例就可以改为： ... Widget build(BuildContext context) { return GrowTransition( child: Image.asset(\"images/avatar.png\"), animation: animation, ); } Flutter中正是通过这种方式封装了很多动画，如：FadeTransition、ScaleTransition、SizeTransition、FractionalTranslation等，很多时候都可以复用这些预置的过渡类。 动画状态监听 上面说过，我们可以通过Animation的addStatusListener()方法来添加动画状态改变监听器。Flutter中，有四种动画状态，在AnimationStatus枚举类中定义，下面我们逐个说明： 枚举值 含义 dismissed 动画在起始点停止 forward 动画正在正向执行 reverse 动画正在反向执行 completed 动画在终点停止 示例 我们将上面图片放大的示例改为先放大再缩小再放大……这样的循环动画。要实现这种效果，我们只需要监听动画状态的改变即可，即：在动画正向执行结束时反转动画，在动画反向执行结束时再正向执行动画。代码如下： initState() { super.initState(); controller = new AnimationController( duration: const Duration(seconds: 1), vsync: this); //图片宽高从0变到300 animation = new Tween(begin: 0.0, end: 300.0).animate(controller); animation.addStatusListener((status) { if (status == AnimationStatus.completed) { //动画执行结束时反向执行动画 controller.reverse(); } else if (status == AnimationStatus.dismissed) { //动画恢复到初始状态时执行动画（正向） controller.forward(); } }); //启动动画（正向） controller.forward(); } "},"chapter9/route_transition.html":{"url":"chapter9/route_transition.html","title":"自定义路由过渡动画","keywords":"","body":"自定义路由切换动画 Material库中提供了一个MaterialPageRoute，它可以使用和平台风格一致的路由切换动画，如在iOS上会左右滑动切换，而在Android上会上下滑动切换。如果在Android上也想使用左右切换风格，可以直接使用CupertinoPageRoute, 如： Navigator.push(context, CupertinoPageRoute( builder: (context){ return PageB(); //路由B } )); 如果想自定义路由切换动画，可以使用PageRouteBuilder，例如我们想以渐隐渐入动画来实现路由过渡： Navigator.push(context, PageRouteBuilder( transitionDuration: Duration(milliseconds: 500), //动画时间为500毫秒 pageBuilder: (BuildContext context, Animation animation, Animation secondaryAnimation) { return new FadeTransition( //使用渐隐渐入过渡, opacity: animation, child: PageB() //路由B ); })); }), 我们可以看到pageBuilder 有一个animation参数，这是Flutter路由管理器提供的，在路由切换时pageBuilder在每个动画帧都会被回调，因此我们可以通过animation对象来自定义过渡动画。 无论是MaterialPageRoute、CupertinoPageRoute，还是PageRouteBuilder，它们都继承自PageRoute类，而PageRouteBuilder其实只是PageRoute的一个包装，我们可以直接继承PageRoute类来实现自定义路由，上面的例子可以通过如下方式实现： 定义一个路由类FadeRoute class FadeRoute extends PageRoute { FadeRoute({ @required this.builder, this.transitionDuration = const Duration(milliseconds: 300), this.opaque = true, this.barrierDismissible = false, this.barrierColor, this.barrierLabel, this.maintainState = true, }); final WidgetBuilder builder; @override final Duration transitionDuration; @override final bool opaque; @override final bool barrierDismissible; @override final Color barrierColor; @override final String barrierLabel; @override final bool maintainState; @override Widget buildPage(BuildContext context, Animation animation, Animation secondaryAnimation) => builder(context); @override Widget buildTransitions(BuildContext context, Animation animation, Animation secondaryAnimation, Widget child) { return FadeTransition( opacity: animation, child: builder(context), ); } } 使用FadeRoute Navigator.push(context, FadeRoute(builder: (context) { return PageB(); })); 虽然上面的两种方法都可以实现自定义切换动画，但实际使用时应考虑优先使用PageRouteBuilder，这样无需定义一个新的路由类，使用起来会比较方便。但是有些时候PageRouteBuilder是不能满足需求的，例如在应用过渡动画时我们需要读取当前路由的一些属性，这时就只能通过继承PageRoute的方式了，举个例子，假如我们只想在打开新路由时应用动画，而在返回时不使用动画，那么我们在构建过渡动画时就必须判断当前路由isActive属性是否为true，代码如下： @override Widget buildTransitions(BuildContext context, Animation animation, Animation secondaryAnimation, Widget child) { //当前路由被激活，是打开新路由 if(isActive) { return FadeTransition( opacity: animation, child: builder(context), ); }else{ //是返回，则不应用过渡动画 return Padding(padding: EdgeInsets.zero); } } 关于路由参数的详细信息读者可以自行查阅API文档，比较简单，不再赘述。 "},"chapter9/hero.html":{"url":"chapter9/hero.html","title":"Hero动画","keywords":"","body":"Hero动画 Hero指的是可以在路由(页面)之间“飞行”的widget，简单来说Hero动画就是在路由切换时，有一个共享的Widget可以在新旧路由间切换，由于共享的Widget在新旧路由页面上的位置、外观可能有所差异，所以在路由切换时会逐渐过渡，这样就会产生一个Hero动画。 你可能多次看到过 hero 动画。例如，一个路由中显示待售商品的缩略图列表，选择一个条目会将其跳转到一个新路由，新路由中包含该商品的详细信息和“购买”按钮。 在Flutter中将图片从一个路由“飞”到另一个路由称为hero动画，尽管相同的动作有时也称为 共享元素转换。下面我们通过一个示例来体验一下hero 动画。 示例 假设有两个路由A和B，他们的内容交互如下： A：包含一个用户头像，圆形，点击后跳到B路由，可以查看大图。 B：显示用户头像原图，矩形； 在AB两个路由之间跳转的时候，用户头像会逐渐过渡到目标路由页的头像上，接下来我们先看看代码，然后再解析： // 路由A class HeroAnimationRoute extends StatelessWidget { @override Widget build(BuildContext context) { return Container( alignment: Alignment.topCenter, child: InkWell( child: Hero( tag: \"avatar\", //唯一标记，前后两个路由页Hero的tag必须相同 child: ClipOval( child: Image.asset(\"images/avatar.png\", width: 50.0, ), ), ), onTap: () { //打开B路由 Navigator.push(context, PageRouteBuilder( pageBuilder: (BuildContext context, Animation animation, Animation secondaryAnimation) { return new FadeTransition( opacity: animation, child: PageScaffold( title: \"原图\", body: HeroAnimationRouteB(), ), ); }) ); }, ), ); } } 路由B: class HeroAnimationRouteB extends StatelessWidget { @override Widget build(BuildContext context) { return Center( child: Hero( tag: \"avatar\", //唯一标记，前后两个路由页Hero的tag必须相同 child: Image.asset(\"images/avatar.png\")， ), ); } } 我们可以看到，实现Hero动画只需要用Hero Widget将要共享的Widget包装起来，并提供一个相同的tag即可，中间的过渡帧都是Flutter Framework自动完成的。必须要注意， 前后路由页的共享Hero的tag必须是相同的，Flutter Framework内部正式通过tag来对应新旧路由页Widget的对应关系的。 Hero动画的原理比较简单，Flutter Framework知道新旧路由页中共享元素的位置和大小，所以根据这两个端点，在动画执行过程中求出过渡时的插值即可，幸运的是，这些事情Flutter已经帮我们做了。 "},"chapter9/stagger_animation.html":{"url":"chapter9/stagger_animation.html","title":"交错动画","keywords":"","body":"交错动画 有些时候我们可能会需要一些复杂的动画，这些动画可能由一个动画序列或重叠的动画组成，比如：有一个柱状图，需要在高度增长的同时改变颜色，等到增长到最大高度后，我们需要在X轴上平移一段距离。这时我们就需要使用交错动画（Stagger Animation）。交错动画需要注意以下几点： 要创建交错动画，需要使用多个动画对象 一个AnimationController控制所有动画 给每一个动画对象指定间隔（Interval） 所有动画都由同一个AnimationController驱动，无论动画实时持续多长时间，控制器的值必须介于0.0和1.0之间，而每个动画的间隔（Interval）介于0.0和1.0之间。对于在间隔中设置动画的每个属性，请创建一个Tween。 Tween指定该属性的开始值和结束值。也就是说0.0到1.0代表整个动画过程，我们可以给不同动画指定起始点和终止点来决定它们的开始时间和终止时间。 示例 下面我们看一个例子，实现一个柱状图增长的动画： 开始时高度从0增长到300像素，同时颜色由绿色渐变为红色；这个过程占据整个动画时间的60%。 高度增长到300后，开始沿X轴向右平移100像素；这个过程占用整个动画时间的40%。 我们将执行动画的Widget分离出来： class StaggerAnimation extends StatelessWidget { StaggerAnimation({ Key key, this.controller }): super(key: key){ //高度动画 height = Tween( begin:.0 , end: 300.0, ).animate( CurvedAnimation( parent: controller, curve: Interval( 0.0, 0.6, //间隔，前60%的动画时间 curve: Curves.ease, ), ), ); color = ColorTween( begin:Colors.green , end:Colors.red, ).animate( CurvedAnimation( parent: controller, curve: Interval( 0.0, 0.6,//间隔，前60%的动画时间 curve: Curves.ease, ), ), ); padding = Tween( begin:EdgeInsets.only(left: .0), end:EdgeInsets.only(left: 100.0), ).animate( CurvedAnimation( parent: controller, curve: Interval( 0.6, 1.0, //间隔，后40%的动画时间 curve: Curves.ease, ), ), ); } final Animation controller; Animation height; Animation padding; Animation color; Widget _buildAnimation(BuildContext context, Widget child) { return Container( alignment: Alignment.bottomCenter, padding:padding.value , child: Container( color: color.value, width: 50.0, height: height.value, ), ); } @override Widget build(BuildContext context) { return AnimatedBuilder( builder: _buildAnimation, animation: controller, ); } } StaggerAnimation中定义了三个动画，分别是对Container的height、color、padding属性设置的动画，然后通过Interval来为每个动画指定在整个动画过程的起始点和终点。 下面我们来实现启动动画的路由： class StaggerDemo extends StatefulWidget { @override _StaggerDemoState createState() => _StaggerDemoState(); } class _StaggerDemoState extends State with TickerProviderStateMixin { AnimationController _controller; @override void initState() { super.initState(); _controller = AnimationController( duration: const Duration(milliseconds: 2000), vsync: this ); } Future _playAnimation() async { try { //先正向执行动画 await _controller.forward().orCancel; //再反向执行动画 await _controller.reverse().orCancel; } on TickerCanceled { // the animation got canceled, probably because we were disposed } } @override Widget build(BuildContext context) { return GestureDetector( behavior: HitTestBehavior.opaque, onTap: () { _playAnimation(); }, child: Center( child: Container( width: 300.0, height: 300.0, decoration: BoxDecoration( color: Colors.black.withOpacity(0.1), border: Border.all( color: Colors.black.withOpacity(0.5), ), ), //调用我们定义的交错动画Widget child: StaggerAnimation( controller: _controller ), ), ), ); } } 执行效果如下，点击灰色矩形，就可以看到整个动画效果： "},"chapter13/":{"url":"chapter13/","title":"自定义Widget","keywords":"","body":"本章目录 自定义Widget方法简介 通过组合现有Widget实现 实例：TurnBox CustomPaint与Canvas 实例：圆形渐变进度条 "},"chapter13/intro.html":{"url":"chapter13/intro.html","title":"自定义Widget方法简介","keywords":"","body":"自定义Widget方法简介 当Flutter提供的现有Widget无法满足我们的需求，或者我们为了共享代码需要封装一些通用Widget，这时我们就需要自定义Widget。在Flutter中自定义Widget有三种方式：通过组合其它Widget、自绘和实现RenderObject，本节我们先分别介绍一下这三种方式的特点，后面章节中则详细介绍它们的细节。 组合其它Widget 这种方式是通过拼装其它低级别的Widget来组合成一个高级别的Widget，例如我们之前介绍的Container就是一个组合Widget，它是由DecoratedBox、ConstrainedBox、Transform、Padding、Align等组成。 在Flutter中，组合的思想非常重要，Flutter提供了非常多的基础Widget，而我们的界面开发都是按照需要组合这些Widget来实现各种不同的布局。 自绘 如果遇到无法通过系统提供的现有Widget实现的UI时，如我们需要一个渐变圆形进度条，而Flutter提供的CircularProgressIndicator并不支持在显示精确进度时对进度条应用渐变色（其valueColor 属性只支持执行旋转动画时变化Indicator的颜色），这时最好的方法就是通过自定义Widget绘制逻辑来画出我们期望的外观。Flutter中提供了CustomPaint和Canvas供我们自绘UI外观。 实现RenderObject Flutter提供的任何具有UI外观的Widget，如文本Text、Image都是通过相应的RenderObject渲染出来的，如Text是由RenderParagraph渲染，而Image是由RenderImage渲染。RenderObject是一个抽象类，它定义了一个抽象方法paint(...): void paint(PaintingContext context, Offset offset) PaintingContext代表Widget的绘制上下文，通过PaintingContext.canvas可以获得Canvas，绘制逻辑主要是通过Canvas API来实现。子类需要实现此方法以实现自身的绘制逻辑，如RenderParagraph需要实现文本绘制逻辑，而RenderImage需要实现图片绘制逻辑。 可以发现，RenderObject中最终也是通过Canvas来绘制的，那么通过实现RenderObject的方式和上面介绍的通过CustomPaint和Canvas自绘的方式有什么区别？其实答案很简单，CustomPaint只是为了方便开发者封装的一个代理类，它直接继承自SingleChildRenderObjectWidget，通过RenderCustomPaint的paint方法将Canvas和画笔Painter(需要开发者实现，后面章节介绍)连接起来实现了最终的绘制（绘制逻辑在Painter中）。 总结 组合是自定义组件最简单的方法，在任何需要自定义的场景下，都应该优先考虑是否能够通过组合来实现。而自绘和通过实现RenderObject的方法本质上是一样的，都需要开发者调用Canvas API手动去绘制UI，缺点是必须了解Canvas API，并且得自己去实现绘制逻辑，而优点是强大灵活，理论上可以实现任何外观的UI。 在本章接下来的小节中，我们将通过一些实例来详细介绍自定义UI的过程，由于后两种方法本质是相同的，后续我们只介绍CustomPaint和Canvas的方式，读者如果对自定义RenderObject的方法好奇，可以查看RenderParagraph或RenderImage源码。 "},"chapter13/combine.html":{"url":"chapter13/combine.html","title":"通过组合现有Widget实现","keywords":"","body":"通过组合现有Widget实现自定义Widget 在Flutter中页面UI通常都是由一些低阶别的Widget组合而成，当我们需要封装一些通用Widget时，应该首先考虑是否可以通过组合其它Widget来实现，如果可以则应优先使用组合，因为直接通过现有Widget拼装会非常方便、简单、高效。 示例：自定义渐变按钮 Flutter Widget库中的按钮默认不支持渐变背景，为了实现渐变背景按钮，我们自定义一个GradientButton Widget。我们先来看看效果： 我们看看GradientButton实现： import 'package:flutter/material.dart'; class GradientButton extends StatelessWidget { GradientButton({ this.colors, this.width, this.height, this.onTap, @required this.child, }); // 渐变色数组 final List colors; // 按钮宽高 final double width; final double height; final Widget child; //点击回调 final GestureTapCallback onTap; @override Widget build(BuildContext context) { ThemeData theme = Theme.of(context); //确保colors数组不空 List _colors = colors ?? [theme.primaryColor, theme.primaryColorDark ?? theme.primaryColor]; return DecoratedBox( decoration: BoxDecoration( gradient: LinearGradient(colors: _colors), ), child: Material( type: MaterialType.transparency, child: InkWell( splashColor: colors.last, highlightColor: Colors.transparent, onTap: onTap, child: ConstrainedBox( constraints: BoxConstraints.tightFor(height: height, width: width), child: Center( child: Padding( padding: const EdgeInsets.all(8.0), child: DefaultTextStyle( style: TextStyle(fontWeight: FontWeight.bold), child: child), ), ), ), ), ), ); } } 可以看到GradientButton是由Padding、Center、InkWell等Widget组合而成。当然上面的代码只是一个示例，作为一个按钮它还并不完整，比如没有禁用状态、不能定义圆角等，读者可以根据实际需要来完善。 使用GradientButton class GradientButtonRoute extends StatelessWidget { @override Widget build(BuildContext context) { return Container( child: Column( children: [ GradientButton( colors: [Colors.orange,Colors.red], height: 50.0, child: Text(\"Submit\"), onTap:onTap , ), GradientButton( height: 50.0, colors: [Colors.lightGreen, Colors.green[700]], child: Text(\"Submit\"), onTap: onTap, ), GradientButton( height: 50.0, colors: [Colors.lightBlue[300], Colors.blueAccent], child: Text(\"Submit\"), onTap: onTap, ), ], ), ); } onTap(){ print(\"button click\"); } } 总结 通过组合的方式定义Widget和我们之前写界面并无差异，不过在抽离出单独的Widget时我们要考虑代码规范性，如必要参数要用@required 标注，对于可选参数在特定场景需要判空或设置默认值等。这是由于使用者大多时候可能不了解Widget的内部细节，所以为了保证代码健壮性，我们需要在用户错误地使用Widget时能够兼容或报错提示（使用assert断言函数）。 "},"chapter13/turn_box.html":{"url":"chapter13/turn_box.html","title":"实例：TurnBox","keywords":"","body":"实例：TurnBox 我们之前已经介绍过RotatedBox，但是它有两个缺点：一是只能将其子节点以90度的倍数旋转，二是当旋转的角度发生变化时，旋转角度更新过程没有动画。 本节我们将实现一个TurnBox，它可以以任意角度来旋转其子节点，并且在角度发生变化时可以执行一个动画过渡到新状态，同时，我们可以手动指定动画速度。 TurnBox的完整代码如下： import 'package:flutter/widgets.dart'; class TurnBox extends StatefulWidget { const TurnBox({ Key key, this.turns = .0, //旋转的“圈”数,一圈为360度，如0.25圈即90度 this.speed = 200, //过渡动画执行的总时长 this.child }) :super(key: key); final double turns; final int speed; final Widget child; @override _TurnBoxState createState() => new _TurnBoxState(); } class _TurnBoxState extends State with SingleTickerProviderStateMixin { AnimationController _controller; @override void initState() { super.initState(); _controller = new AnimationController( vsync: this, lowerBound: -double.infinity, upperBound: double.infinity ); _controller.value = widget.turns; } @override void dispose() { _controller.dispose(); super.dispose(); } @override Widget build(BuildContext context) { return RotationTransition( turns: _controller, child: widget.child, ); } @override void didUpdateWidget(TurnBox oldWidget) { super.didUpdateWidget(oldWidget); //旋转角度发生变化时执行过渡动画 if (oldWidget.turns != widget.turns) { _controller.animateTo( widget.turns, duration: Duration(milliseconds: widget.speed??200), curve: Curves.easeOut, ); } } } 代码比较简单，我们主要是通过包装(组合)RotationTransition来实现的。 下面我们测试一下TurnBox的功能，测试代码如下： import 'package:flutter/material.dart'; import '../widgets/index.dart'; class TurnBoxRoute extends StatefulWidget { @override _TurnBoxRouteState createState() => new _TurnBoxRouteState(); } class _TurnBoxRouteState extends State { double _turns = .0; @override Widget build(BuildContext context) { return Center( child: Column( children: [ TurnBox( turns: _turns, speed: 500, child: Icon(Icons.refresh, size: 50,), ), TurnBox( turns: _turns, speed: 1000, child: Icon(Icons.refresh, size: 150.0,), ), RaisedButton( child: Text(\"顺时针旋转1/5圈\"), onPressed: () { setState(() { _turns += .2; }); }, ), RaisedButton( child: Text(\"逆时针旋转1/5圈\"), onPressed: () { setState(() { _turns -= .2; }); }, ) ], ), ); } } 测试代码运行后效果如下图： 当我们点击旋转按钮时，两个图标的旋转都会旋转1/5圈，但旋转的速度是不同的，读者可以自己运行一下示例看看效果。 "},"chapter13/custom_paint.html":{"url":"chapter13/custom_paint.html","title":"CustomPaint与Canvas","keywords":"","body":"CustomPaint与Canvas 对于一些复杂或不规则的UI，我们可能无法使用现有Widget组合的方式来实现，比如我们需要一个正六边形、一个渐变的圆形进度条、一个棋盘等，当然有时候我们可以使用图片来实现，但在一些需要动态交互的场景静态图片是实现不了的，比如要实现一个手写输入面板。这时，我们就需要来自己绘制UI外观。 几乎所有的UI系统都会提供一个自绘UI的接口，这个接口通常会提供一块2D画布Canvas，Canvas内部封装了一些基本绘制的API，开发者可以通过Canvas绘制各种自定义图形。在Flutter中，提供了一个CustomPaint Widget，它可以结合一个画笔CustomPainter来实现绘制自定义图形。 CustomPaint 我们看看CustomPaint构造函数： const CustomPaint({ Key key, this.painter, this.foregroundPainter, this.size = Size.zero, this.isComplex = false, this.willChange = false, Widget child, //子节点，可以为空 }) painter: 背景画笔，会显示在子节点后面; foregroundPainter: 前景画笔，会显示在子节点前面 size：当child为null时，代表默认绘制区域大小，如果有child则忽略此参数，画布尺寸则为child尺寸。如果有child但是想指定画布为特定大小，可以使用SizeBox包裹CustomPaint实现。 isComplex：是否复杂的绘制，如果是，Flutter会应用一些缓存策略来减少重复渲染的开销。 willChange：和isComplex配合使用，当启用缓存时，该属性代表在下一帧中绘制是否会改变。 可以看到，绘制时我们需要提供前景或背景画笔，两者也可以同时提供。我们的画笔需要继承CustomPainter类，我们在画笔类中实现真正的绘制逻辑。 注意 如果CustomPaint有子节点，为了避免子节点不必要的重绘并提高性能，通常情况下都会将子节点包裹在RepaintBoundary Widget中，这样会在绘制时创建一个新的绘制层（Layer），其子Widget将在新的Layer上绘制，而父Widget将在原来Layer上绘制，也就是说RepaintBoundary 子Widget的绘制将独立于父Widget的绘制，RepaintBoundary会隔离其子节点和CustomPaint本身的绘制边界。示例如下： CustomPaint( size: Size(300, 300), //指定画布大小 painter: MyPainter(), child: RepaintBoundary(child:...)), ) CustomPainter CustomPainter中提定义了一个虚函数paint： void paint(Canvas canvas, Size size); paint有两个参数: Canvas：一个画布，包括各种绘制方法，我们列出一下常用的方法： |API名称 | 功能 | | ---------- | ------ | | drawLine | 画线 | | drawPoint | 画点 | | drawPath | 画路径 | | drawImage | 画图像 | | drawRect | 画矩形 | | drawCircle | 画圆 | | drawOval | 画椭圆 | | drawArc | 画圆弧 | Size：当前绘制区域大小。 画笔Paint 现在画布有了，我们最后还缺一个画笔，Flutter提供了Paint类来实现画笔。在Paint中，我们可以配置画笔的各种属性如粗细、颜色、样式等。如： var paint = Paint() //创建一个画笔并配置其属性 ..isAntiAlias = true //是否抗锯齿 ..style = PaintingStyle.fill //画笔样式：填充 ..color=Color(0x77cdb175);//画笔颜色 更多的配置属性读者可以参考Paint类定义。 示例：五子棋/盘 下面我们通过一个五子棋游戏中棋盘和棋子的绘制来演示自绘UI的过程，首先我们看一下我们的目标结果： 代码： import 'package:flutter/material.dart'; import 'dart:math'; class CustomPaintRoute extends StatelessWidget { @override Widget build(BuildContext context) { return Center( child: CustomPaint( size: Size(300, 300), //指定画布大小 painter: MyPainter(), ), ); } } class MyPainter extends CustomPainter { @override void paint(Canvas canvas, Size size) { double eWidth = size.width / 15; double eHeight = size.height / 15; //画棋盘背景 var paint = Paint() ..isAntiAlias = true ..style = PaintingStyle.fill //填充 ..color = Color(0x77cdb175); //背景为纸黄色 canvas.drawRect(Offset.zero & size, paint); //画棋盘网格 paint ..style = PaintingStyle.stroke //线 ..color = Colors.black87 ..strokeWidth = 1.0; for (int i = 0; i true; } 性能 绘制是比较昂贵的操作，所以我们在实现自绘控件时应该考虑到性能开销，下面是两条关于性能优化的建议： 尽可能的利用好shouldRepaint返回值；在UI树重新build时，控件在绘制前都会先调用该方法以确定是否有必要重绘；假如我们绘制的UI不依赖外部状态，那么就应该始终返回false，因为外部状态改变导致重新build时不会影响我们的UI外观；如果绘制依赖外部状态，那么我们就应该在shouldRepaint中判断依赖的状态是否改变，如果已改变则应返回true来重绘，反之则应返回false不需要重绘。 绘制尽可能多的分层；在上面五子棋的示例中，我们将棋盘和棋子的绘制放在了一起，这样会有一个问题：由于棋盘始终是不变的，用户每次落子时变的只是棋子，但是如果按照上面的代码来实现，每次绘制棋子时都要重新绘制一次棋盘，这是没必要的。优化的方法就是将棋盘单独抽为一个Widget，并设置其shouldRepaint回调值为false，然后将棋盘Widget作为背景。然后将棋子的绘制放到另一个Widget中，这样落子时只需要绘制棋子。 总结 自绘控件非常强大，理论上可以实现任何2D图形外观，实际上Flutter提供的所有Widget最终都是调用Canvas绘制出来的，只不过绘制的逻辑被封装起来了，读者有兴趣可以查看具有外观样式的Widget的源码，找到其对应的RenderObject对象，如Text Widget最终会通过RenderParagraph对象来通过Canvas实现文本绘制逻辑。 下一节我们再通过实现一个自绘的圆形渐变进度条的实例来帮助读者加深印象。 "},"chapter13/gradient_circular_progress_demo.html":{"url":"chapter13/gradient_circular_progress_demo.html","title":"实例：圆形渐变进度条(自绘)","keywords":"","body":"实例：圆形渐变进度条(自绘) 本节我们实现一个圆形渐变进度条，它支持： 支持多种渐变色。 任意弧度；整个进度可以不是整圆。 可以自定义粗细、两端是否圆角等样式。 可以发现要实现这样的一个进度条是无法通过现有组件组合而成的，所以我们通过自绘方式实现。 实现代码如下： import 'dart:math'; import 'package:flutter/material.dart'; class GradientCircularProgressIndicator extends StatelessWidget { GradientCircularProgressIndicator({ this.stokeWidth = 2.0, @required this.radius, @required this.colors, this.stops, this.strokeCapRound = false, this.backgroundColor = const Color(0xFFEEEEEE), this.totalAngle = 2 * pi, this.value }); ///粗细 final double stokeWidth; /// 圆的半径 final double radius; ///两端是否为圆角 final bool strokeCapRound; /// 当前进度，取值范围 [0.0-1.0] final double value; /// 进度条背景色 final Color backgroundColor; /// 进度条的总弧度，2*PI为整圆，小于2*PI则不是整圆 final double totalAngle; /// 渐变色数组 final List colors; /// 渐变色的终止点，对应colors属性 final List stops; @override Widget build(BuildContext context) { double _offset = .0; // 如果两端为圆角，则需要对起始位置进行调整，否则圆角部分会偏离起始位置 // 下面调整的角度的计算公式是通过数学几何知识得出，读者有兴趣可以研究一下为什么是这样 if (strokeCapRound) { _offset = asin(stokeWidth / (radius * 2 - stokeWidth)); } var _colors = colors; if (_colors == null) { Color color = Theme .of(context) .accentColor; _colors = [color, color]; } return Transform.rotate( angle: -pi / 2.0 - _offset, child: CustomPaint( size: Size.fromRadius(radius), painter: _GradientCircularProgressPainter( stokeWidth: stokeWidth, strokeCapRound: strokeCapRound, backgroundColor: backgroundColor, value: value, total: totalAngle, radius: radius, colors: _colors, ) ), ); } } //实现画笔 class _GradientCircularProgressPainter extends CustomPainter { _GradientCircularProgressPainter({ this.stokeWidth: 10.0, this.strokeCapRound: false, this.backgroundColor = const Color(0xFFEEEEEE), this.radius, this.total = 2 * pi, @required this.colors, this.stops, this.value }); final double stokeWidth; final bool strokeCapRound; final double value; final Color backgroundColor; final List colors; final double total; final double radius; final List stops; @override void paint(Canvas canvas, Size size) { if (radius != null) { size = Size.fromRadius(radius); } double _offset = stokeWidth / 2.0; double _value = (value ?? .0); _value = _value.clamp(.0, 1.0) * total; double _start = .0; if (strokeCapRound) { _start = asin(stokeWidth/ (size.width - stokeWidth)); } Rect rect = Offset(_offset, _offset) & Size( size.width - stokeWidth, size.height - stokeWidth ); var paint = Paint() ..strokeCap = strokeCapRound ? StrokeCap.round : StrokeCap.butt ..style = PaintingStyle.stroke ..isAntiAlias = true ..strokeWidth = stokeWidth; // 先画背景 if (backgroundColor != Colors.transparent) { paint.color = backgroundColor; canvas.drawArc( rect, _start, total, false, paint ); } // 再画前景，应用渐变 if (_value > 0) { paint.shader = SweepGradient( startAngle: 0.0, endAngle: _value, colors: colors, stops: stops, ).createShader(rect); canvas.drawArc( rect, _start, _value, false, paint ); } } @override bool shouldRepaint(CustomPainter oldDelegate) => true; } 下面我们来测试一下，为了尽可能多的展示GradientCircularProgressIndicator的不同外观和用途，这个示例代码会比较长，并且添加了动画，建议读者将此示例运行起来观看实际效果，我们先看看其中的一帧动画的截图： 完整的代码： import 'dart:math'; import 'package:flutter/material.dart'; import '../widgets/index.dart'; class GradientCircularProgressRoute extends StatefulWidget { @override GradientCircularProgressRouteState createState() { return new GradientCircularProgressRouteState(); } } class GradientCircularProgressRouteState extends State with TickerProviderStateMixin { AnimationController _animationController; @override void initState() { super.initState(); _animationController = new AnimationController(vsync: this, duration: Duration(seconds: 3)); bool isForward = true; _animationController.addStatusListener((status) { if (status == AnimationStatus.forward) { isForward = true; } else if (status == AnimationStatus.completed || status == AnimationStatus.dismissed) { if (isForward) { _animationController.reverse(); } else { _animationController.forward(); } } else if (status == AnimationStatus.reverse) { isForward = false; } }); _animationController.forward(); } @override void dispose() { _animationController.dispose(); super.dispose(); } @override Widget build(BuildContext context) { return SingleChildScrollView( child: Center( child: Column( crossAxisAlignment: CrossAxisAlignment.center, children: [ AnimatedBuilder( animation: _animationController, builder: (BuildContext context, Widget child) { return Padding( padding: const EdgeInsets.symmetric(vertical: 16.0), child: Column( children: [ Wrap( spacing: 10.0, runSpacing: 16.0, children: [ GradientCircularProgressIndicator( // No gradient colors: [Colors.blue, Colors.blue], radius: 50.0, stokeWidth: 3.0, value: _animationController.value, ), GradientCircularProgressIndicator( colors: [Colors.red, Colors.orange], radius: 50.0, stokeWidth: 3.0, value: _animationController.value, ), GradientCircularProgressIndicator( colors: [Colors.red, Colors.orange, Colors.red], radius: 50.0, stokeWidth: 5.0, value: _animationController.value, ), GradientCircularProgressIndicator( colors: [Colors.teal, Colors.cyan], radius: 50.0, stokeWidth: 5.0, strokeCapRound: true, value: CurvedAnimation( parent: _animationController, curve: Curves.decelerate) .value, ), TurnBox( turns: 1 / 8, child: GradientCircularProgressIndicator( colors: [Colors.red, Colors.orange, Colors.red], radius: 50.0, stokeWidth: 5.0, strokeCapRound: true, backgroundColor: Colors.red[50], totalAngle: 1.5 * pi, value: CurvedAnimation( parent: _animationController, curve: Curves.ease) .value), ), RotatedBox( quarterTurns: 1, child: GradientCircularProgressIndicator( colors: [Colors.blue[700], Colors.blue[200]], radius: 50.0, stokeWidth: 3.0, strokeCapRound: true, backgroundColor: Colors.transparent, value: _animationController.value), ), GradientCircularProgressIndicator( colors: [ Colors.red, Colors.amber, Colors.cyan, Colors.green[200], Colors.blue, Colors.red ], radius: 50.0, stokeWidth: 5.0, strokeCapRound: true, value: _animationController.value, ), ], ), GradientCircularProgressIndicator( colors: [Colors.blue[700], Colors.blue[200]], radius: 100.0, stokeWidth: 20.0, value: _animationController.value, ), Padding( padding: const EdgeInsets.symmetric(vertical: 16.0), child: GradientCircularProgressIndicator( colors: [Colors.blue[700], Colors.blue[300]], radius: 100.0, stokeWidth: 20.0, value: _animationController.value, strokeCapRound: true, ), ), //剪裁半圆 ClipRect( child: Align( alignment: Alignment.topCenter, heightFactor: .5, child: Padding( padding: const EdgeInsets.only(bottom: 8.0), child: SizedBox( //width: 100.0, child: TurnBox( turns: .75, child: GradientCircularProgressIndicator( colors: [Colors.teal, Colors.cyan[500]], radius: 100.0, stokeWidth: 8.0, value: _animationController.value, totalAngle: pi, strokeCapRound: true, ), ), ), ), ), ), SizedBox( height: 104.0, width: 200.0, child: Stack( alignment: Alignment.center, children: [ Positioned( height: 200.0, top: .0, child: TurnBox( turns: .75, child: GradientCircularProgressIndicator( colors: [Colors.teal, Colors.cyan[500]], radius: 100.0, stokeWidth: 8.0, value: _animationController.value, totalAngle: pi, strokeCapRound: true, ), ), ), Padding( padding: const EdgeInsets.only(top: 10.0), child: Text( \"${(_animationController.value * 100).toInt()}%\", style: TextStyle( fontSize: 25.0, color: Colors.blueGrey, ), ), ) ], ), ), ], ), ); }, ), ], ), ), ); } } "},"chapter10/":{"url":"chapter10/","title":"文件操作与网络请求","keywords":"","body":"本章目录 文件操作 Http请求-HttpClient Http请求-Dio package 实例：Http分块下载 WebSocket 使用Socket API Json转Model "},"chapter10/file_operation.html":{"url":"chapter10/file_operation.html","title":"文件操作","keywords":"","body":"文件操作 Dart的IO库包含了文件读写的相关类，它属于Dart语法标准的一部分，所以通过Dart IO库，无论是Dart VM下的脚本还是Flutter，都是通过Dart IO库来操作文件的，不过和Dart VM相比，Flutter有一个重要差异是文件系统路径不同，这是因为Dart VM是运行在PC或服务器操作系统下，而Flutter是运行在移动操作系统中，他们的文件系统会有一些差异。 APP目录 Android和iOS的应用存储目录不同，PathProvider 插件提供了一种平台透明的方式来访问设备文件系统上的常用位置。该类当前支持访问两个文件系统位置： 临时目录: 可以使用 getTemporaryDirectory() 来获取临时目录； 系统可随时清除的临时目录（缓存）。在iOS上，这对应于NSTemporaryDirectory() 返回的值。在Android上，这是getCacheDir())返回的值。 文档目录: 可以使用getApplicationDocumentsDirectory()来获取应用程序的文档目录，该目录用于存储只有自己可以访问的文件。只有当应用程序被卸载时，系统才会清除该目录。在iOS上，这对应于NSDocumentDirectory。在Android上，这是AppData目录。 外部存储目录：可以使用getExternalStorageDirectory()来获取外部存储目录，如SD卡；由于iOS不支持外部目录，所以在iOS下调用该方法会抛出UnsupportedError异常，而在Android下结果是android SDK中getExternalStorageDirectory的返回值。 一旦你的Flutter应用程序有一个文件位置的引用，你可以使用dart:ioAPI来执行对文件系统的读/写操作。有关使用Dart处理文件和目录的详细内容可以参考Dart语言文档，下面我们看一个简单的例子。 示例 我们还是以计数器为例，实现在应用退出重启后可以恢复点击次数。 这里，我们使用文件来保存数据： 引入PathProvider插件；在pubspec.yaml文件中添加如下声明： path_provider: ^0.4.1 添加后，执行flutter packages get 获取一下, 版本号可能随着时间推移会发生变化，读者可以使用最新版。 实现： import 'dart:io'; import 'dart:async'; import 'package:flutter/material.dart'; import 'package:path_provider/path_provider.dart'; class FileOperationRoute extends StatefulWidget { FileOperationRoute({Key key}) : super(key: key); @override _FileOperationRouteState createState() => new _FileOperationRouteState(); } class _FileOperationRouteState extends State { int _counter; @override void initState() { super.initState(); //从文件读取点击次数 _readCounter().then((int value) { setState(() { _counter = value; }); }); } Future _getLocalFile() async { // 获取应用目录 String dir = (await getApplicationDocumentsDirectory()).path; return new File('$dir/counter.txt'); } Future _readCounter() async { try { File file = await _getLocalFile(); // 读取点击次数（以字符串） String contents = await file.readAsString(); return int.parse(contents); } on FileSystemException { return 0; } } Future _incrementCounter() async { setState(() { _counter++; }); // 将点击次数以字符串类型写到文件中 await (await _getLocalFile()).writeAsString('$_counter'); } @override Widget build(BuildContext context) { return new Scaffold( appBar: new AppBar(title: new Text('文件操作')), body: new Center( child: new Text('点击了 $_counter 次'), ), floatingActionButton: new FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: new Icon(Icons.add), ), ); } } 上面代码比较简单，不再赘述，需要说明的是，本示例只是为了演示文件读写，而在实际开发中，如果要存储一些简单的数据，使用shared_preferences插件会比较简单。 注意，Dart IO库操作文件的API非常丰富，但本书不是介绍Dart语言的，故不详细说明，读者需要的话可以自行学习。 "},"chapter10/http.html":{"url":"chapter10/http.html","title":"Http请求-HttpClient","keywords":"","body":"通过HttpClient发起HTTP请求 Dart IO库中提供了Http请求的一些类，我们可以直接使用HttpClient来发起请求。使用HttpClient发起请求分为五步： 创建一个HttpClient HttpClient httpClient = new HttpClient(); 打开Http连接，设置请求头 HttpClientRequest request = await httpClient.getUrl(uri); 这一步可以使用任意Http method，如httpClient.post(...)、httpClient.delete(...)等。如果包含Query参数，可以在构建uri时添加，如： Uri uri=Uri(scheme: \"https\", host: \"flutterchina.club\", queryParameters: { \"xx\":\"xx\", \"yy\":\"dd\" }); 通过HttpClientRequest可以设置请求header，如： request.headers.add(\"user-agent\", \"test\"); 如果是post或put等可以携带请求体方法，可以通过HttpClientRequest对象发送request body，如： String payload=\"...\"; request.add(utf8.encode(payload)); //request.addStream(_inputStream); //可以直接添加输入流 等待连接服务器 HttpClientResponse response = await request.close(); 这一步完成后，请求信息就已经发送给服务器了，返回一个HttpClientResponse对象，它包含响应头（header）和响应流(响应体的Stream)，接下来就可以通过读取响应流来获取响应内容。 读取响应内容 String responseBody = await response.transform(utf8.decoder).join(); 我们通过读取响应流来获取服务器返回的数据，在读取时我们可以设置编码格式，这里是utf8。 请求结束，关闭HttpClient httpClient.close(); 关闭client后，通过该client发起的所有请求都会中止。 示例 我们实现一个获取百度首页html的例子，示例效果如下： ​ 点击“获取百度首页”按钮后，会请求百度首页，请求成功后，我们将返回内容显示出来并在控制台打印响应header，代码如下： import 'dart:convert'; import 'dart:io'; import 'package:flutter/material.dart'; class HttpTestRoute extends StatefulWidget { @override _HttpTestRouteState createState() => new _HttpTestRouteState(); } class _HttpTestRouteState extends State { bool _loading = false; String _text = \"\"; @override Widget build(BuildContext context) { return ConstrainedBox( constraints: BoxConstraints.expand(), child: SingleChildScrollView( child: Column( children: [ RaisedButton( child: Text(\"获取百度首页\"), onPressed: _loading ? null : () async { setState(() { _loading = true; _text = \"正在请求...\"; }); try { //创建一个HttpClient HttpClient httpClient = new HttpClient(); //打开Http连接 HttpClientRequest request = await httpClient.getUrl( Uri.parse(\"https://www.baidu.com\")); //使用iPhone的UA request.headers.add(\"user-agent\", \"Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1\"); //等待连接服务器（会将请求信息发送给服务器） HttpClientResponse response = await request.close(); //读取响应内容 _text = await response.transform(utf8.decoder).join(); //输出响应头 print(response.headers); //关闭client后，通过该client发起的所有请求都会中止。 httpClient.close(); } catch (e) { _text = \"请求失败：$e\"; } finally { setState(() { _loading = false; }); } } ), Container( width: MediaQuery.of(context).size.width-50.0, child: Text(_text.replaceAll(new RegExp(r\"\\s\"), \"\")) ) ], ), ), ); } } 控制台输出： I/flutter (18545): connection: Keep-Alive I/flutter (18545): cache-control: no-cache I/flutter (18545): set-cookie: .... //有多个，省略... I/flutter (18545): transfer-encoding: chunked I/flutter (18545): date: Tue, 30 Oct 2018 10:00:52 GMT I/flutter (18545): content-encoding: gzip I/flutter (18545): vary: Accept-Encoding I/flutter (18545): strict-transport-security: max-age=172800 I/flutter (18545): content-type: text/html;charset=utf-8 I/flutter (18545): tracecode: 00525262401065761290103018, 00522983 HttpClient配置 HttpClient有很多属性可以配置，常用的属性列表如下： 属性 含义 idleTimeout 对应请求头中的keep-alive字段值，为了避免频繁建立连接，httpClient在请求结束后会保持连接一段时间，超过这个阈值后才会关闭连接。 connectionTimeout 和服务器建立连接的超时，如果超过这个值则会抛出SocketException异常。 maxConnectionsPerHost 同一个host，同时允许建立连接的最大数量。 autoUncompress 对应请求头中的Content-Encoding，如果设置为true，则请求头中Content-Encoding的值为当前HttpClient支持的压缩算法列表，目前只有\"gzip\" userAgent 对应请求头中的User-Agent字段。 可以发现，有些属性只是为了更方便的设置请求头，对于这些属性，你完全可以通过HttpClientRequest直接设置header，不同的是通过HttpClient设置的对整个httpClient都生效，而通过HttpClientRequest设置的只对当前请求生效。 HTTP请求认证 Http协议的认证（Authentication）机制可以用于保护非公开资源。如果Http服务器开启了认证，那么用户在发起请求时就需要携带用户凭据，如果你在浏览器中访问了启用Basic认证的资源时，浏览就会弹出一个登录框，如： 我们先看看Basic认证的基本过程： 客户端发送http请求给服务器，服务器验证该用户是否已经登录验证过了，如果没有的话， 服务器会返回一个401 Unauthozied给客户端，并且在响应header中添加一个 “WWW-Authenticate” 字段，例如： WWW-Authenticate: Basic realm=\"admin\" 其中\"Basic\"为认证方式，realm为用户角色的分组，可以在后台添加分组。 客户端得到响应码后，将用户名和密码进行base64编码（格式为用户名:密码），设置请求头Authorization，继续访问 : Authorization: Basic YXXFISDJFISJFGIJIJG 服务器验证用户凭据，如果通过就返回资源内容。 注意，Http的方式除了Basic认证之外还有：Digest认证、Client认证、Form Based认证等，目前Flutter的HttpClient只支持Basic和Digest两种认证方式，这两种认证方式最大的区别是发送用户凭据时，对于用户凭据的内容，前者只是简单的通过Base64编码（可逆），而后者会进行哈希运算，相对来说安全一点点，但是为了安全起见，无论是采用Basic认证还是Digest认证，都应该在Https协议下，这样可以防止抓包和中间人攻击。 HttpClient关于Http认证的方法和属性： addCredentials(Uri url, String realm, HttpClientCredentials credentials) 该方法用于添加用户凭据,如： httpClient.addCredentials(_uri, \"admin\", new HttpClientBasicCredentials(\"username\",\"password\"), //Basic认证凭据 ); 如果是Digest认证，可以创建Digest认证凭据： HttpClientDigestCredentials(\"username\",\"password\") authenticate(Future f(Uri url, String scheme, String realm)) 这是一个setter，类型是一个回调，当服务器需要用户凭据且该用户凭据未被添加时，httpClient会调用此回调，在这个回调当中，一般会调用addCredential()来动态添加用户凭证，例如： httpClient.authenticate=(Uri url, String scheme, String realm) async{ if(url.host==\"xx.com\" && realm==\"admin\"){ httpClient.addCredentials(url, \"admin\", new HttpClientBasicCredentials(\"username\",\"pwd\"), ); return true; } return false; }; 一个建议是，如果所有请求都需要认证，那么应该在HttpClient初始化时就调用addCredentials()来添加全局凭证，而不是去动态添加。 代理 可以通过findProxy来设置代理策略，例如，我们要将所有请求通过代理服务器（192.168.1.2:8888）发送出去： client.findProxy = (uri) { // 如果需要过滤uri，可以手动判断 return \"PROXY 192.168.1.2:8888\"; }; findProxy 回调返回值是一个遵循浏览器PAC脚本格式的字符串，详情可以查看API文档，如果不需要代理，返回\"DIRECT\"即可。 在APP开发中，很多时候我们需要抓包来调试，而抓包软件(如charles)就是一个代理，这时我们就可以将请求发送到我们的抓包软件，我们就可以在抓包软件中看到请求的数据了。 有时代理服务器也启用了身份验证，这和http协议的认证是相似的，HttpClient提供了对应的Proxy认证方法和属性： set authenticateProxy( Future f(String host, int port, String scheme, String realm)); void addProxyCredentials( String host, int port, String realm, HttpClientCredentials credentials); 他们的使用方法和上面“HTTP请求认证”一节中介绍的addCredentials和authenticate 相同，故不再赘述。 证书校验 Https中为了防止通过伪造证书而发起的中间人攻击，客户端应该对自签名或非CA颁发的证书进行校验。HttpClient对证书校验的逻辑如下： 如果请求的Https证书是可信CA颁发的，并且访问host包含在证书的domain列表中(或者符合通配规则)并且证书未过期，则验证通过。 如果第一步验证失败，但在创建HttpClient时，已经通过SecurityContext将证书添加到证书信任链中，那么当服务器返回的证书在信任链中的话，则验证通过。 如果1、2验证都失败了，如果用户提供了badCertificateCallback回调，则会调用它，如果回调返回true，则允许继续链接，如果返回false，则终止链接。 综上所述，我们的证书校验其实就是提供一个badCertificateCallback回调，下面通过一个示例来说明。 示例 假设我们的后台服务使用的是自签名证书，证书格式是PEM格式，我们将证书的内容保存在本地字符串中，那么我们的校验逻辑如下： String PEM=\"XXXXX\";//可以从文件读取 ... httpClient.badCertificateCallback=(X509Certificate cert, String host, int port){ if(cert.pem==PEM){ return true; //证书一致，则允许发送数据 } return false; }; X509Certificate是证书的标准格式，包含了证书除私钥外所有信息，读者可以自行查阅文档。另外，上面的示例没有校验host，是因为只要服务器返回的证书内容和本地的保存一致就已经能证明是我们的服务器了（而不是中间人），host验证通常是为了防止证书和域名不匹配。 对于自签名的证书，我们也可以将其添加到本地证书信任链中，这样证书验证时就会自动通过，而不会再走到badCertificateCallback回调中： SecurityContext sc=new SecurityContext(); //file为证书路径 sc.setTrustedCertificates(file); //创建一个HttpClient HttpClient httpClient = new HttpClient(context: sc); 注意，通过setTrustedCertificates()设置的证书格式必须为PEM或PKCS12，如果证书格式为PKCS12，则需将证书密码传入，这样则会在代码中暴露证书密码，所以客户端证书校验不建议使用PKCS12格式的证书。 总结 值得注意的是，HttpClient提供的这些属性和方法最终都会作用在请求header里，我们完全可以通过手动去设置header来实现，之所以提供这些方法，只是为了方便开发者而已。另外，Http协议是一个非常重要的、使用最多的网络协议，每一个开发者都应该对http协议非常熟悉。 "},"chapter10/dio.html":{"url":"chapter10/dio.html","title":"Http请求-Dio package","keywords":"","body":"网络操作 Dio http库 通过上一节介绍，我们可以发现直接使用HttpClient发起网络请求是比较麻烦的，很多事情得我们手动处理，如果再涉及到文件上传/下载、Cookie管理等就会非常繁琐。幸运的是，Dart社区有一些第三方http请求库，用它们来发起http请求将会简单的多，本节我们介绍一下目前人气较高的dio库。 dio是一个强大的Dart Http请求库，支持Restful API、FormData、拦截器、请求取消、Cookie管理、文件上传/下载、超时等。 引入 引入dio: dependencies: dio: ^x.x.x #请使用pub上的最新版本 导入并创建dio实例： import 'package:dio/dio.dart'; Dio dio = new Dio(); 接下来就可以通过 dio实例来发起网络请求了，注意，一个dio实例可以发起多个http请求，一般来说，APP只有一个http数据源时，dio应该使用单例模式。 示例 发起 GET 请求 : Response response; response=await dio.get(\"/test?id=12&name=wendu\") print(response.data.toString()); 对于GET请求我们可以将query参数通过对象来传递，上面的代码等同于： response=await dio.get(\"/test\",queryParameters:{\"id\":12,\"name\":\"wendu\"}) print(response); 发起一个 POST 请求: response=await dio.post(\"/test\",data:{\"id\":12,\"name\":\"wendu\"}) 发起多个并发请求: response= await Future.wait([dio.post(\"/info\"),dio.get(\"/token\")]); 下载文件: response=await dio.download(\"https://www.google.com/\",_savePath); 发送 FormData: FormData formData = new FormData.from({ \"name\": \"wendux\", \"age\": 25, }); response = await dio.post(\"/info\", data: formData) 如果发送的数据是FormData，则dio会将请求header的contentType设为“multipart/form-data”。 通过FormData上传多个文件: FormData formData = new FormData.from({ \"name\": \"wendux\", \"age\": 25, \"file1\": new UploadFileInfo(new File(\"./upload.txt\"), \"upload1.txt\"), \"file2\": new UploadFileInfo(new File(\"./upload.txt\"), \"upload2.txt\"), // 支持文件数组上传 \"files\": [ new UploadFileInfo(new File(\"./example/upload.txt\"), \"upload.txt\"), new UploadFileInfo(new File(\"./example/upload.txt\"), \"upload.txt\") ] }); response = await dio.post(\"/info\", data: formData) 值得一提的是，dio内部仍然使用HttpClient发起的请求，所以代理、请求认证、证书校验等和HttpClient是相同的，我们可以在onHttpClientCreate回调中设置，例如： (dio.httpClientAdapter as DefaultHttpClientAdapter).onHttpClientCreate = (client) { //设置代理 client.findProxy = (uri) { return \"PROXY 192.168.1.2:8888\"; }; //校验证书 httpClient.badCertificateCallback=(X509Certificate cert, String host, int port){ if(cert.pem==PEM){ return true; //证书一致，则允许发送数据 } return false; }; }; 注意，onHttpClientCreate会在当前dio实例内部需要创建HttpClient时调用，所以通过此回调配置HttpClient会对整个dio实例生效，如果你想针对某个应用请求单独的代理或证书校验策略，可以创建一个新的dio实例即可。 怎么样，是不是很简单，除了这些基本的用法，dio还支持请求配置、拦截器等，官方资料比较详细，故本书不再赘述，详情可以参考dio主页：https://github.com/flutterchina/dio 。 下一节我们将使用dio实现一个分块下载器。 "},"chapter10/download_with_chunks.html":{"url":"chapter10/download_with_chunks.html","title":"实例：Http分块下载","keywords":"","body":"实例：Http分块下载 Http协议定义了分块传输的响应header字段，但具体是否支持取决于Server的实现，我们可以指定请求头的\"range\"字段来验证服务器是否支持分块传输。例如，我们可以利用curl命令来验证： bogon:~ duwen$ curl -H \"Range: bytes=0-10\" http://download.dcloud.net.cn/HBuilder.9.0.2.macosx_64.dmg -v # 请求头 > GET /HBuilder.9.0.2.macosx_64.dmg HTTP/1.1 > Host: download.dcloud.net.cn > User-Agent: curl/7.54.0 > Accept: */* > Range: bytes=0-10 #响应头 我们在请求头中添加\"Range: bytes=0-10\"的作用是，告诉服务器本次请求我们只想获取文件0-10(包括10，共11字节)这块内容。如果服务器支持分块传输的话，则响应状态码为206，表示“部分内容”，并且同时响应头中变会包含”Content-Range“字段，如果不支持则不会包含，我们看看上面\"Content-Range\"的内容： Content-Range: bytes 0-10/233295878 0-10表示本次返回的区块，233295878代表文件的总长度，单位都是byte, 也就是该文件大概233M多一点。 基于此，我们可以设计一个简单的多线程的文件分块下载器，实现的思路是： 先检测是否支持分块传输，如果不支持，则直接下载；若支持，则将剩余内容分块下载。 各个分块下载时保存到各自临时文件，等到所有分块下载完后合并临时文件。 删除临时文件。 下面是整体的流程： // 通过第一个分块请求检测服务器是否支持分块传输 Response response = await downloadChunk(url, 0, firstChunkSize, 0); if (response.statusCode == 206) { //如果支持 //解析文件总长度，进而算出剩余长度 total = int.parse( response.headers.value(HttpHeaders.contentRangeHeader).split(\"/\").last); int reserved = total - int.parse(response.headers.value(HttpHeaders.contentLengthHeader)); //文件的总块数(包括第一块) int chunk = (reserved / firstChunkSize).ceil() + 1; if (chunk > 1) { int chunkSize = firstChunkSize; if (chunk > maxChunk + 1) { chunk = maxChunk + 1; chunkSize = (reserved / maxChunk).ceil(); } var futures = []; for (int i = 0; i 下面我们使用dio的download API 实现downloadChunk： //start 代表当前块的起始位置，end代表结束位置 //no 代表当前是第几块 Future downloadChunk(url, start, end, no) async { progress.add(0); //progress记录每一块已接收数据的长度 --end; return dio.download( url, savePath + \"temp$no\", //临时文件按照块的序号命名，方便最后合并 onReceiveProgress: createCallback(no), // 创建进度回调，后面实现 options: Options( headers: {\"range\": \"bytes=$start-$end\"}, //指定请求的内容区间 ), ); } 接下来实现mergeTempFiles: Future mergeTempFiles(chunk) async { File f = File(savePath + \"temp0\"); IOSink ioSink= f.openWrite(mode: FileMode.writeOnlyAppend); //合并临时文件 for (int i = 1; i 下面我们看一下完整实现： /// Downloading by spiting as file in chunks Future downloadWithChunks( url, savePath, { ProgressCallback onReceiveProgress, }) async { const firstChunkSize = 102; const maxChunk = 3; int total = 0; var dio = Dio(); var progress = []; createCallback(no) { return (int received, _) { progress[no] = received; if (onReceiveProgress != null && total != 0) { onReceiveProgress(progress.reduce((a, b) => a + b), total); } }; } Future downloadChunk(url, start, end, no) async { progress.add(0); --end; return dio.download( url, savePath + \"temp$no\", onReceiveProgress: createCallback(no), options: Options( headers: {\"range\": \"bytes=$start-$end\"}, ), ); } Future mergeTempFiles(chunk) async { File f = File(savePath + \"temp0\"); IOSink ioSink= f.openWrite(mode: FileMode.writeOnlyAppend); for (int i = 1; i 1) { int chunkSize = firstChunkSize; if (chunk > maxChunk + 1) { chunk = maxChunk + 1; chunkSize = (reserved / maxChunk).ceil(); } var futures = []; for (int i = 0; i 现在可以进行分块下载了： main() async { var url = \"http://download.dcloud.net.cn/HBuilder.9.0.2.macosx_64.dmg\"; var savePath = \"./example/HBuilder.9.0.2.macosx_64.dmg\"; await downloadWithChunks(url, savePath, onReceiveProgress: (received, total) { if (total != -1) { print(\"${(received / total * 100).floor()}%\"); } }); } 思考 分块下载真的能提高下载速度吗？ 其实下载速度的主要瓶颈是取决于网络速度和服务器的出口速度，如果是同一个数据源，分块下载的意义并不大，因为服务器是同一个，出口速度确定的，主要取决于网速，而上面的例子正式同源分块下载，读者可以自己对比一下分块和不分块的的下载速度。如果有多个下载源，并且每个下载源的出口带宽都是有限制的，这时分块下载可能会更快一下，之所以说“可能”，是由于这并不是一定的，比如有三个源，三个源的出口带宽都为1G/s，而我们设备所连网络的峰值假设只有800M/s，那么瓶颈就在我们的网络。即使我们设备的带宽大于任意一个源，下载速度依然不一定就比单源单线下载快，试想一下，假设有两个源A和B，速度A源是B源的3倍，如果采用分块下载，两个源各下载一半的话，读者可以算一下所需的下载时间，然后再算一下只从A源下载所需的时间，看看哪个更快。 分块下载的最终速度受设备所在网络带宽、源出口速度、每个块大小、以及分块的数量等诸多因素影响，实际过程中很难保证速度最优。在实际开发中，读者可可以先测试对比后再决定是否使用。 分块下载有什么实际的用处吗？ 分块下载还有一个比较使用的场景是断点续传，可以将文件分为若干个块，然后维护一个下载状态文件用以记录每一个块的状态，这样即使在网络中断后，也可以恢复中断前的状态，具体实现读者可以自己尝试一下，还是有一些细节需要特别注意的，比如分块大小多少合适？下载到一半的块如何处理？要不要维护一个任务队列？ "},"chapter10/websocket.html":{"url":"chapter10/websocket.html","title":"WebSocket","keywords":"","body":"使用WebSockets Http协议是无状态的，只能由客户端主动发起，服务端再被动响应，服务端无法向客户端主动推送内容，并且一旦服务器响应结束，链接就会断开(见注解部分)，所以无法进行实时通信。WebSocket协议正是为解决客户端与服务端实时通信而产生的技术，现在已经被主流浏览器支持，所以对于Web开发者来说应该比较熟悉了，Flutter也提供了专门的包来支持WebSocket协议。 注意：Http协议中虽然可以通过keep-alive机制使服务器在响应结束后链接会保持一段时间，但最终还是会断开，keep-alive机制主要是用于避免在同一台服务器请求多个资源时频繁创建链接，它本质上是支持链接复用的技术，而并非用于实时通信，读者需要知道这两者的区别。 WebSocket协议本质上是一个基于tcp的协议，它是先通过HTTP协议发起一条特殊的http请求进行握手后，如果服务端支持WebSocket协议，则会进行协议升级。WebSocket会使用http协议握手后创建的tcp链接，和http协议不同的是，WebSocket的tcp链接是个长链接（不会断开），所以服务端与客户端就可以通过此TCP连接进行实时通信。有关WebSocket协议细节，读者可以看RFC文档，下面我们重点看看Flutter中如何使用WebSocket。 在接下来例子中，我们将连接到由websocket.org提供的测试服务器。服务器将简单地返回我们发送给它的相同消息！ 步骤 连接到WebSocket服务器。 监听来自服务器的消息。 将数据发送到服务器。 关闭WebSocket连接。 1. 连接到WebSocket服务器 web_socket_channel package 提供了我们需要连接到WebSocket服务器的工具. 该package提供了一个WebSocketChannel允许我们既可以监听来自服务器的消息，又可以将消息发送到服务器的方法。 在Flutter中，我们可以创建一个WebSocketChannel连接到一台服务器： final channel = new IOWebSocketChannel.connect('ws://echo.websocket.org'); 2. 监听来自服务器的消息 现在我们建立了连接，我们可以监听来自服务器的消息，在我们发送消息给测试服务器之后，它会返回相同的消息。 我们如何收取消息并显示它们？在这个例子中，我们将使用一个StreamBuilder Widget来监听新消息， 并用一个Text Widget来显示它们。 new StreamBuilder( stream: widget.channel.stream, builder: (context, snapshot) { return new Text(snapshot.hasData ? '${snapshot.data}' : ''); }, ); 工作原理 WebSocketChannel提供了一个来自服务器的消息Stream 。 该Stream类是dart:async包中的一个基础类。它提供了一种方法来监听来自数据源的异步事件。与Future返回单个异步响应不同，Stream类可以随着时间推移传递很多事件。 该StreamBuilder Widget将连接到一个Stream， 并在每次收到消息时通知Flutter重新构建界面。 3. 将数据发送到服务器 为了将数据发送到服务器，我们会add消息给WebSocketChannel提供的sink。 channel.sink.add('Hello!'); 工作原理 WebSocketChannel提供了一个StreamSink，它将消息发给服务器。 StreamSink类提供了给数据源同步或异步添加事件的一般方法。 4. 关闭WebSocket连接 在我们使用WebSocket后，要关闭连接： channel.sink.close(); 完整的例子 import 'package:flutter/material.dart'; import 'package:web_socket_channel/io.dart'; class WebSocketRoute extends StatefulWidget { @override _WebSocketRouteState createState() => new _WebSocketRouteState(); } class _WebSocketRouteState extends State { TextEditingController _controller = new TextEditingController(); IOWebSocketChannel channel; String _text = \"\"; @override void initState() { //创建websocket连接 channel = new IOWebSocketChannel.connect('ws://echo.websocket.org'); } @override Widget build(BuildContext context) { return new Scaffold( appBar: new AppBar( title: new Text(\"WebSocket(内容回显)\"), ), body: new Padding( padding: const EdgeInsets.all(20.0), child: new Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ new Form( child: new TextFormField( controller: _controller, decoration: new InputDecoration(labelText: 'Send a message'), ), ), new StreamBuilder( stream: channel.stream, builder: (context, snapshot) { //网络不通会走到这 if (snapshot.hasError) { _text = \"网络不通...\"; } else if (snapshot.hasData) { _text = \"echo: \"+snapshot.data; } return new Padding( padding: const EdgeInsets.symmetric(vertical: 24.0), child: new Text(_text), ); }, ) ], ), ), floatingActionButton: new FloatingActionButton( onPressed: _sendMessage, tooltip: 'Send message', child: new Icon(Icons.send), ), ); } void _sendMessage() { if (_controller.text.isNotEmpty) { channel.sink.add(_controller.text); } } @override void dispose() { channel.sink.close(); super.dispose(); } } 上面的例子比较简单，不再赘述。我们现在思考一个问题，假如我们想通过WebSocket传输二进制数据应该怎么做（比如要从服务器接收一张图片）？我们发现StreamBuilder和Stream都没有指定接收类型的参数，并且在创建WebSocket链接时也没有相应的配置，貌似没有什么办法……其实很简单，要接收二进制数据仍然使用StreamBuilder，因为WebSocket中所有发送的数据使用帧的形式发送，而帧是有固定格式，每一个帧的数据类型都可以通过Opcode字段指定，它可以指定当前帧是文本类型还是二进制类型（还有其它类型），所以客户端在收到帧时就已经知道了其数据类型，所以flutter完全可以在收到数据后解析出正确的类型，所以就无需开发者去关心，当服务器传输的数据是指定为二进制时，StreamBuilder的snapshot.data的类型就是List，是文本时，则为String。 "},"chapter10/socket.html":{"url":"chapter10/socket.html","title":"使用Socket API","keywords":"","body":"Socket 我们之前介绍的Http协议和WebSocket协议都属于应用层协议，除了它们，应用层协议还有很多如：SMTP、FTP等，它们都是通过Socket实现的。其实，操作系统中提供的原生网络请求API是标准的，在C语言的Socket库中，它主要提供了端到端建立链接和发送数据的基础API，而高级编程语言中的Socket库其实都是对操作系统的socket API的一个封装。所以，如果我们需要自定义协议或者想直接来控制管理网络链接、又或者我们觉得自带的HttpClient不好用想重新实现一个，这时我们就需要使用Socket。Flutter的Socket API在dart io包中，下面我们看一个使用Socket实现简单http请求的示例，以请求百度首页为例： _request() async{ //建立连接 var socket=await Socket.connect(\"baidu.com\", 80); //根据http协议，发送请求头 socket.writeln(\"GET / HTTP/1.1\"); socket.writeln(\"Host:baidu.com\"); socket.writeln(\"Connection:close\"); socket.writeln(); await socket.flush(); //发送 //读取返回内容 _response =await socket.transform(utf8.decoder).join(); await socket.close(); } 可以看到，使用Socket需要我们自己实现Http协议细节，本例只是一个简单示例，没有处理重定向、cookie等。本示例完整代码参考示例demo，运行后如下： 可以看到响应内容分两个部分，第一部分是响应头，第二部分是响应体，服务端可以根据请求信息动态来输出响应体。由于本示例请求头比较简单，所以响应体和浏览器中访问的会有差别，读者可以补充一些请求头(如user-agent)来看看输出的变化。 "},"chapter10/json_model.html":{"url":"chapter10/json_model.html","title":"Json转Model","keywords":"","body":"Json Model 在实战中，后台接口往往会返回一些结构化数据，如JSON、XML等，如之前我们请求Github API的示例，它返回的数据就是JSON格式的字符串，为了方便我们在代码中操作JSON，我们先将JSON格式的字符串转为Dart对象，这个可以通过dart:convert中内置的JSON解码器json.decode() 来实现，该方法可以根据JSON字符串具体内容将其转为List或Map，这样我们就可以通过他们来查找所需的值，如： //一个JSON格式的用户列表字符串 String jsonStr='[{\"name\":\"Jack\"},{\"name\":\"Rose\"}]'; //将JSON字符串转为Dart对象(此处是List) List items=json.decode(jsonStr); //输出第一个用户的姓名 print(items[0][\"name\"]); 通过json.decode() 将JSON字符串转为List/Map的方法比较简单，它没有外部依赖或其它的设置，对于小项目很方便。但当项目变大时，这种手动编写序列化逻辑可能变得难以管理且容易出错，例如有如下JSON: { \"name\": \"John Smith\", \"email\": \"john@example.com\" } 我们可以通过调用json.decode方法来解码JSON ，使用JSON字符串作为参数: Map user = json.decode(json); print('Howdy, ${user['name']}!'); print('We sent the verification link to ${user['email']}.'); 由于json.decode()仅返回一个Map，这意味着直到运行时我们才知道值的类型。 通过这种方法，我们失去了大部分静态类型语言特性：类型安全、自动补全和最重要的编译时异常。这样一来，我们的代码可能会变得非常容易出错。例如，当我们访问name或email字段时，我们输入的很快，导致字段名打错了。但由于这个JSON在map结构中，所以编译器不知道这个错误的字段名，所以编译时不会报错。 其实，这个问题在很多平台上都会遇到，而也早就有了好的解决方法即“Json Model化”，具体做法就是，通过预定义一些与Json结构对应的Model类，然后在请求到数据后再动态根据数据创建出Model类的实例。这样一来，在开发阶段我们使用的是Model类的实例，而不再是Map/List，这样访问内部属性时就不会发生拼写错误。例如，我们可以通过引入一个简单的模型类(Model class)来解决前面提到的问题，我们称之为User。在User类内部，我们有： 一个User.fromJson 构造函数, 用于从一个map构造出一个 User实例 map structure 一个toJson 方法, 将 User 实例转化为一个map. 这样，调用代码现在可以具有类型安全、自动补全字段（name和email）以及编译时异常。如果我们将拼写错误字段视为int类型而不是String， 那么我们的代码就不会通过编译，而不是在运行时崩溃。 user.dart class User { final String name; final String email; User(this.name, this.email); User.fromJson(Map json) : name = json['name'], email = json['email']; Map toJson() => { 'name': name, 'email': email, }; } 现在，序列化逻辑移到了模型本身内部。采用这种新方法，我们可以非常容易地反序列化user. Map userMap = json.decode(json); var user = new User.fromJson(userMap); print('Howdy, ${user.name}!'); print('We sent the verification link to ${user.email}.'); 要序列化一个user，我们只是将该User对象传递给该json.encode方法。我们不需要手动调用toJson这个方法，因为`JSON.encode内部会自动调用。 String json = json.encode(user); 这样，调用代码就不用担心JSON序列化了，但是，Model类还是必须的。在实践中，User.fromJson和User.toJson方法都需要单元测试到位，以验证正确的行为。 另外，实际场景中，JSON对象很少会这么简单，嵌套的JSON对象并不罕见，如果有什么能为我们自动处理JSON序列化，那将会非常好。幸运的是，有！ 自动生成Model 尽管还有其他库可用，但在本书中，我们介绍一下官方推荐的json_serializable package包。 它是一个自动化的源代码生成器，可以在开发阶段为我们生成JSON序列化模板，这样一来，由于序列化代码不再由我们手写和维护，我们将运行时产生JSON序列化异常的风险降至最低。 在项目中设置json_serializable 要包含json_serializable到我们的项目中，我们需要一个常规和两个开发依赖项。简而言之，开发依赖项是不包含在我们的应用程序源代码中的依赖项，它是开发过程中的一些辅助工具、脚本，和node中的开发依赖项相似。 pubspec.yaml dependencies: # Your other regular dependencies here json_annotation: ^2.0.0 dev_dependencies: # Your other dev_dependencies here build_runner: ^1.0.0 json_serializable: ^2.0.0 在您的项目根文件夹中运行 flutter packages get (或者在编辑器中点击 “Packages Get”) 以在项目中使用这些新的依赖项. 以json_serializable的方式创建model类 让我们看看如何将我们的User类转换为一个json_serializable。为了简单起见，我们使用前面示例中的简化JSON model。 user.dart import 'package:json_annotation/json_annotation.dart'; // user.g.dart 将在我们运行生成命令后自动生成 part 'user.g.dart'; ///这个标注是告诉生成器，这个类是需要生成Model类的 @JsonSerializable() class User{ User(this.name, this.email); String name; String email; //不同的类使用不同的mixin即可 factory User.fromJson(Map json) => _$UserFromJson(json); Map toJson() => _$UserToJson(this); } 有了上面的设置，源码生成器将生成用于序列化name和email字段的JSON代码。 如果需要，自定义命名策略也很容易。例如，如果我们正在使用的API返回带有snake_case的对象，但我们想在我们的模型中使用lowerCamelCase， 那么我们可以使用@JsonKey标注： //显式关联JSON字段名与Model属性的对应关系 @JsonKey(name: 'registration_date_millis') final int registrationDateMillis; 运行代码生成程序 json_serializable第一次创建类时，您会看到与下图类似的错误。 这些错误是完全正常的，这是因为Model类的生成代码还不存在。为了解决这个问题，我们必须运行代码生成器来为我们生成序列化模板。有两种运行代码生成器的方法： 一次性生成 通过在我们的项目根目录下运行: flutter packages pub run build_runner build 这触发了一次性构建，我们可以在需要时为我们的Model生成json序列化代码，它通过我们的源文件，找出需要生成Model类的源文件（包含@JsonSerializable标注的）来生成对应的.g.dart文件。一个好的建议是将所有Model类放在一个单独的目录下，然后在该目录下执行命令。 虽然这非常方便，但如果我们不需要每次在Model类中进行更改时都要手动运行构建命令的话会更好。 持续生成 使用watcher可以使我们的源代码生成的过程更加方便。它会监视我们项目中文件的变化，并在需要时自动构建必要的文件，我们可以通过flutter packages pub run build_runner watch在项目根目录下运行来启动watcher。只需启动一次观察器，然后它就会在后台运行，这是安全的。 自动化生成模板 上面的方法有一个最大的问题就是要为每一个json写模板，这是比较枯燥的。如果有一个工具可以直接根据JSON文本生成模板，那我们就能彻底解放双手了。笔者自己用dart实现了一个脚本，它可以自动生成模板，并直接将JSON转为Model类，下面我们看看怎么做： 定义一个\"模板的模板\"，名为\"template.dart\"： import 'package:json_annotation/json_annotation.dart'; %t part '%s.g.dart'; @JsonSerializable() class %s { %s(); %s factory %s.fromJson(Map json) => _$%sFromJson(json); Map toJson() => _$%sToJson(this); } 模板中的“%t”、“%s”为占位符，将在脚本运行时动态被替换为合适的导入头和类名。 写一个自动生成模板的脚本(mo.dart)，它可以根据指定的JSON目录，遍历生成模板，在生成时我们定义一些规则： 如果JSON文件名以下划线“_”开始，则忽略此JSON文件。 复杂的JSON对象往往会出现嵌套，我们可以通过一个特殊标志来手动指定嵌套的对象（后面举例）。 脚本我们通过Dart来写，源码如下： import 'dart:convert'; import 'dart:io'; import 'package:path/path.dart' as path; const TAG=\"\\$\"; const SRC=\"./json\"; //JSON 目录 const DIST=\"lib/models/\"; //输出model目录 void walk() { //遍历JSON目录生成模板 var src = new Directory(SRC); var list = src.listSync(); var template=new File(\"./template.dart\").readAsStringSync(); File file; list.forEach((f) { if (FileSystemEntity.isFileSync(f.path)) { file = new File(f.path); var paths=path.basename(f.path).split(\".\"); String name=paths.first; if(paths.last.toLowerCase()!=\"json\"||name.startsWith(\"_\")) return ; if(name.startsWith(\"_\")) return; //下面生成模板 var map = json.decode(file.readAsStringSync()); //为了避免重复导入相同的包，我们用Set来保存生成的import语句。 var set= new Set(); StringBuffer attrs= new StringBuffer(); (map as Map).forEach((key, v) { if(key.startsWith(\"_\")) return ; attrs.write(getType(v,set,name)); attrs.write(\" \"); attrs.write(key); attrs.writeln(\";\"); attrs.write(\" \"); }); String className=name[0].toUpperCase()+name.substring(1); var dist=format(template,[name,className,className,attrs.toString(), className,className,className]); var _import=set.join(\";\\r\\n\"); _import+=_import.isEmpty?\"\":\";\"; dist=dist.replaceFirst(\"%t\",_import ); //将生成的模板输出 new File(\"$DIST$name.dart\").writeAsStringSync(dist); } }); } String changeFirstChar(String str, [bool upper=true] ){ return (upper?str[0].toUpperCase():str[0].toLowerCase())+str.substring(1); } //将JSON类型转为对应的dart类型 String getType(v,Set set,String current){ current=current.toLowerCase(); if(v is bool){ return \"bool\"; }else if(v is num){ return \"num\"; }else if(v is Map){ return \"Map\"; }else if(v is List){ return \"List\"; }else if(v is String){ //处理特殊标志 if(v.startsWith(\"$TAG[]\")){ var className=changeFirstChar(v.substring(3),false); if(className.toLowerCase()!=current) { set.add('import \"$className.dart\"'); } return \"List\"; }else if(v.startsWith(TAG)){ var fileName=changeFirstChar(v.substring(1),false); if(fileName.toLowerCase()!=current) { set.add('import \"$fileName.dart\"'); } return changeFirstChar(fileName); } return \"String\"; }else{ return \"String\"; } } //替换模板占位符 String format(String fmt, List params) { int matchIndex = 0; String replace(Match m) { if (matchIndex 写一个shell(mo.sh)，将生成模板和生成model串起来： dart mo.dart flutter packages pub run build_runner build --delete-conflicting-outputs 至此，我们的脚本写好了，我们在根目录下新建一个json目录，然后把user.json移进去，然后在lib目录下创建一个models目录，用于保存最终生成的Model类。现在我们只需要一句命令即可生成Model类了: ./mo.sh 运行后，一切都将自动执行，现在好多了，不是吗？ 嵌套JSON 我们定义一个person.json内容修改为： { \"name\": \"John Smith\", \"email\": \"john@example.com\", \"mother\":{ \"name\": \"Alice\", \"email\":\"alice@example.com\" }, \"friends\":[ { \"name\": \"Jack\", \"email\":\"Jack@example.com\" }, { \"name\": \"Nancy\", \"email\":\"Nancy@example.com\" } ] } 每个Person都有name 、email 、 mother和friends四个字段，由于mother也是一个Person，朋友是多个Person(数组)，所以我们期望生成的Model是下面这样： import 'package:json_annotation/json_annotation.dart'; part 'person.g.dart'; @JsonSerializable() class Person { Person(); String name; String email; Person mother; List friends; factory Person.fromJson(Map json) => _$PersonFromJson(json); Map toJson() => _$PersonToJson(this); } 这时，我们只需要简单修改一下JSON，添加一些特殊标志，重新运行mo.sh即可： { \"name\": \"John Smith\", \"email\": \"john@example.com\", \"mother\":\"$person\", \"friends\":\"$[]person\" } 我们使用美元符“$”作为特殊标志符(如果与内容冲突，可以修改mo.dart中的TAG常量，自定义标志符)，脚本在遇到特殊标志符后会先把相应字段转为相应的对象或对象数组，对象数组需要在标志符后面添加数组符“[]”，符号后面接具体的类型名，此例中是person。其它类型同理，加入我们给User添加一个Person类型的 boss字段： { \"name\": \"John Smith\", \"email\": \"john@example.com\", \"boss\":\"$person\" } 重新运行mo.sh，生成的user.dart如下： import 'package:json_annotation/json_annotation.dart'; import \"person.dart\"; part 'user.g.dart'; @JsonSerializable() class User { User(); String name; String email; Person boss; factory User.fromJson(Map json) => _$UserFromJson(json); Map toJson() => _$UserToJson(this); } 可以看到，boss字段已自动添加，并自动导入了“person.dart”。 使用IDE插件生成model 目前Android Studio(或IntelliJ)有一个插件，它可以自动将Json转为model，该插件会对嵌套Json也会生成model。这个特性在有些时候可能会引起重定义，如两个Json都内嵌了一个user的对象时，会导致user model在不同的文件中会被定义两次，需要开发者手动去重。 FAQ 很多人可能会问Flutter中有没有像Java开发中的Gson/Jackson一样的Json序列化类库？答案是没有！因为这样的库需要使用运行时反射，这在Flutter中是禁用的。运行时反射会干扰Dart的tree shaking，使用tree shaking，可以在release版中“去除”未使用的代码，这可以显著优化应用程序的大小。由于反射会默认应用到所有代码，因此tree shaking会很难工作，因为在启用反射时很难知道哪些代码未被使用，因此冗余代码很难剥离，所以Flutter中禁用了Dart的反射功能，而正因如此也就无法实现动态转化Model的功能。 "},"chapter11/":{"url":"chapter11/","title":"包与插件","keywords":"","body":"包与插件 开发package 插件开发：平台通道简介 插件开发：实现Android端API 插件开发：实现IOS端API "},"chapter11/develop_package.html":{"url":"chapter11/develop_package.html","title":"开发package","keywords":"","body":"Package 使用package可以创建共享的模块化代码。一个最小的package包括： 一个pubspec.yaml文件：声明了package的名称、版本、作者等的元数据文件。 一个 lib 文件夹：包括包中公开的(public)代码，最少应有一个.dart文件 Flutter Packages分为两类： Dart包：其中一些可能包含Flutter的特定功能，因此对Flutter框架具有依赖性，这种包仅用于Flutter，例如fluro包。 插件包：一种专用的Dart包，其中包含用Dart代码编写的API，以及针对Android（使用Java或Kotlin）和针对iOS（使用OC或Swift）平台的特定实现，也就是说插件包括原生代码，一个具体的例子是battery插件包。 注意，虽然Flutter的Dart运行时和Dart VM运行时不是完全相同，但是如果Package中没有涉及这些存在差异的部分，那么这样的包可以同时支持Flutter和Dart VM，如Dart http网络库dio. 开发Dart包 第一步：创建Dart包 您可以通过Android Studio：File>New>New Flutter Project 来创建： 您也可以通过使用--template=package 来执行 flutter create 命令来创建： flutter create --template=package hello 这将在hello/文件夹下创建一个具有以下专用内容的package工程： lib/hello.dart：Package的Dart代码 test/hello_test.dart：Package的单元测试代码。 实现package 对于纯Dart包，只需在主lib/.dart文件内或lib目录中的文件中添加功能即可 。要测试软件包，请在test目录中添加unit tests。下面我们看看如何组织Package包的代码，我们以shelf Package为例，它的目录结构如下： 在lib根目录下的shelf.dart中，导出了多个lib/src目录下的dart文件： export 'src/cascade.dart'; export 'src/handler.dart'; export 'src/handlers/logger.dart'; export 'src/hijack_exception.dart'; export 'src/middleware.dart'; export 'src/pipeline.dart'; export 'src/request.dart'; export 'src/response.dart'; export 'src/server.dart'; export 'src/server_handler.dart'; 而Package中主要的功能的源码都在src目录下。shelf Package也导出了一个迷你库: shelf_io，它主要是处理HttpRequest的。 导入包 当需要使用这个Package时，我们可以通过\"package:\"指令来指定包的入口文件： import 'package:utilities/utilities.dart'; 同一个包中的源码文件之间也可以使用相对路径来导入。 生成文档 可以使用 dartdoc 工具来为Package生成文档，开发者需要做的就是遵守文档注释语法在代码中添加文档注释，最后使用dartdoc可以直接生成API文档（一个静态网站）。文档注释是使用三斜线\"///\"开始，如： /// The event handler responsible for updating the badge in the UI. void updateBadge() { ... } 详细的文档语法请参考dartdoc 。 处理包的相互依赖 如果我们正在开发一个hello包，它依赖于另一个包，则需要将该依赖包添加到pubspec.yaml文件的dependencies部分。 下面的代码使url_launcher插件的API在hello包中是可用的： 在 hello/pubspec.yaml中: dependencies: url_launcher: ^0.4.2 现在可以在hello中import 'package:url_launcher/url_launcher.dart' 然后调用 launch()方法了。 这与在Flutter应用程序或任何其他Dart项目中引用软件包没有什么不同。 但是，如果hello碰巧是一个插件包，其平台特定的代码需要访问url_launcher公开的特定于平台的API，那么我们还需要为特定于平台的构建文件添加合适的依赖声明，如下所示。 Android 在 hello/android/build.gradle: android { // lines skipped dependencies { provided rootProject.findProject(\":url_launcher\") } } 您现在可以在hello/android/src源码中import io.flutter.plugins.urllauncher.UrlLauncherPlugin访问UrlLauncherPlugin类。 iOS 在hello/ios/hello.podspec: Pod::Spec.new do |s| # lines skipped s.dependency 'url_launcher' 您现在可以在hello/ios/Classes源码中 #import \"UrlLauncherPlugin.h\" 然后访问 UrlLauncherPlugin类。 解决依赖冲突 假设我们想在我们的hello包中使用some_package和other_package，并且这两个包都依赖url_launcher，但是依赖的是url_launcher的不同的版本。 那我们就有潜在的冲突。避免这种情况的最好方法是在指定依赖关系时，程序包作者使用版本范围而不是特定版本。 dependencies: url_launcher: ^0.4.2 # 这样会较好, 任何0.4.x(x >= 2)都可. image_picker: '0.1.1' # 不是很好，只有0.1.1版本. 如果some_package声明了上面的依赖关系,other_package声明了url_launcher版本像’0.4.5’或’^0.4.0’，pub将能够自动解决问题。 即使some_package和other_package声明了不兼容的url_launcher版本，它仍然可能会和url_launcher以兼容的方式正常工作。 你可以通过向hello包的pubspec.yaml文件中添加依赖性覆盖声明来处理冲突，从而强制使用特定版本： 强制使用 0.4.3版本的url_launcher，在 hello/pubspec.yaml中: dependencies: some_package: other_package: dependency_overrides: url_launcher: '0.4.3' 如果冲突的依赖不是一个包，而是一个特定于Android的库，比如guava，那么必须将依赖重写声明添加到Gradle构建逻辑中。 强制使用23.0版本的guava库，在hello/android/build.gradle中： configurations.all { resolutionStrategy { force 'com.google.guava:guava:23.0-android' } } Cocoapods目前不提供依赖覆盖功能。 发布Package 一旦实现了一个包，我们可以在Pub上发布它 ，这样其他开发者就可以轻松使用它。 在发布之前，检查pubspec.yaml、README.md以及CHANGELOG.md文件，以确保其内容的完整性和正确性。然后，运行 dry-run 命令以查看是否都准备OK了: flutter packages pub publish --dry-run 验证无误后，我们就可以运行发布命令了： flutter packages pub publish 如果你遇到包发布失败的情况，先检查是否因为众所周知的网络原因，如果是网络问题，可以使用VPN，这里需要注意的是一些代理只会代理部分APP的网络请求，如浏览器的，它们可能并不能代理dart的网络请求，所以在这种情况下，即使开了代理也依然无法连接到Pub，因此，在发布Pub包时使用全局代理或全局VPN会保险些。如果网络没有问题，以管理员权限(sudo)运行发布命令重试。 "},"chapter11/platform-channel.html":{"url":"chapter11/platform-channel.html","title":"插件开发：平台通道简介","keywords":"","body":"插件开发：平台通道简介 所谓“平台特定”或“特定平台”，平台指的就是指Flutter运行的平台，如Android或IOS，可以认为就是应用的原生部分。所以，平台通道正是Flutter和原生之间通信的桥梁，它也是Flutter插件的底层基础设施。 Flutter使用了一个灵活的系统，允许您调用特定平台的API，无论在Android上的Java或Kotlin代码中，还是iOS上的ObjectiveC或Swift代码中均可用。 Flutter与原生之间的通信依赖灵活的消息传递方式： 应用的Flutter部分通过平台通道（platform channel）将消息发送到其应用程序的所在的宿主（iOS或Android）应用（原生应用）。 宿主监听平台通道，并接收该消息。然后它会调用该平台的API，并将响应发送回客户端，即应用程序的Flutter部分。 平台通道 使用平台通道在Flutter(client)和原生(host)之间传递消息，如下图所示： 当在Flutter中调用原生方法时，调用信息通过平台通道传递到原生，原生收到调用信息后方可执行指定的操作，如需返回数据，则原生会将数据再通过平台通道传递给Flutter。值得注意的是消息传递是异步的，这确保了用户界面在消息传递时不会被挂起。 在客户端，MethodChannel API 可以发送与方法调用相对应的消息。 在宿主平台上，MethodChannel 在Android API 和 FlutterMethodChannel iOS API可以接收方法调用并返回结果。这些类可以帮助我们用很少的代码就能开发平台插件。 注意: 如果需要，方法调用(消息传递)可以是反向的，即宿主作为客户端调用Dart中实现的API。 quick_actions插件就是一个具体的例子。 平台通道数据类型支持 平台通道使用标准消息编/解码器对消息进行编解码，它可以高效的对消息进行二进制序列化与反序列化。由于Dart与原生平台之间数据类型有所差异，下面我们列出数据类型之间的映射关系。 Dart Android iOS null null nil (NSNull when nested) bool java.lang.Boolean NSNumber numberWithBool: int java.lang.Integer NSNumber numberWithInt: int, if 32 bits not enough java.lang.Long NSNumber numberWithLong: int, if 64 bits not enough java.math.BigInteger FlutterStandardBigInteger double java.lang.Double NSNumber numberWithDouble: String java.lang.String NSString Uint8List byte[] FlutterStandardTypedData typedDataWithBytes: Int32List int[] FlutterStandardTypedData typedDataWithInt32: Int64List long[] FlutterStandardTypedData typedDataWithInt64: Float64List double[] FlutterStandardTypedData typedDataWithFloat64: List java.util.ArrayList NSArray Map java.util.HashMap NSDictionary 当在发送和接收值时，这些值在消息中的序列化和反序列化会自动进行。 开发Flutter插件 使用平台通道调用原生代码 下面我们通过一个获取电池电量的插件来介绍一下Flutter插件的开发流程。该插件中我们在Dart中通过getBatteryLevel 调用Android BatteryManager API和iOS device.batteryLevel API。 创建一个新的应用程序项目 首先创建一个新的应用程序: 在终端中运行：flutter create batterylevel 默认情况下，模板支持使用Java编写Android代码，或使用Objective-C编写iOS代码。要使用Kotlin或Swift，请使用-i和/或-a标志: 在终端中运行: flutter create -i swift -a kotlin batterylevel 创建Flutter平台客户端 该应用的State类拥有当前的应用状态。我们需要延长这一点以保持当前的电量 首先，我们构建通道。我们使用MethodChannel调用一个方法来返回电池电量。 通道的客户端和宿主通过通道构造函数中传递的通道名称进行连接。单个应用中使用的所有通道名称必须是唯一的; 我们建议在通道名称前加一个唯一的“域名前缀”，例如samples.flutter.io/battery。 import 'dart:async'; import 'package:flutter/material.dart'; import 'package:flutter/services.dart'; ... class _MyHomePageState extends State { static const platform = const MethodChannel('samples.flutter.io/battery'); // Get battery level. } 接下来，我们调用通道上的方法，指定通过字符串标识符调用方法getBatteryLevel。 该调用可能失败(平台不支持平台API，例如在模拟器中运行时)，所以我们将invokeMethod调用包装在try-catch语句中。 我们使用返回的结果，在setState中来更新用户界面状态batteryLevel。 // Get battery level. String _batteryLevel = 'Unknown battery level.'; Future _getBatteryLevel() async { String batteryLevel; try { final int result = await platform.invokeMethod('getBatteryLevel'); batteryLevel = 'Battery level at $result % .'; } on PlatformException catch (e) { batteryLevel = \"Failed to get battery level: '${e.message}'.\"; } setState(() { _batteryLevel = batteryLevel; }); } 最后，我们在build创建包含一个小字体显示电池状态和一个用于刷新值的按钮的用户界面。 @override Widget build(BuildContext context) { return new Material( child: new Center( child: new Column( mainAxisAlignment: MainAxisAlignment.spaceEvenly, children: [ new RaisedButton( child: new Text('Get Battery Level'), onPressed: _getBatteryLevel, ), new Text(_batteryLevel), ], ), ), ); } 在接下来的两节中，我们会分别介绍Android和iOS端API的实现。 自定义平台通道和编解码器 除了上面提到的MethodChannel，还可以使用BasicMessageChannel，它支持使用自定义消息编解码器进行基本的异步消息传递。 此外，可以使用专门的BinaryCodec、StringCodec和 JSONMessageCodec类，或创建自己的编解码器。 "},"chapter11/android_implement.html":{"url":"chapter11/android_implement.html","title":"插件开发：实现Android端API","keywords":"","body":"插件开发：Android端API实现 本节我们接着上一节\"获取电池电量\"插件的示例，来完成Android端API的实现。以下步骤是使用Java的示例，如果您更喜欢Kotlin，可以直接跳到后面Kotlin部分。 首先在Android Studio中打开您的Flutter应用的Android部分： 启动 Android Studio 选择 File > Open… 定位到您 Flutter app目录, 然后选择里面的 android文件夹，点击 OK 在java目录下打开 MainActivity.java 接下来，在onCreate里创建MethodChannel并设置一个MethodCallHandler。确保使用和Flutter客户端中使用的通道名称相同的名称。 import io.flutter.app.FlutterActivity; import io.flutter.plugin.common.MethodCall; import io.flutter.plugin.common.MethodChannel; import io.flutter.plugin.common.MethodChannel.MethodCallHandler; import io.flutter.plugin.common.MethodChannel.Result; public class MainActivity extends FlutterActivity { private static final String CHANNEL = \"samples.flutter.io/battery\"; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); new MethodChannel(getFlutterView(), CHANNEL).setMethodCallHandler( new MethodCallHandler() { @Override public void onMethodCall(MethodCall call, Result result) { // TODO } }); } } 接下来，我们添加Java代码，使用Android电池API来获取电池电量。此代码和在原生Android应用中编写的代码完全相同。 首先，添加需要导入的依赖。 import android.content.ContextWrapper; import android.content.Intent; import android.content.IntentFilter; import android.os.BatteryManager; import android.os.Build.VERSION; import android.os.Build.VERSION_CODES; import android.os.Bundle; 然后，将下面的新方法添加到activity类中的，位于onCreate 方法下方： private int getBatteryLevel() { int batteryLevel = -1; if (VERSION.SDK_INT >= VERSION_CODES.LOLLIPOP) { BatteryManager batteryManager = (BatteryManager) getSystemService(BATTERY_SERVICE); batteryLevel = batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY); } else { Intent intent = new ContextWrapper(getApplicationContext()). registerReceiver(null, new IntentFilter(Intent.ACTION_BATTERY_CHANGED)); batteryLevel = (intent.getIntExtra(BatteryManager.EXTRA_LEVEL, -1) * 100) / intent.getIntExtra(BatteryManager.EXTRA_SCALE, -1); } return batteryLevel; } 最后，我们完成之前添加的onMethodCall方法。我们需要处理平台方法名为getBatteryLevel的调用消息，所以我们需要先在call参数判断调用的方法是否为getBatteryLevel。 这个平台方法的实现只需调用我们在前一步中编写的Android代码，并通过result参数返回成功或错误情况的响应信息。如果调用了未定义的API，我们也会通知返回： @Override public void onMethodCall(MethodCall call, Result result) { if (call.method.equals(\"getBatteryLevel\")) { int batteryLevel = getBatteryLevel(); if (batteryLevel != -1) { result.success(batteryLevel); } else { result.error(\"UNAVAILABLE\", \"Battery level not available.\", null); } } else { result.notImplemented(); } } 现在就可以在Android上运行该应用程序了，如果使用的是Android模拟器，则可以通过工具栏中的\"...\"按钮访问Extended Controls面板中的电池电量。 使用Kotlin添加Android平台特定的实现 使用Kotlin和使用Java的步骤类似，首先在Android Studio中打开您的Flutter应用的Android部分： 启动 Android Studio。 选择 the menu item \"File > Open…\"。 定位到 Flutter app目录, 然后选择里面的 android文件夹，点击 OK。 在kotlin目录中打开MainActivity.kt。 接下来，在onCreate里创建MethodChannel并设置一个MethodCallHandler。确保使用与在Flutter客户端使用的通道名称相同。 import android.os.Bundle import io.flutter.app.FlutterActivity import io.flutter.plugin.common.MethodChannel import io.flutter.plugins.GeneratedPluginRegistrant class MainActivity() : FlutterActivity() { private val CHANNEL = \"samples.flutter.io/battery\" override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) GeneratedPluginRegistrant.registerWith(this) MethodChannel(flutterView, CHANNEL).setMethodCallHandler { call, result -> // TODO } } } 接下来，我们添加Kotlin代码，使用Android电池API来获取电池电量，这和原生开发是一样的。 首先，添加需要导入的依赖。 import android.content.Context import android.content.ContextWrapper import android.content.Intent import android.content.IntentFilter import android.os.BatteryManager import android.os.Build.VERSION import android.os.Build.VERSION_CODES 然后，将下面的新方法添加到activity类中的，位于onCreate 方法下方： private fun getBatteryLevel(): Int { val batteryLevel: Int if (VERSION.SDK_INT >= VERSION_CODES.LOLLIPOP) { val batteryManager = getSystemService(Context.BATTERY_SERVICE) as BatteryManager batteryLevel = batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY) } else { val intent = ContextWrapper(applicationContext).registerReceiver(null, IntentFilter(Intent.ACTION_BATTERY_CHANGED)) batteryLevel = intent!!.getIntExtra(BatteryManager.EXTRA_LEVEL, -1) * 100 / intent.getIntExtra(BatteryManager.EXTRA_SCALE, -1) } return batteryLevel } 最后，我们完成之前添加的onMethodCall方法。我们需要处理平台方法名为getBatteryLevel的调用消息，所以我们需要先在call参数判断调用的方法是否为getBatteryLevel。 这个平台方法的实现只需调用我们在前一步中编写的Android代码，并通过result参数返回成功或错误情况的响应信息。如果调用了未定义的API，我们也会通知返回： ​ MethodChannel(flutterView, CHANNEL).setMethodCallHandler { call, result -> if (call.method == \"getBatteryLevel\") { val batteryLevel = getBatteryLevel() if (batteryLevel != -1) { result.success(batteryLevel) } else { result.error(\"UNAVAILABLE\", \"Battery level not available.\", null) } } else { result.notImplemented() } } 您现在就可以在Android上运行该应用程序。如果您使用的是Android模拟器，则可以通过工具栏中的\"...\"按钮访问Extended Controls面板中的电池电量。 "},"chapter11/ios_implement.html":{"url":"chapter11/ios_implement.html","title":"插件开发：实现IOS端API","keywords":"","body":"插件开发：iOS端API实现 本节我们接着之前\"获取电池电量\"插件的示例，来完成iOS端API的实现。以下步骤使用Objective-C，如果您更喜欢Swift，可以直接跳到后面Swift部分。 首先打开Xcode中Flutter应用程序的iOS部分: 启动 Xcode 选择 File > Open… 定位到您 Flutter app目录, 然后选择里面的 iOS文件夹，点击 OK 确保Xcode项目的构建没有错误。 选择 Runner > Runner ，打开AppDelegate.m 接下来，在application didFinishLaunchingWithOptions:方法内部创建一个FlutterMethodChannel，并添加一个处理方法。 确保与在Flutter客户端使用的通道名称相同。 #import @implementation AppDelegate - (BOOL)application:(UIApplication*)application didFinishLaunchingWithOptions:(NSDictionary*)launchOptions { FlutterViewController* controller = (FlutterViewController*)self.window.rootViewController; FlutterMethodChannel* batteryChannel = [FlutterMethodChannel methodChannelWithName:@\"samples.flutter.io/battery\" binaryMessenger:controller]; [batteryChannel setMethodCallHandler:^(FlutterMethodCall* call, FlutterResult result) { // TODO }]; return [super application:application didFinishLaunchingWithOptions:launchOptions]; } 接下来，我们添加Objective-C代码，使用iOS电池API来获取电池电量，这和原生是相同的。 在AppDelegate类中添加以下新的方法： - (int)getBatteryLevel { UIDevice* device = UIDevice.currentDevice; device.batteryMonitoringEnabled = YES; if (device.batteryState == UIDeviceBatteryStateUnknown) { return -1; } else { return (int)(device.batteryLevel * 100); } } 最后，我们完成之前添加的setMethodCallHandler方法。我们需要处理的平台方法名为getBatteryLevel，所以我们在call参数中需要先判断是否为getBatteryLevel。 这个平台方法的实现只需调用我们在前一步中编写的iOS代码，并使用result参数返回成功或错误的响应。如果调用了未定义的API，我们也会通知返回： [batteryChannel setMethodCallHandler:^(FlutterMethodCall* call, FlutterResult result) { if ([@\"getBatteryLevel\" isEqualToString:call.method]) { int batteryLevel = [self getBatteryLevel]; if (batteryLevel == -1) { result([FlutterError errorWithCode:@\"UNAVAILABLE\" message:@\"电池信息不可用\" details:nil]); } else { result(@(batteryLevel)); } } else { result(FlutterMethodNotImplemented); } }]; 现在可以在iOS上运行该应用程序了，如果使用的是iOS模拟器，请注意，它不支持电池API，因此应用程序将显示“电池信息不可用”。 使用Swift实现iOS API 以下步骤与上面使用Objective-C相似，首先打开Xcode中Flutter应用程序的iOS部分: 启动 Xcode 选择 File > Open… 定位到您 Flutter app目录, 然后选择里面的 ios文件夹，点击 OK 确保Xcode项目的构建没有错误。 选择 Runner > Runner ，然后打开AppDelegate.swift 接下来，覆盖application方法并创建一个FlutterMethodChannel绑定通道名称samples.flutter.io/battery： @UIApplicationMain @objc class AppDelegate: FlutterAppDelegate { override func application( _ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool { GeneratedPluginRegistrant.register(with: self); let controller : FlutterViewController = window?.rootViewController as! FlutterViewController; let batteryChannel = FlutterMethodChannel.init(name: \"samples.flutter.io/battery\", binaryMessenger: controller); batteryChannel.setMethodCallHandler({ (call: FlutterMethodCall, result: FlutterResult) -> Void in // Handle battery messages. }); return super.application(application, didFinishLaunchingWithOptions: launchOptions); } } 接下来，我们添加Swift代码，使用iOS电池API来获取电池电量，这和原生开发是相同的。 将以下新方法添加到AppDelegate.swift底部: private func receiveBatteryLevel(result: FlutterResult) { let device = UIDevice.current; device.isBatteryMonitoringEnabled = true; if (device.batteryState == UIDeviceBatteryState.unknown) { result(FlutterError.init(code: \"UNAVAILABLE\", message: \"电池信息不可用\", details: nil)); } else { result(Int(device.batteryLevel * 100)); } } 最后，我们完成之前添加的setMethodCallHandler方法。我们需要处理的平台方法名为getBatteryLevel，所以我们在call参数中需要先判断是否为getBatteryLevel。 这个平台方法的实现只需调用我们在前一步中编写的iOS代码，并使用result参数返回成功或错误的响应。如果调用了未定义的API，我们也会通知返回： batteryChannel.setMethodCallHandler({ (call: FlutterMethodCall, result: FlutterResult) -> Void in if (\"getBatteryLevel\" == call.method) { receiveBatteryLevel(result: result); } else { result(FlutterMethodNotImplemented); } }); 现在可以在iOS上运行应用程序，如果使用的是iOS模拟器，请注意，它不支持电池API，因此应用程序将显示“电池信息不可用”。 "},"todo.html":{"url":"todo.html","title":"系统能力调用","keywords":"","body":"提示 本文档尚未完成，您可以： 去Flutter中文网查看相关内容。 您想补充此文档？可以查看《Flutter实战》开源项目\"贡献须知\"。 点击下面的\"赏\"按钮，请作者喝杯咖啡，鼓励继续创作~~ "},"chapter12/":{"url":"chapter12/","title":"国际化","keywords":"","body":"本章目录 让App支持多语言 实现Localizations 使用Intl包 "},"chapter12/multi_languages_support.html":{"url":"chapter12/multi_languages_support.html","title":"让App支持多语言","keywords":"","body":"让App支持多语言 如果我们的应用要支持多种语言，那么我们需要“国际化”它。这意味着我们在开发时需要为应用程序支持的每种语言环境设置“本地化”的一些值，如文本和布局。Flutter提供一些widget和类以帮助实现国际化，而Flutter的库本身也是国际化的。 接下来我们以MaterialApp类为入口的应用来说明如何支持国际化。 大多数应用程序都是通过MaterialApp为入口，但根据低级别的WidgetsApp类为入口编写的应用程序也可以使用相同的类和逻辑进行国际化。MaterialApp实际上也是WidgetsApp的一个包装。 支持国际化 默认情况下，Flutter仅提供美国英语本地化。要添加对其他语言的支持，应用程序必须指定其他MaterialApp属性，并包含一个名为“flutter_localizations”的包。 截至2018年5月，该包支持24种语言。要使用flutter_localizations包，首先需要添加依赖到pubspec.yaml文件中： dependencies: flutter: sdk: flutter flutter_localizations: sdk: flutter 接下来，下载flutter_localizations库，然后指定MaterialApp的localizationsDelegates和supportedLocales： import 'package:flutter_localizations/flutter_localizations.dart'; new MaterialApp( localizationsDelegates: [ // 本地化的代理类 GlobalMaterialLocalizations.delegate, GlobalWidgetsLocalizations.delegate, ], supportedLocales: [ const Locale('en', 'US'), // 美国英语 const Locale('zh', 'CN'), // 中文简体 //其它Locales ], // ... ) 基于WidgetsApp的应用程序类似，只是不需要GlobalMaterialLocalizations.delegate。 localizationsDelegates列表中的元素是生成本地化值集合的工厂。GlobalMaterialLocalizations.delegate 为Material 组件库提供的本地化的字符串和其他值，它可以使Material Widget支持多语言。 GlobalWidgetsLocalizations.delegate定义widget默认的文本方向，从左到右或从右到左，这是因为有些语言的阅读习惯并不是从左到右，比如如阿拉伯语就是从右向左的。 获取当前区域Locale Locale类是用来标识用户的语言环境的，它包括语言和国家两个标志如： const Locale('zh', 'CN') // 中文简体 我们始终可以通过以下方式来获取应用的当前区域Locale： Locale myLocale = Localizations.localeOf(context); Localizations Widget一般位于Widget树中其它业务组件的顶部，它的作用是定义区域Locale以及设置子树依赖的本地化资源。 如果系统的语言环境发生变化，WidgetsApp将创建一个新的Localizations Widget并重建它，这样子树中通过Localizations.localeOf(context) 获取的Locale就会更新。 监听系统语言切换 当我们更改系统语言设置时，APP中的Localizations widget会重新构建，Localizations.localeOf(context)` 获取的Locale就会更新，最终界面会重新build达到切换语言的效果。但是这个过程是隐式完成的，我们并没有主动去监听系统语言切换，但是有时我们需要在系统语言发生改变时做一些事，这时我们就需要监听locale改变事件。 我们可以通过localeResolutionCallback或localeListResolutionCallback回调来监听locale改变的事件，我们先看看localeResolutionCallback的回调函数签名： Locale Function(Locale locale, Iterable supportedLocales) 参数locale的值为当前的当前的系统语言设置，当应用启动时或用户动态改变系统语言设置时此locale即为系统的当前locale。当开发者手动指定APP的locale时，那么此locale参数代表开发者指定的locale，此时将忽略系统locale如： MaterialApp( ... locale: const Locale('en', 'US'), //手动指定locale ... ) 上面的例子中手动指定了应用locale为美国英语，指定后即使设备当前语言是中文简体，应用中的locale也依然是美国英语。 如果locale为null，则表示Flutter未能获取到设备的Locale信息，所以我们在使用locale之前一定要先判空。 supportedLocales 为当前应用支持的locale列表，是开发者在MaterialApp中通过supportedLocales属性注册的。 返回值是一个Locale，此Locale为Flutter APP最终的Locale。通常在不支持的语言区域时返回一个默认的Locale。 localeListResolutionCallback和localeResolutionCallback唯一的不同就在第一个参数类型，前者接收的是一个Locale列表，而后者接收的是单个Locale。 Locale Function(List locales, Iterable supportedLocales) 在新版的Android系统中，用户可以设置一个语言列表，这样一来，支持多语言的应用就会得到这个列表，应用通常的处理方式就是按照列表的顺序依次尝试加载相应的Locale，如果某一种语言加载成功则会停止。下面是Android中设置语言列表的截图： 在Flutter中，应该优先使用localeListResolutionCallback，当然你不必担心Android系统的差异性，如果在低版本的Android系统中，Flutter会自动处理这种情况，这时Locale列表只会包含一项。 Localization widget Localizations widget用于加载和查找包含本地化值的对象。应用程序通过Localizations.of(context,type)来引用这些对象。 如果设备的Locale区域设置发生更改，则Localizations widget会自动加载新区域的Locale值，然后重新构建使用了它们的widget。 发生这种情况是因为Localizations内部使用了InheritedWidget ，当build函数引用了InheritedWidget时，会创建对InheritedWidget的隐式依赖关系。当InheritedWidget发生更改时，即Localizations widget的Locale设置发生更改时，将重建其依赖的上下文。 本地化值由Localizations的 LocalizationsDelegates 列表加载 。 每个委托必须定义一个异步load() 方法，以生成封装了一系列本地化值的对象。通常这些对象为每个本地化值定义一个方法。 在大型应用程序中，不同模块或Package可能会与自己的本地化值捆绑在一起。 这就是为什么要用Localizations 管理对象表的原因。 要检索由LocalizationsDelegate load方法之一产生的对象，可以指定一个BuildContext和对象的类型。例如，Material 组件库的本地化字符串由MaterialLocalizations类定义， 此类的实例由MaterialApp类提供的LocalizationDelegate创建， 它们可以通过Localizations.of被获取到： Localizations.of(context, MaterialLocalizations); 这个特殊的Localizations.of()表达式会经常使用，所以MaterialLocalizations类提供了一个便捷方法： static MaterialLocalizations of(BuildContext context) { return Localizations.of(context, MaterialLocalizations); } // 可以直接调用便捷方法 tooltip: MaterialLocalizations.of(context).backButtonTooltip, 使用打包好的LocalizationsDelegates 为了尽可能小而且简单，flutter软件包中仅提供美国英语值的MaterialLocalizations和WidgetsLocalizations接口的实现。 这些实现类分别称为DefaultMaterialLocalizations和DefaultWidgetsLocalizations。flutter_localizations Package包含GlobalMaterialLocalizations和GlobalWidgetsLocalizations的本地化接口的多语言实现， 国际化的应用程序必须按照本节开头说明的那样为这些类指定本地化Delegate。 上述的GlobalMaterialLocalizations和GlobalWidgetsLocalizations只是Material组件库的本地化实现，如果我们要让自己的布局支持多语言，那么就需要实现在即的Localizations，我们将在下一节介绍其具体的实现方式。 "},"chapter12/locallization_implement.html":{"url":"chapter12/locallization_implement.html","title":"实现Localizations","keywords":"","body":"实现Localizations 前面讲了Material组件库如何支持国际化，本节我们将介绍一下我们自己的UI中如何支持多语言。根据上节所述，我们需要实现两个类：一个Delegate类一个Localizations类，下面我们通过一个实例说明。 实现Localizations类 我们已经知道Localizations类中主要实现提供了本地化值，如文本： //Locale资源类 class DemoLocalizations { DemoLocalizations(this.isZh); //是否为中文 bool isZh = false; //为了使用方便，我们定义一个静态方法 static DemoLocalizations of(BuildContext context) { return Localizations.of(context, DemoLocalizations); } //Locale相关值，title为应用标题 String get title { return isZh ? \"Flutter应用\" : \"Flutter APP\"; } //... 其它的值 } DemoLocalizations中会根据当前的语言来返回不同的文本，如title，我们可以将所有需要支持多语言的文本都在此类中定义。DemoLocalizations的实例将会在Delegate类的load方法中创建。 实现Delegate类 Delegate类的职责是在Locale改变时加载新的Locale资源，所以它有一个load方法，Delegate类需要继承自LocalizationsDelegate类，实现相应的接口，示例如下： //Locale代理类 class DemoLocalizationsDelegate extends LocalizationsDelegate { const DemoLocalizationsDelegate(); //是否支持某个Local @override bool isSupported(Locale locale) => ['en', 'zh'].contains(locale.languageCode); // Flutter会调用此类加载相应的Locale资源类 @override Future load(Locale locale) { print(\"xxxx$locale\"); return SynchronousFuture( DemoLocalizations(locale.languageCode == \"zh\") ); } @override bool shouldReload(DemoLocalizationsDelegate old) => false; } shouldReload的返回值决定当Localizations Widget重新build时，是否调用load方法重新加载Locale资源。一般情况下，Locale资源只应该在Locale切换时加载一次，不需要每次在Localizations 重新build时都加载，所以返回false即可。可能有些人会担心返回false的话在APP启动后用户再改变系统语言时load方法将不会被调用，所以Locale资源将不会被加载。事实上，每当Locale改变时Flutter都会再调用load方法加载新的Locale，无论shouldReload返回true还是false。 最后一步：添加多语言支持 和上一节中介绍的相同，我们现在需要先注册DemoLocalizationsDelegate类，然后再通过DemoLocalizations.of(context)来动态获取当前Locale文本。 只需要在MaterialApp或WidgetsApp的localizationsDelegates列表中添加我们的Delegate实例即可完成注册： localizationsDelegates: [ // 本地化的代理类 GlobalMaterialLocalizations.delegate, GlobalWidgetsLocalizations.delegate, // 注册我们的Delegate DemoLocalizationsDelegate() ], 接下来我们可以在Widget中使用Locale值： return Scaffold( appBar: AppBar( //使用Locale title title: Text(DemoLocalizations.of(context).title), ), ... //省略无关代码 ） 这样，当在美国英语和中文简体之间切换系统语言时，APP的标题将会分别为“Flutter APP”和“Flutter应用”。 总结 本节我们通过一个简单的示例说明了Flutter应用国际化的基本过程及原理。但是上面的实例还有一个严重的不足就是我们需要在DemoLocalizations类中获取title时手动的判断当前语言Locale，然后返回合适的文本。试想一下，当我们要支持的语言不是两种而是8种甚至20几种时，如果为每个文本属性都要分别去判断到底是哪种Locale从而获取相应语言的文本将会是一件非常复杂的事。还有，通常情况下翻译人员并不是开发人员，能不能像i18n或i10n标准那样可以将翻译单独保存为一个arb文件交由翻译人员去翻译，翻译好之后开发人员再通过工具将arb文件转为代码。答案是肯定的！我们将在下一节介绍如何通过Dart intl包来实现这些。 "},"chapter12/intl.html":{"url":"chapter12/intl.html","title":"使用Intl包","keywords":"","body":"使用Intl包 使用Intl包我们不仅可以非常轻松的实现国际化，而且也可以将字符串文本分离成单独的文件，方便开发人员和翻译人员分工协作。为了使用Intl包我们需要添加两个依赖： dependencies: #...省略无关项 intl: ^0.15.7 dev_dependencies: #...省略无关项 intl_translation: ^0.17.2 intl_translation 包主要包含了一些工具，它在开发阶段主要主要的作用是从代码中提取要国际化的字符串到单独的arb文件和根据arb文件生成对应语言的dart代码，而intl包主要是引用和加载intl_translation生成后的dart代码。下面我们将一步步来说明如何使用： 第一步：创建必要目录 首先，在项目根目录下创建一个i10n-arb目录，该目录保存我们接下来通过intl_translation命令生成的arb文件。一个简单的arb文件内容如下： { \"@@last_modified\": \"2018-12-10T15:46:20.897228\", \"@@locale\":\"zh_CH\", \"title\": \"Flutter应用\", \"@title\": { \"description\": \"Title for the Demo application\", \"type\": \"text\", \"placeholders\": {} } } 我们根据\"@@locale\"字段可以看出这个arb对应的是中文简体的翻译，里面的title字段对应的正是我们应用标题的中文简体翻译。@title字段是对title的一些描述信息。 接下来，我们在lib目录下创建一个i10n的目录，该目录用于保存从arb文件生成的dart代码文件。 第二步：实现Localizations和Delegate类 和上一节中的步骤类似，我们仍然要实现Localizations和Delegate类，不同的是，现在我们在实现时要使用intl包的一些方法（有些是动态生成的）。 下面我们在lib/i10n目录下新建一个“localization_intl.dart”的文件，文件内容如下： import 'package:flutter/material.dart'; import 'package:intl/intl.dart'; import 'messages_all.dart'; //1 class DemoLocalizations { static Future load(Locale locale) { final String name = locale.countryCode.isEmpty ? locale.languageCode : locale.toString(); final String localeName = Intl.canonicalizedLocale(name); //2 return initializeMessages(localeName).then((b) { Intl.defaultLocale = localeName; return new DemoLocalizations(); }); } static DemoLocalizations of(BuildContext context) { return Localizations.of(context, DemoLocalizations); } String get title { return Intl.message( 'Flutter APP', name: 'title', desc: 'Title for the Demo application', ); } } //Locale代理类 class DemoLocalizationsDelegate extends LocalizationsDelegate { const DemoLocalizationsDelegate(); //是否支持某个Local @override bool isSupported(Locale locale) => ['en', 'zh'].contains(locale.languageCode); // Flutter会调用此类加载相应的Locale资源类 @override Future load(Locale locale) { //3 return DemoLocalizations.load(locale); } // 当Localizations Widget重新build时，是否调用load重新加载Locale资源. @override bool shouldReload(DemoLocalizationsDelegate old) => false; } 注意： 注释1的\"messages_all.dart\"文件是通过intl_translation工具从arb文件生成的代码，所以在第一次运行生成命令之前，此文件不存在。注释2处的initializeMessages()方法和\"messages_all.dart\"文件一样，是同时生成的。 注释3处和上一节示例代码不同，这里我们直接调用DemoLocalizations.load()即可。 第三部：添加需要国际化的属性 现在我们可以在DemoLocalizations类中添加需要国际化的属性或方法，如上面示例代码中的title属性，这时我们就要用到Intl库提供的一些方法，这些方法可以帮我们轻松实现不同语言的一些语法特性，如复数语境，举个例子，比如我们有一个电子邮件列表页，我们需要在顶部显示未读邮件的数量，在未读数量不同事，我们展示的文本可能会不同： 未读邮件数 提示语 0 There are no emails left 1 There is 1 email left n(n>1) There are n emails left 我们可以通过Intl.plural(...)来实现： remainingEmailsMessage(int howMany) => Intl.plural(howMany, zero: 'There are no emails left', one: 'There is $howMany email left', other: 'There are $howMany emails left', name: \"remainingEmailsMessage\", args: [howMany], desc: \"How many emails remain after archiving.\", examples: const {'howMany': 42, 'userName': 'Fred'}); 可以看到通过Intl.plural方法可以在howMany值不同时输出不同的提示信息。 Intl包还有一些其他的方法，读者可以自行查看其文档，本书不在赘述。 第四步：生成arb文件 现在我们可以通intl_translation包的工具来提取代码中的字符串到一个arb文件，运行如下命名： flutter pub pub run intl_translation:extract_to_arb --output-dir=i10n-arb \\ lib/i10n/localization_intl.dart 运行此命令后，会将我们之前通过Intl API标识的属性和字符串提取到“i10n-arb/intl_messages.arb”文件中，我们看看其内容： { \"@@last_modified\": \"2018-12-10T17:37:28.505088\", \"title\": \"Flutter APP\", \"@title\": { \"description\": \"Title for the Demo application\", \"type\": \"text\", \"placeholders\": {} }, \"remainingEmailsMessage\": \"{howMany,plural, =0{There are no emails left}=1{There is {howMany} email left}other{There are {howMany} emails left}}\", \"@remainingEmailsMessage\": { \"description\": \"How many emails remain after archiving.\", \"type\": \"text\", \"placeholders\": { \"howMany\": { \"example\": 42 } } } } 这个是默认的Locale资源文件，如果我们现在要支持中文简体，只需要在该文件同级目录创建一个\"intl_zh_CN.arb\"文件，然后将\"intl_messages.arb\"的内容拷贝到\"intl_zh_CN.arb\"文件，接下来将英文翻译为中文即可，翻译后的\"intl_zh_CN.arb\"文件内容如下： { \"@@last_modified\": \"2018-12-10T15:46:20.897228\", \"@@locale\":\"zh_CH\", \"title\": \"Flutter应用\", \"@title\": { \"description\": \"Title for the Demo application\", \"type\": \"text\", \"placeholders\": {} }, \"remainingEmailsMessage\": \"{howMany,plural, =0{没有未读邮件}=1{有{howMany}封未读邮件}other{有{howMany}封未读邮件}}\", \"@remainingEmailsMessage\": { \"description\": \"How many emails remain after archiving.\", \"type\": \"text\", \"placeholders\": { \"howMany\": { \"example\": 42 } } } } 我们必须要翻译title和remainingEmailsMessage字段，description是该字段的说明，通常给翻译人员看，代码中不会用到。 有两点需要说明： 如果某个特定的arb中缺失某个属性，那么应用将会加载默认的arb文件(intl_messages.arb)中的相应属性，这是Intl的托底策略。 每次运行提取命令时，intl_messages.arb都会根据代码重新生成，但其他arb文件不会，所以当要添加新的字段或方法时，其他arb文件是增量的，不用担心会覆盖。 arb文件是标准的，其格式规范可以自行了解。通常会将arb文件交给翻译人员，当他们完成翻译后，我们再通过下面的步骤根据arb文件生成最终的dart代码。 第五步：生成dart代码 最后一步就是根据arb生成dart文件： flutter pub pub run intl_translation:generate_from_arb --output-dir=lib/i10n --no-use-deferred-loading lib/i10n/localization_intl.dart i10n-arb/intl_*.arb 这句命令在首次运行时会在\"lib/i10n\"目录下生成多个文件，对应多种Locale，这些代码便是最终要使用的dart代码。 总结 至此，我们将使用Intl包对APP进行国际化的流程介绍完了，我们可以发现，其中第一步和第二步只在第一次需要，而我们开发时的主要的工作都是在第三步。由于最后两步在第三步完成后每次也都需要，所以我们可以将最后两步放在一个shell脚本里，当我们完成第三步或完成arb文件翻译后只需要分别执行该脚本即可。我们在根目录下创建一个intl.sh的脚本，内容为： flutter pub pub run intl_translation:extract_to_arb --output-dir=i10n-arb lib/i10n/localization_intl.dart flutter pub pub run intl_translation:generate_from_arb --output-dir=lib/i10n --no-use-deferred-loading lib/i10n/localization_intl.dart i10n-arb/intl_*.arb 然后授予执行权限： chmod +x intl.sh 执行intl.sh ./intl.sh "},"chapter14/":{"url":"chapter14/","title":"Flutter核心原理","keywords":"","body":"本章目录 Flutter UI系统 Element和BuildContext RenderObject和RenderBox Flutter从启动到显示 "},"chapter14/flutter_ui_system.html":{"url":"chapter14/flutter_ui_system.html","title":"Flutter UI系统","keywords":"","body":"Flutter UI系统 在本书的前面章节中，我们多次提到\"UI系统\"这个概念，本书中所指的UI系统特指：基于一个平台，在此平台上实现GUI的一个系统，这里的平台特指操作系统，如Android、iOS或者Windows、macOS。我们说过各个平台UI系统的原理是相通的，也就是说无论是Android还是iOS，他们将一个用户界面展示到屏幕的流程是相似的，所以，在介绍Flutter UI系统之前，我们先看看UI系统的基本原理，这样可以帮助读者对操作系统和系统底层UI逻辑有一个清晰的认识。 UI系统原理 硬件绘图基本原理 提到原理，我们要从屏幕显示图像的基本原理谈起。我们知道显示器（屏幕）是由一个个物理显示单元组成，每一个单元我们可以称之为一个物理像素点，而每一个像素点可以发出多种颜色，显示器成相的原理就是在不同的物理像素点上显示不同的颜色，最终构成完整的图像。 一个像素点能发出的所有颜色总数是显示器的一个重要指标，比如我们所说的1600万色的屏幕就是指一个像素点可以显示出1600万种颜色，而显示器颜色是有RGB三基色组成，所以1600万即2的24次方，即每个基本色（R、G、B）深度扩展至8 bit(位)，颜色深度越深，所能显示的色彩更加丰富靓丽。 为了更新显示画面，显示器是以固定的频率刷新（从GPU取数据），比如有一部手机屏幕的刷新频率是 60Hz。当一帧图像绘制完毕后准备绘制下一帧时，显示器会发出一个垂直同步信号（如VSync）， 60Hz的屏幕就会一秒内发出 60次这样的信号。而这个信号主要是用于同步CPU、GPU和显示器的。一般地来说，计算机系统中，CPU、GPU和显示器以一种特定的方式协作：CPU将计算好的显示内容提交给 GPU，GPU渲染后放入帧缓冲区，然后视频控制器按照同步信号从帧缓冲区取帧数据传递给显示器显示。 CPU和GPU的任务是各有偏重的，CPU主要用于基本数学和逻辑计算，而GPU主要执行和图形处理相关的复杂的数学，如矩阵变化和几何计算，GPU的主要作用就是确定最终输送给显示器的各个像素点的色值。 操作系统绘制API的封装 由于最终的图形计算和绘制都是由相应的硬件来完成，而直接操作硬件的指令通常都会有操作系统屏蔽，应用开发者通常不会直接面对硬件，操作系统屏蔽了这些底层硬件操作后会提供一些封装后的API供操作系统之上的应用调用，但是对于应用开发者来说，直接调用这些操作系统提供的API是比较复杂和低效的，因为操作系统提供的API往往比较基础，直接调用需要了解API的很多细节。正是因为这个原因，几乎所有用于开发GUI程序的编程语言都会在操作系统之上再封装一层，将操作系统原生API封装在一个编程框架和模型中，然后定义一种简单的开发规则来开发GUI应用程序，而这一层抽象，正是我们所说的“UI”系统，如Android SDK正是封装了Android操作系统API，提供了一个“UI描述文件XML+Java操作DOM”的UI系统，而iOS的UIKit 对View的抽象也是一样的，他们都将操作系统API抽象成一个基础对象（如用于2D图形绘制的Canvas），然后再定义一套规则来描述UI，如UI树结构，UI操作的单线程原则等。 Flutter UI系统 我们可以看到，无论是Android SDK还是iOS的UIKit 的职责都是相同的，它们只是语言载体和底层的系统不同而已。那么可不可以实现这么一个UI系统：可以使用同一种编程语言开发，然后针对不同操作系统API抽象一个对上接口一致，对下适配不同操作系统的的中间层，然后在打包编译时再使用相应的中间层代码？如果可以做到，那么我们就可以使用同一套代码编写跨平台的应用了。而Flutter的原理正是如此，它提供了一套Dart API，然后在底层通过OpenGL这种跨平台的绘制库（内部会调用操作系统API）实现了一套代码跨多端。由于Dart API也是调用操作系统API，所以它的性能接近原生。 注意，虽然Dart是先调用了OpenGL，OpenGL才会调用操作系统API，但是这仍然是原生渲染，因为OpenGL只是操作系统API的一个封装库，它并不像WebView渲染那样需要JavaScript运行环境和CSS渲染器，所以不会有性能损失。 至此，我们已经介绍了Flutter UI系统和操作系统交互的这一部分原理，现在需要说一些它对应用开发者定义的开发标准。其实在前面的章节中，我们已经对这个标准非常熟悉了, 简单概括就是：组合和响应式。我们要开发一个UI界面，需要通过组合其它Widget来实现，Flutter中，一切都是Widget，当UI要发生变化时，我们不去直接修改DOM，而是通过更新状态，让Flutter UI系统来根据新的状态来重新构建UI。 讲到这里，读者可能发现Flutter UI系统和Flutter Framework的概念是差不多的，的确如此，之所以用“UI系统”，是因为其他平台中可能不这么叫，我们只是为了概念统一，便于描述，读者不必纠结于概念本身。 在接下来的小节中，我们先详细介绍一下Element、RenderObject，它们是组成Flutter UI系统的基石。最后我们在分析一下Flutter应用启动和运行的整体过程。 "},"chapter14/element_buildcontext.html":{"url":"chapter14/element_buildcontext.html","title":"Element和BuildContext","keywords":"","body":"Element与BuildContext Element 在“Widget简介”一节，我们介绍了Widget和Element的关系，我们知道最终的UI树其实是由一个个独立的Element节点构成。我们也知道了组件最终的Layout、渲染都是通过RenderObject来完成的，从创建到渲染的大体流程是：根据Widget生成Element，然后创建相应的RenderObject并关联到Element.renderObject属性上，最后再通过RenderObject来完成布局排列和绘制。 Element就是Widget在UI树具体位置的一个实例化对象，大多数Element只有唯一的renderObject，但还有一些Element会有多个子节点，如继承自RenderObjectElement的一些类，比如MultiChildRenderObjectElement。最终所有Element的RenderObject构成一棵树，我们称之为渲染树，即render tree。 Element的生命周期如下： Framework 调用Widget.createElement 创建一个Element实例，记为element Framework 调用 element.mount(parentElement,newSlot) ，mount方法中首先调用elment所对应Widget的createRenderObject方法创建与element相关联的RenderObject对象，然后调用element.attachRenderObject方法将element.renderObject添加到渲染树中插槽指定的位置（这一步不是必须的，一般发生在Element树结构发生变化时才需要重新attach）。插入到渲染树后的element就处于“active”状态，处于“active”状态后就可以显示在屏幕上了（可以隐藏）。 当element父Widget的配置数据改变时，为了进行Element复用，Framework在决定重新创建Element前会先尝试复用相同位置旧的element：调用Element对应Widget的canUpdate()方法，如果返回true，则复用旧Element，旧的Element会使用新的Widget配置数据更新，反之则会创建一个新的Element，不会复用。Widget.canUpdate()主要是判断newWidget与oldWidget的runtimeType和key是否同时相等，如果同时相等就返回true，否则就会返回false。根据这个原理，当我们需要强制更新一个Widget时，可以通过指定不同的Key来禁止复用。 当有父Widget的配置数据改变时，同时其State.build返回的Widget结构与之前不同，此时就需要重新构建对应的Element树。为了进行Element复用，在Element重新构建前会先尝试是否可以复用旧树上相同位置的element，element节点在更新前都会调用其对应Widget的canUpdate方法，如果返回true，则复用旧Element，旧的Element会使用新Widget配置数据更新，反之则会创建一个新的Element。Widget.canUpdate主要是判断newWidget与oldWidget的runtimeType和key是否同时相等，如果同时相等就返回true，否则就会返回false。根据这个原理，当我们需要强制更新一个Widget时，可以通过指定不同的Key来避免复用。 当有祖先Element决定要移除element 时（如Widget树结构发生了变化，导致element对应的Widget被移除），这时该祖先Element就会调用deactivateChild 方法来移除它，移除后element.renderObject也会被从渲染树中移除，然后Framework会调用element.deactivate 方法，这时element状态变为“inactive”状态。 “inactive”态的element将不会再显示到屏幕。为了避免在一次动画执行过程中反复创建、移除某个特定element，“inactive”态的element在当前动画最后一帧结束前都会保留，如果在动画执行结束后它还未能重新变成”active“状态，Framework就会调用其unmount方法将其彻底移除，这时element的状态为defunct,它将永远不会再被插入到树中。 如果element要重新插入到Element树的其它位置，如element或element的祖先拥有一个GlobalKey（用于全局复用元素），那么Framework会先将element从现有位置移除，然后再调用其activate方法，并将其renderObject重新attach到渲染树。 看完Element的生命周期，可能有些读者会有疑问，开发者会直接操作Element树吗？其实对于开发者来说，大多数情况下只需要关注Widget树就行，Flutter框架已经将对Widget树的操作映射到了Element树上，这可以极大的降低复杂度，提高开发效率。但是了解Element对理解整个Flutter UI框架是至关重要的，Flutter正是通过Element这个纽带将Widget和RenderObject关联起来，了解Element层不仅会帮助读者对Flutter UI框架有个清晰的认识，而且也会提高自己的抽象能力和设计能力。另外在有些时候，我们必须得直接使用Element对象来完成一些操作，比如获取主题Theme数据，具体细节将在下文介绍。 BuildContext 无论是StatelessWidget和StatefulWidget的build方法都会传一个BuildContext对象： Widget build(BuildContext context) {} 我们知道，在很多时候我们都需要使用这个context 做一些事，比如： Theme.of(context) //获取主题 Navigator.push(context, route) //入栈新路由 Localizations.of(context, type) //获取Local context.size //获取上下文大小 context.findRenderObject() //查找当前或最近的一个祖先RenderObject 那么BuildContext到底是什么呢，查看其定义，发现其是一个抽象接口类： abstract class BuildContext { ... } 那StatelessWidget和StatefulWidget的build方法传入的context对象是哪个实现了BuildContext的类。我们顺藤摸瓜，发现调用时发生在StatelessWidget和StatefulWidget对应的StatelessElement和StatefulElement的build方法中，以StatelessElement为例： class StatelessElement extends ComponentElement { ... @override Widget build() => widget.build(this); ... } 发现build传递的是this，很明显了，这个BuildContext很可能就是Element类，查看Element类定义，发现Element类果然实现了BuildContext接口: class Element extends DiagnosticableTree implements BuildContext { ... } 至此真相大白，BuildContext就是Widget对应的Element，所以我们可以通过context在StatelessWidget和StatefulWidget的build方法中直接访问Element对象。我们获取主题数据的代码Theme.of(context)内部正是调用了Element的inheritFromWidgetOfExactType()方法。 思考题：为什么build方法的参数不定义成Element对象，而要定义成BuildContext ? 进阶 我们可以看到Element是Flutter UI框架内部连接Widget和RenderObject的纽带，大多数时候开发者只需要关注Widget层即可，但是Widget层有时候并不能完全屏蔽Element细节，所以Framework在StatelessWidget和StatefulWidget中通过build方法参数将Element对象也传递给了开发者，这样便可以在需要时直接操作Element对象。那么现在笔者提两个问题，请读者先自己思考一下： 如果没有Widget层，单靠Element层是否可以搭建起一个可用的UI框架？如果可以应该是什么样子？ Flutter UI框架能不做成响应式吗？ 对于问题1，答案当然是肯定的，因为我们之前说过Widget树只是Element树的映射，我们完全可以直接通过Element来搭建一个UI框架。下面举一个例子： 我们通过纯粹的Element来模拟一个StatefulWidget的功能，假设有一个页面，该页面有一个按钮，按钮的文本是1-9 9个数，点击一次按钮，则对9个数随机排一次序，代码如下： class HomeView extends ComponentElement{ HomeView(Widget widget) : super(widget); String text = \"123456789\"; @override Widget build() { Color primary=Theme.of(this).primaryColor; //1 return GestureDetector( child: Center( child: FlatButton( child: Text(text, style: TextStyle(color: primary),), onPressed: () { var t = text.split(\"\")..shuffle(); text = t.join(); markNeedsBuild(); //点击后将该Element标记为dirty，Element将会rebuild }, ), ), ); } } 上面build方法不接收参数，这一点和在StatelessWidget和StatefulWidget中build(BuildContext)方法不同。代码中需要用到BuildContext的地方直接用this代替即可，如代码注释1处Theme.of(this)参数直接传this即可，因为当前对象本身就是Element实例。 当text发生改变时，我们调用markNeedsBuild()方法将当前Element标记为dirty即可，标记为dirty的Element会在下一帧中重建。实际上，State.setState()在内部也是调用的markNeedsBuild()方法。 上面代码中build方法返回的仍然是一个Widget，这是由于Flutter框架中已经有了Widget这一层，并且组件库都已经是以Widget的形式提供了，如果在Flutter框架中所有组件都像示例的HomeView一样以Element形式提供，那么就可以用纯Element来构建UI了，HomeView的build方法返回值类型就可以是Element了。 如果我们需要将上面代码在现有Flutter框架中跑起来，那么还是得提供一个”适配器“Widget将HomeView结合到现有框架中，下面CustomHome就相当于”适配器“： class CustomHome extends Widget { @override Element createElement() { return HomeView(this); } } 现在就可以将CustomHome添加到Widget树了，我们在一个新路由页创建它，最终效果如下： 点击按钮则按钮文本会随机排序。 对于问题2，答案当然也是肯定的，Flutter engine提供的dart API是原始且独立的，这个与操作系统提供的API类似，上层UI框架设计成什么样完全取决于设计者，完全可以将UI框架设计成Android风格或iOS风格，但这些事Google不会再去做，我们也没必要再去搞这一套，这是因为响应式的思想本身是很棒的，之所以提出这个问题，是因为笔者认为做与不做是一回事，但知道能不能做是另一回事，这能反映出我们对知识的掌握程度。 总结 本节详细的介绍了Element的生命周期，以及它与Widget、BuildContext的关系，也介绍了Element在Flutter UI系统中的角色和作用，我们将在下一节介绍Flutter UI系统中另一个重要的角色RenderObject。 "},"chapter14/render_object.html":{"url":"chapter14/render_object.html","title":"RenderObject与RenderBox","keywords":"","body":"RenderObject和RenderBox 在上一节我们说过每个Element都对应一个RenderObject，我们可以通过Element.renderObject 来获取。并且我们也说过RenderObject的主要职责是Layout和绘制，所有的RenderObject会组成一棵渲染树Render Tree。本节我们将重点介绍一下RenderObject的作用。 RenderObject就是渲染树中的一个对象，它拥有一个parent和一个parentData 插槽（slot），所谓插槽，就是指预留的一个接口或位置，这个接口和位置是由其它对象来接入或占据的，这个接口或位置在软件中通常用预留变量来表示，而parentData正是一个预留变量，它正是由parent 来赋值的，parent通常会通过子RenderObject的parentData存储一些和子元素相关的数据，如在Stack布局中，RenderStack就会将子元素的偏移数据存储在子元素的parentData中（具体可以查看Positioned实现）。 RenderObject类本身实现了一套基础的layout和绘制协议，但是并没有定义子节点模型（如一个节点可以有几个子节点，没有子节点？一个？两个？或者更多？）。 它也没有定义坐标系统（如子节点定位是在笛卡尔坐标中还是极坐标？）和具体的布局协议（是通过宽高还是通过constraint和size?，或者是否由父节点在子节点布局之前或之后设置子节点的大小和位置等）。为此，Flutter提供了一个RenderBox类，它继承自RenderObject，布局坐标系统采用笛卡尔坐标系，这和Android和iOS原生坐标系是一致的，都是屏幕的top、left是原点，然后分宽高两个轴，大多数情况下，我们直接使用RenderBox就可以了，除非遇到要自定义布局模型或坐标系统的情况，下面我们重点介绍一下RenderBox。 布局过程 Constraints 在 RenderBox 中，有个 size属性用来保存控件的宽和高。RenderBox的layout是通过在组件树中从上往下传递BoxConstraints对象的实现的。BoxConstraints对象可以限制子节点的最大和最小宽高，子节点必须遵守父节点给定的限制条件。 在布局阶段，父节点会调用子节点的layout()方法，下面我们看看RenderObject中layout()方法的大致实现（删掉了一些无关代码和异常捕获）: void layout(Constraints constraints, { bool parentUsesSize = false }) { ... RenderObject relayoutBoundary; if (!parentUsesSize || sizedByParent || constraints.isTight || parent is! RenderObject) { relayoutBoundary = this; } else { final RenderObject parent = this.parent; relayoutBoundary = parent._relayoutBoundary; } ... if (sizedByParent) { performResize(); } performLayout(); ... } 可以看到layout方法需要传入两个参数，第一个为constraints，即 父节点对子节点大小的限制，该值根据父节点的布局逻辑确定。另外一个参数是 parentUsesSize，该值用于确定 relayoutBoundary，该参数表示子节点布局变化是否影响父节点，如果为true，当子节点布局发生变化时父节点都会标记为需要重新布局，如果为false，则子节点布局发生变化后不会影响父节点。 relayoutBoundary 上面layout()源码中定义了一个relayoutBoundary变量，什么是 relayoutBoundary？在前面介绍Element时，我们讲过当一个Element标记为 dirty 时便会重新build，这时 RenderObject 便会重新布局，我们是通过调用 markNeedsBuild() 来标记Element为dirty的。在 RenderObject中有一个类似的markNeedsLayout()方法，它会将 RenderObject 的布局状态标记为 dirty，这样在下一个frame中便会重新layout，我们看看RenderObject的markNeedsLayout()的部分源码： void markNeedsLayout() { ... assert(_relayoutBoundary != null); if (_relayoutBoundary != this) { markParentNeedsLayout(); } else { _needsLayout = true; if (owner != null) { ... owner._nodesNeedingLayout.add(this); owner.requestVisualUpdate(); } } } 代码大致逻辑是先判断自身是不是 relayoutBoundary，如果不是就继续向 parent 查找，一直向上查找到是 relayoutBoundary 的 RenderObject为止，然后再将其标记为 dirty 的。这样来看它的作用就比较明显了，意思就是当一个控件的大小被改变时可能会影响到它的 parent，因此 parent 也需要被重新布局，那么到什么时候是个头呢？答案就是 relayoutBoundary，如果一个 RenderObject 是 relayoutBoundary，就表示它的大小变化不会再影响到 parent 的大小了，于是 parent 也就不用重新布局了。 performResize 和 performLayout RenderBox实际的测量和布局逻辑是在performResize() 和 performLayout()两个方法中，RenderBox子类需要实现这两个方法来定制自身的布局逻辑。根据layout() 源码可以看出只有 sizedByParent 为 true 时，performResize() 才会被调用，而 performLayout() 是每次布局都会被调用的。sizedByParent 意为该节点的大小是否仅通过 parent 传给它的 constraints 就可以确定了，即该节点的大小与它自身的属性和其子节点无关，比如如果一个控件永远充满 parent 的大小，那么 sizedByParent就应该返回true，此时其大小在 performResize() 中就确定了，在后面的 performLayout() 方法中将不会再被修改了，这种情况下 performLayout() 只负责布局子节点。 在 performLayout() 方法中除了完成自身布局，也必须完成子节点的布局，这是因为只有父子节点全部完成后布局流程才算真正完成。所以最终的调用栈将会变成：layout() > performResize()/performLayout() > child.layout() > ... ，如此递归完成整个UI的布局。 RenderBox子类要定制布局算法不应该重写layout()方法，因为对于任何RenderBox的子类来说，它的layout流程基本是相同的，不同之处只在具体的布局算法，而具体的布局算法子类应该通过重写performResize() 和 performLayout()两个方法来实现，他们会在layout()中被调用。 ParentData 当layout结束后，每个节点的位置（相对于父节点的偏移）就已经确定了，RenderObject就可以根据位置信息来进行最终的绘制。但是在layout过程中，节点的位置信息怎么保存？对于大多数RenderBox子类来说如果子类只有一个子节点，那么子节点偏移一般都是Offset.zero ，如果有多个子节点，则每个子节点的偏移就可能不同。而子节点在父节点的偏移数据正是通过RenderObject的parentData属性来保存的。在RenderBox中，其parentData属性默认是一个BoxParentData对象，该属性只能通过父节点的setupParentData()方法来设置： abstract class RenderBox extends RenderObject { @override void setupParentData(covariant RenderObject child) { if (child.parentData is! BoxParentData) child.parentData = BoxParentData(); } ... } BoxParentData定义如下： /// Parentdata 会被RenderBox和它的子类使用. class BoxParentData extends ParentData { /// offset表示在子节点在父节点坐标系中的绘制偏移 Offset offset = Offset.zero; @override String toString() => 'offset=$offset'; } 一定要注意，RenderObject的parentData 只能通过父元素设置. 当然，ParentData并不仅仅可以用来存储偏移信息，通常所有和子节点特定的数据都可以存储到子节点的ParentData中，如ContainerBox的ParentData就保存了指向兄弟节点的previousSibling和nextSibling，Element.visitChildren()方法也正是通过它们来实现对子节点的遍历。再比如KeepAlive Widget，它使用KeepAliveParentDataMixin（继承自ParentData） 来保存子节的keepAlive状态。 绘制过程 RenderObject可以通过paint()方法来完成具体绘制逻辑，流程和布局流程相似，子类可以实现paint()方法来完成自身的绘制逻辑，paint()签名如下： void paint(PaintingContext context, Offset offset) { } 通过context.canvas可以取到Canvas对象，接下来就可以调用Canvas API来实现具体的绘制逻辑。 如果节点有子节点，它除了完成自身绘制逻辑之外，还要调用子节点的绘制方法。我们以RenderFlex对象为例说明： @override void paint(PaintingContext context, Offset offset) { // 如果子元素未超出当前边界，则绘制子元素 if (_overflow 代码很简单，首先判断有无溢出，如果没有则调用defaultPaint(context, offset)来完成绘制，该方法源码如下： void defaultPaint(PaintingContext context, Offset offset) { ChildType child = firstChild; while (child != null) { final ParentDataType childParentData = child.parentData; //绘制子节点， context.paintChild(child, childParentData.offset + offset); child = childParentData.nextSibling; } } 很明显，由于Flex本身没有需要绘制的东西，所以直接遍历其子节点，然后调用paintChild()来绘制子节点，同时将子节点ParentData中在layout阶段保存的offset加上自身偏移作为第二个参数传递给paintChild()。而如果子节点还有子节点时，paintChild()方法还会调用子节点的paint()方法，如此递归完成整个节点树的绘制，最终调用栈为： paint() > paintChild() > paint() ... 。 当需要绘制的内容大小溢出当前空间时，将会执行paintOverflowIndicator() 来绘制溢出部分提示，这个就是我们经常看到的溢出提示，如： RepaintBoundary 我们已经在CustomPaint一节中介绍过RepaintBoundary，现在我们深入的了解一些。与 RelayoutBoundary 相似，RepaintBoundary是用于在确定重绘边界的，与 RelayoutBoundary 不同的是，这个绘制边界需要由开发者通过RepaintBoundary Widget自己指定，如： CustomPaint( size: Size(300, 300), //指定画布大小 painter: MyPainter(), child: RepaintBoundary( child: Container(...), ), ), 下面我们看看RepaintBoundary的原理，RenderObject有一个isRepaintBoundary属性，该属性决定这个RenderObject重绘时是否独立于其父元素，如果该属性值为true ，则独立绘制，反之则一起绘制。那独立绘制是怎么实现的呢？ 答案就在paintChild()源码中： void paintChild(RenderObject child, Offset offset) { ... if (child.isRepaintBoundary) { stopRecordingIfNeeded(); _compositeChild(child, offset); } else { child._paintWithContext(this, offset); } ... } 我们可以看到，在绘制子节点时，如果child.isRepaintBoundary 为 true则会调用_compositeChild()方法，_compositeChild()源码如下： void _compositeChild(RenderObject child, Offset offset) { // 给子节点创建一个layer ，然后再上面绘制子节点 if (child._needsPaint) { repaintCompositedChild(child, debugAlsoPaintedParent: true); } else { ... } assert(child._layer != null); child._layer.offset = offset; appendLayer(child._layer); } 很明显了，独立绘制是通过在不同的layer（层）上绘制的。所以，很明显，正确使用isRepaintBoundary属性可以提高绘制效率，避免不必要的重绘。具体原理是：和触发重新build和layout类似，RenderObject也提供了一个markNeedsPaint()方法，其源码如下： void markNeedsPaint() { ... //如果RenderObject.isRepaintBoundary 为true,则该RenderObject拥有layer，直接绘制 if (isRepaintBoundary) { ... if (owner != null) { //找到最近的layer，绘制 owner._nodesNeedingPaint.add(this); owner.requestVisualUpdate(); } } else if (parent is RenderObject) { // 没有自己的layer, 会和一个祖先节点共用一个layer assert(_layer == null); final RenderObject parent = this.parent; // 向父级递归查找 parent.markNeedsPaint(); assert(parent == this.parent); } else { // 如果直到根节点也没找到一个Layer，那么便需要绘制自身，因为没有其它节点可以绘制根节点。 if (owner != null) owner.requestVisualUpdate(); } } 可以看出，当调用 markNeedsPaint() 方法时，会从当前 RenderObject 开始一直向父节点查找，直到找到 一个isRepaintBoundary 为 true的RenderObject 时，才会触发重绘，这样便可以实现局部重绘。当 有RenderObject 绘制的很频繁或很复杂时，可以通过RepaintBoundary Widget来指定isRepaintBoundary 为 true，这样在绘制时仅会重绘自身而无需重绘它的 parent，如此便可提高性能。 还有一个问题，通过RepaintBoundary Widget如何设置isRepaintBoundary属性呢？其实如果使用了RepaintBoundary Widget，其对应的RenderRepaintBoundary会自动将isRepaintBoundary设为true的： class RenderRepaintBoundary extends RenderProxyBox { /// Creates a repaint boundary around [child]. RenderRepaintBoundary({ RenderBox child }) : super(child); @override bool get isRepaintBoundary => true; } 命中测试 我们在”事件处理与通知“一章中已经讲过Flutter事件机制和命中测试流程，本节我们看一下其内部实现原理。 一个对象是否可以响应事件，取决于其对命中测试的返回，当发生用户事件时，会从根节点（RenderView）开始进行命中测试，下面是RenderView的hitTest()源码： bool hitTest(HitTestResult result, { Offset position }) { if (child != null) child.hitTest(result, position: position); //递归子RenderBox进行命中测试 result.add(HitTestEntry(this)); //将测试结果添加到result中 return true; } 我们再看看RenderBox默认的hitTest()实现： bool hitTest(HitTestResult result, { @required Offset position }) { ... if (_size.contains(position)) { if (hitTestChildren(result, position: position) || hitTestSelf(position)) { result.add(BoxHitTestEntry(this, position)); return true; } } return false; } 我们看到默认的实现里调用了hitTestSelf()和hitTestChildren()两个方法，这两个方法默认实现如下： @protected bool hitTestSelf(Offset position) => false; @protected bool hitTestChildren(HitTestResult result, { Offset position }) => false; hitTest 方法用来判断该 RenderObject 是否在被点击的范围内，同时负责将被点击的 RenderBox 添加到 HitTestResult 列表中，参数 position 为事件触发的坐标（如果有的话），返回 true 则表示有 RenderBox 通过了命中测试，需要响应事件，反之则认为当前RenderBox没有命中。在继承RenderBox时，可以直接重写hitTest()方法，也可以重写 hitTestSelf() 或 hitTestChildren(), 唯一不同的是 hitTest()中需要将通过命中测试的节点信息添加到命中测试结果列表中，而 hitTestSelf() 和 hitTestChildren()则只需要简单的返回true或false。 语义化 语义化即Semantics，主要是提供给读屏软件的接口，也是实现辅助功能的基础，通过语义化接口可以让机器理解页面上的内容，对于有视力障碍用户可以使用读屏软件来理解UI内容。如果一个RenderObject要支持语义化接口，可以实现 describeApproximatePaintClip和 visitChildrenForSemantics方法和semanticsAnnotator getter。更多关于语义化的信息可以查看API文档。 总结 本节我们介绍了RenderObject主要的功能和方法，理解这些内容可以帮助我们更好的理解Flutter UI底层原理。我们也可以看到，如果要从头到尾实现一个RenderObject是比较麻烦的，我们必须去实现layout、绘制和命中测试逻辑，但是值得庆幸的是，大多数时候我们可以直接在Widget层通过组合或者CustomPaint完成自定义UI。如果遇到只能定义一个新RenderObject的场景时（如要实现一个新的layout算法的布局容器），可以直接继承自RenderBox，这样可以帮我们减少一部分工作。 "},"chapter14/flutter_app_startup.html":{"url":"chapter14/flutter_app_startup.html","title":"Flutter从启动到显示","keywords":"","body":"Flutter运行机制-从启动到显示 Flutter的入口在\"lib/main.dart\"的main()函数中，它是Dart应用程序的起点。在Flutter应用中，main()函数如下： void main() { runApp(MyApp()); } 可以看main()函数只调用了一个runApp()方法，我们看看runApp()方法中都做了什么： void runApp(Widget app) { WidgetsFlutterBinding.ensureInitialized() ..attachRootWidget(app) ..scheduleWarmUpFrame(); } 参数app是一个Widget，它是Flutter应用启动后要展示的第一个Widget。而WidgetsFlutterBinding正是绑定Widget 框架和Flutter engine的桥梁，定义如下： class WidgetsFlutterBinding extends BindingBase with GestureBinding, ServicesBinding, SchedulerBinding, PaintingBinding, SemanticsBinding, RendererBinding, WidgetsBinding { static WidgetsBinding ensureInitialized() { if (WidgetsBinding.instance == null) WidgetsFlutterBinding(); return WidgetsBinding.instance; } } 可以看到WidgetsFlutterBinding继承自 BindingBase 并混入了很多Binding，在介绍这些Binding之前我们先介绍一下Window对象。我们看看Window的官方解释： The most basic interface to the host operating system's user interface. 很明显，Window正是Flutter Framework连接宿主操作系统的接口。我们看一下Window类的部分定义： class Window { // 当前设备的DPI，即一个物理相许显示多少逻辑像素，数字越大，显示效果就越精细保真。 // DPI是设备屏幕的固件属性，如Nexus 6的屏幕DPI为3.5 double get devicePixelRatio => _devicePixelRatio; // Flutter UI绘制区域的大小 Size get physicalSize => _physicalSize; // 当前系统默认的语言Locale Locale get locale; // 当前系统字体缩放比例。 double get textScaleFactor => _textScaleFactor; // 当绘制区域大小改变回调 VoidCallback get onMetricsChanged => _onMetricsChanged; // Locale发生变化回调 VoidCallback get onLocaleChanged => _onLocaleChanged; // 系统字体缩放变化回调 VoidCallback get onTextScaleFactorChanged => _onTextScaleFactorChanged; // 绘制前回调，一般会受显示器的垂直同步信号VSync驱动，当屏幕刷新时就会被调用 FrameCallback get onBeginFrame => _onBeginFrame; // 绘制回调 VoidCallback get onDrawFrame => _onDrawFrame; // 点击或指针事件回调 PointerDataPacketCallback get onPointerDataPacket => _onPointerDataPacket; // 调度Frame，该方法执行后，onBeginFrame和onDrawFrame将紧接着会在合适时机被调用， // 此方法会直接调用Flutter engine的Window_scheduleFrame方法 void scheduleFrame() native 'Window_scheduleFrame'; // 更新应用在GPU上的渲染,此方法会直接调用Flutter engine的Window_render方法 void render(Scene scene) native 'Window_render'; // 发送平台消息 void sendPlatformMessage(String name, ByteData data, PlatformMessageResponseCallback callback) ; // 平台通道消息处理回调 PlatformMessageCallback get onPlatformMessage => _onPlatformMessage; ... //其它属性及回调 } 可以看到Window类包含了当前设备和系统的一些信息以及Flutter Engine的一些回调。现在我们再回来看看WidgetsFlutterBinding混入的各种Binding。通过查看这些 Binding的源码，我们可以发现这些Binding中基本都是监听并处理Window对象的一些事件，然后将这些事件按照Framework的模型包装、抽象然后分发。可以看到WidgetsFlutterBinding正是粘连Flutter engine与上层Framework的”胶水“。 GestureBinding：提供了window.onPointerDataPacket 回调，绑定Framework手势子系统，是Framework事件模型与底层事件的绑定入口。 ServicesBinding：提供了window.onPlatformMessage 回调， 用于绑定平台消息通道（message channel），主要处理原生和Flutter通信。 SchedulerBinding：提供了window.onBeginFrame和window.onDrawFrame回调，监听刷新事件，绑定Framework绘制调度子系统。 PaintingBinding：绑定绘制库，主要用于处理图片缓存。 SemanticsBinding：语义化层与Flutter engine的桥梁，主要是辅助功能的底层支持。 RendererBinding: 提供了window.onMetricsChanged 、window.onTextScaleFactorChanged 等回调。它是渲染树与Flutter engine的桥梁。 WidgetsBinding：提供了window.onLocaleChanged、onBuildScheduled 等回调。它Flutter Widget层与engine的桥梁。 WidgetsFlutterBinding.ensureInitialized()负责初始化一个WidgetsBinding的全局单例，紧接着会调用WidgetsBinding的attachRootWidget方法，该方法负责将根Widget添加到RenderView上，代码如下： void attachRootWidget(Widget rootWidget) { _renderViewElement = RenderObjectToWidgetAdapter( container: renderView, debugShortDescription: '[root]', child: rootWidget ).attachToRenderTree(buildOwner, renderViewElement); } 注意，代码中的有renderView和renderViewElement两个变量，renderView是一个RenderObject，它是渲染树的根，而renderViewElement是renderView对应的Element对象，可见该方法主要完成了 根Widget 到根 RenderObject再到更Element的整个关联过程。我们看看attachToRenderTree的源码实现： RenderObjectToWidgetElement attachToRenderTree(BuildOwner owner, [RenderObjectToWidgetElement element]) { if (element == null) { owner.lockState(() { element = createElement(); assert(element != null); element.assignOwner(owner); }); owner.buildScope(element, () { element.mount(null, null); }); } else { element._newWidget = this; element.markNeedsBuild(); } return element; } 该方法负责创建根 Element，即 RenderObjectToWidgetElement，并且将 Element 与 Widget 进行关联，即创建出 WidgetTree 对应的 ElementTree。如果 Element 已经创建过了，则将根 Element 中关联的 Widget 设为新的，由此可以看出 Element 只会创建一次，后面会进行复用。那么BuildOwner是什么呢？其实他就是Widget framework的管理类，它跟踪哪些Widget需要重新构建。 渲染 回到runApp的实现中，当调用完attachRootWidget后，最后一行会调用 WidgetsFlutterBinding 实例的 scheduleWarmUpFrame() 方法，该方法的实现在 SchedulerBinding 中，它被调用后会立即进行一次绘制（而不是等待\"Vsync\" 信号），在此次绘制结束前，该方法会锁定事件分发，也就是说在本次绘制结束完成之前Flutter将不会响应各种事件，这可以保证在绘制过程中不会再触发新的重绘。下面是scheduleWarmUpFrame() 方法的部分实现(省略了无关代码)： void scheduleWarmUpFrame() { ... Timer.run(() { handleBeginFrame(null); }); Timer.run(() { handleDrawFrame(); resetEpoch(); }); // 锁定事件 lockEvents(() async { await endOfFrame; Timeline.finishSync(); }); ... } 可以看到该方法中主要调用了handleBeginFrame() 和 handleDrawFrame() 两个方法，在看这两个方法之前我们首先了解一下 Frame 和c 的概念： Frame: 一次绘制过程，我们称其为一帧。Flutter engine受显示器垂直同步信号\"VSync\"的趋势不断的触发绘制。我们之前说的Flutter可以实现60fps（Frame Per-Second），就是指一秒钟可以触发60次重绘，FPS值越大，界面就越流畅。 FrameCallback：SchedulerBinding 类中有三个FrameCallback回调队列， 在一次绘制过程中，这三个回调队列会放在不同时机被执行： transientCallbacks：用于存放一些临时回调，一般存放动画回调。可以通过SchedulerBinding.instance.scheduleFrameCallback 添加回调。 persistentCallbacks：用于存放一些持久的回调，不能在此类回调中再请求新的绘制帧，持久回调一经注册则不能移除。SchedulerBinding.instance.addPersitentFrameCallback()，这个回调中处理了布局与绘制工作。 postFrameCallbacks：在Frame结束时只会被调用一次，调用后会被系统移除，可由 SchedulerBinding.instance.addPostFrameCallback() 注册，注意，不要在此类回调中再触发新的Frame，这可以会导致循环刷新。 现在请读者自行查看handleBeginFrame() 和 handleDrawFrame() 两个方法的源码，可以发现前者主要是执行了transientCallbacks队列，而后者执行了 persistentCallbacks 和 postFrameCallbacks 队列。 绘制 渲染和绘制逻辑在RenderBinding 中实现，查看其源发，发现在其initInstances()方法中有如下代码： void initInstances() { ... //省略无关代码 //监听Window对象的事件 ui.window ..onMetricsChanged = handleMetricsChanged ..onTextScaleFactorChanged = handleTextScaleFactorChanged ..onSemanticsEnabledChanged = _handleSemanticsEnabledChanged ..onSemanticsAction = _handleSemanticsAction; //添加PersistentFrameCallback addPersistentFrameCallback(_handlePersistentFrameCallback); } 我们看最后一行，通过addPersistentFrameCallback 向persistentCallbacks队列添加了一个回调 _handlePersistentFrameCallback: void _handlePersistentFrameCallback(Duration timeStamp) { drawFrame(); } 该方法直接调用了RenderBinding的drawFrame()方法： void drawFrame() { assert(renderView != null); pipelineOwner.flushLayout(); //布局 pipelineOwner.flushCompositingBits(); //重绘之前的预处理操作，检查RenderObject是否需要重绘 pipelineOwner.flushPaint(); // 重绘 renderView.compositeFrame(); // 将需要绘制的比特数据发给GPU pipelineOwner.flushSemantics(); // this also sends the semantics to the OS. } 我们看看这些方法分别做了什么： flushLayout() void flushLayout() { ... while (_nodesNeedingLayout.isNotEmpty) { final List dirtyNodes = _nodesNeedingLayout; _nodesNeedingLayout = []; for (RenderObject node in dirtyNodes..sort((RenderObject a, RenderObject b) => a.depth - b.depth)) { if (node._needsLayout && node.owner == this) node._layoutWithoutResize(); } } } } 源码很简单，该方法主要任务是更新了所有被标记为“dirty”的RenderObject的布局信息。主要的动作发生在node._layoutWithoutResize()方法中，该方法中会调用performLayout()进行重新布局。 flushCompositingBits() void flushCompositingBits() { _nodesNeedingCompositingBitsUpdate.sort( (RenderObject a, RenderObject b) => a.depth - b.depth ); for (RenderObject node in _nodesNeedingCompositingBitsUpdate) { if (node._needsCompositingBitsUpdate && node.owner == this) node._updateCompositingBits(); //更新RenderObject.needsCompositing属性值 } _nodesNeedingCompositingBitsUpdate.clear(); } 检查RenderObject是否需要重绘，然后更新RenderObject.needsCompositing属性，如果该属性值被标记为true则需要重绘。 flushPaint() void flushPaint() { ... try { final List dirtyNodes = _nodesNeedingPaint; _nodesNeedingPaint = []; // 反向遍历需要重绘的RenderObject for (RenderObject node in dirtyNodes..sort((RenderObject a, RenderObject b) => b.depth - a.depth)) { if (node._needsPaint && node.owner == this) { if (node._layer.attached) { // 真正的绘制逻辑 PaintingContext.repaintCompositedChild(node); } else { node._skippedPaintingOnLayer(); } } } } } 该方法进行了最终的绘制，可以看出它不是重绘了所有 RenderObject，而是只重绘了需要重绘的 RenderObject。真正的绘制是通过PaintingContext.repaintCompositedChild()来绘制的，该方法最终会调用Flutter engine提供的Canvas API来完成绘制。 compositeFrame() void compositeFrame() { ... try { final ui.SceneBuilder builder = ui.SceneBuilder(); final ui.Scene scene = layer.buildScene(builder); if (automaticSystemUiAdjustment) _updateSystemChrome(); ui.window.render(scene); //调用Flutter engine的渲染API scene.dispose(); } finally { Timeline.finishSync(); } } 这个方法中有一个Scene对象，Scene对象是一个数据结构，保存最终渲染后的像素信息。这个方法将Canvas画好的Scene传给window.render()方法，该方法会直接将scene信息发送给Flutter engine，最终又engine将图像画在设备屏幕上。 最后 需要注意的是：由于RenderBinding只是一个mixin，而with它的是WidgetBinding，所以我们需要看看WidgetBinding中是否重写该方法，查看WidgetBinding的drawFrame()方法源码： @override void drawFrame() { ...//省略无关代码 try { if (renderViewElement != null) buildOwner.buildScope(renderViewElement); super.drawFrame(); //调用RenderBinding的drawFrame()方法 buildOwner.finalizeTree(); } } 我们发现在调用RenderBinding.drawFrame()方法前会调用 buildOwner.buildScope() （非首次绘制），该方法会将被标记为“dirty” 的 Element 进行 rebuild() 。 总结 本节介绍了Flutter APP从启动到显示到屏幕上的主流程，读者可以结合前面章节对Widget、Element以及RenderObject的介绍来加强细节理解。 "}}